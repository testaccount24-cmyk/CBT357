/**  REXX  -- GEN COBOL OFFSETS IN COLUMNS 73 THRU 80             **/

/**  COBCOLS USES INSYNC TO DETERMINE COBOL STRUCTURE OFFSETS     **/
/**  AND PLACE THEM IN COLUMNS 73 THRU 80.  IT WILL WORK WITHIN   **/
/**  A RANGE SPECIFIED BY C/CC/C## OR OVER THE ENTIRE FILE.       **/

/**  THE OFFSETS ARE SHOWN AS ZZZ9ZZZ9.                           **/

/*  SET UP ISPF ENVIRONMENT AND DETERMINE STARTING/ENDING LINES    */
   SAVEMSG=MSG()
   X=MSG("OFF")
   X=ADDRESS()
   SUBCOM ISPEXEC
   IF RC <> 0 THEN DO
         SAY "COBCOLS MUST BE RUN UNDER ISPF EDIT!"
         SIGNAL QUIT
       END
   SUBCOM ISREDIT
   UMODE = "ISREDIT"
   ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
   ADDRESS ISREDIT
   "MACRO (PARM) NOPROCESS"
   IF PARM = "?" THEN SIGNAL DISPDOC
   "PROCESS RANGE C"
   IF RC > 0 THEN DO
      "(TOP) = LINENUM .ZFIRST"
      "(BOT) = LINENUM .ZLAST"
   END
   ELSE DO
      "(TOP) = LINENUM .ZFRANGE"
      "(BOT) = LINENUM .ZLRANGE"
   END

/*  DELETE OLD TEMP PDS FILE, IF ANY, AND ALLOCATE NEW ONE         */
   ADDRESS TSO
   "FREE DD(DDXX #INDD)"
   "DELETE $$$TEMP.COPYBOOK.PDS"
   "ALLOCATE DD(#INDD) DSN($$$TEMP.COPYBOOK.PDS) NEW UNIT(SYSDA)",
      "CYL SPACE(01 01) RECFM(F B) LRECL(80) BLKSIZE(27920) DIR(12)"
   "ALLOCATE DD(DDXX) DSN($$$TEMP.COPYBOOK.PDS(DUMMYMEM)) SHR"

/*  WRITE LINES IN SPECIFIED RANGE TO TEMP PDS FILE AS MEMBER      */
   "EXECIO 0 DISKW" DDXX "(OPEN"
   GOT_FIRST = 'NO'
   DO II = TOP TO BOT BY 1
      "ISREDIT (RECORD) = LINE &II"
      IF SUBSTR(RECORD,7,1) <> '*',
               & SUBSTR(RECORD,7,1) <> '/',
               & SUBSTR(RECORD,8,65) <> ' ' THEN DO
         IF GOT_FIRST = 'NO' THEN DO
            IF INDEX(SUBSTR(RECORD,8,4),'1') = 0 THEN DO
               DUMMY_REC = '       01  DUMMY-01-LEVEL.'
               PUSH DUMMY_REC
               ADDRESS TSO "EXECIO 1 DISKW" DDXX
            END
            GOT_FIRST = 'YES'
         END
         BB = INDEX(RECORD,'( ');
         DO WHILE ( BB <> 0 );
            RECORD = SUBSTR(RECORD,1,BB) || SUBSTR(RECORD,BB+2)
            BB = INDEX(RECORD,'( ');
         END
         PUSH RECORD
         ADDRESS TSO "EXECIO 1 DISKW" DDXX
      END
   END
   ADDRESS TSO
   "EXECIO 0 DISKW" DDXX "(FINIS"
   "FREE DD(DDXX)"

/*  FREE & ALLOCATE FILES FOR CALL TO INSYNC                       */
   "FREE DD(#PARM #PRINT #LOG SYSTSPRT #ELIBDD)"
   "DELETE $$$TEMP.PARM.FILE"
   "ALLOC DD(#PARM) DSN($$$TEMP.PARM.FILE) NEW TRACKS SPACE(1)",
      "UNIT(SYSDA) LRECL(80) BLKSIZE(800) RECFM(F B)"
   QUEUE "FUNCTION=LAYOUT"
   QUEUE "INDD=#INDD"
   QUEUE "MEMBER=DUMMYMEM"
   QUEUE "LINESPERPAGE=999"
   "EXECIO" QUEUED() "DISKW #PARM (FINIS"
   "DELETE $$$TEMP.PRINT.FILE"
   "ALLOCATE DD(#PRINT) DSN($$$TEMP.PRINT.FILE) NEW UNIT(SYSDA)",
      "CYL SPACE(10,10) RECFM(F B A) LRECL(133) BLKSIZE(27930)",
      "RELEASE"
   "DELETE $$$TEMP.LOG.FILE"
   "ALLOCATE DD(#LOG) DSN($$$TEMP.LOG.FILE) NEW UNIT(SYSDA)",
      "CYL SPACE(01,01) RECFM(F B A) LRECL(133) BLKSIZE(27930)"
   "ALLOCATE DD(SYSTSPRT) DUMMY"
   "ALLOCATE DD(#ELIBDD) DSN('TCH.PROD.INSYNC.ELIB') SHR"
   "CALL 'TCH.PROD.INSYNC.LOADLIB(INSYNC)' 'MVS'"

/*  READ PRINT FILE AND STRIP OFF OFFSETS INTO LAST 8 BYTES OF   */
/*  APPROPRIATE RECORDS                                          */
   ADDRESS ISREDIT
   ADDRESS TSO "EXECIO 0 DISKR" #PRINT "(OPEN"

   CALL GET_LAYOUT
   DO II = TOP TO BOT BY 1
      IF INDEX(SCANSTR,'(1)') <> 0 THEN DO
         CALL GET_OCCURS
         "ISREDIT (RECORD) = LINE &II"
         IF SCANSTR = "FILLER" THEN SCANSTR = END_COL - START_COL + 1
         IF SUBSTR(RECORD,7,1) <> "*",
               & SUBSTR(RECORD,7,1) <> "/",
               & SUBSTR(RECORD,8,65) <> " ",
               & INDEX(RECORD,SCANSTR) <> 0 THEN DO
            RECORD = SUBSTR(RECORD,1,72),
               || START_COL || END_COL
            "ISREDIT LINE &II = &STR(RECORD)"
            CALL GET_LAYOUT
         END
      END
      ELSE DO
         IF INDEX(SCANSTR,'(') = 0 THEN DO
            CALL GET_COLS
            "ISREDIT (RECORD) = LINE &II"
            IF SCANSTR = "FILLER" THEN SCANSTR = END_COL - START_COL + 1
            IF SUBSTR(RECORD,7,1) <> "*",
                  & SUBSTR(RECORD,7,1) <> "/",
                  & SUBSTR(RECORD,8,65) <> " ",
                  & INDEX(RECORD,SCANSTR) <> 0 THEN DO
               RECORD = SUBSTR(RECORD,1,72),
                  || START_COL || END_COL
               "ISREDIT LINE &II = &STR(RECORD)"
               CALL GET_LAYOUT
            END
         END
         ELSE CALL GET_LAYOUT
      END
   END II

SHORT:
   ADDRESS TSO "EXECIO 0 DISKR" #PRINT "(FINIS"
   ADDRESS TSO
   "FREE DD(#PARM #INDD #PRINT #LOG SYSTSPRT #ELIBDD)"
   "DELETE $$$TEMP.PARM.FILE"
   "DELETE $$$TEMP.PRINT.FILE"
   "DELETE $$$TEMP.COPYBOOK.PDS"
   "DELETE $$$TEMP.LOG.FILE"
   ADDRESS ISPEXEC
   X=MSG(SAVEMSG)
   EXIT(0)

GET_LAYOUT:
   CALL DO_DISKR
   IF RET_CD <> 0 THEN SIGNAL SHORT
   IF INDEX(LAYLINE,'DUMMY-01-LEVEL') <> 0 THEN SIGNAL GET_LAYOUT
   IF DATATYPE(SUBSTR(LAYLINE,8,1)) <> "NUM" THEN SIGNAL GET_LAYOUT
   DO  NN = 61 TO 1 BY -1 WHILE ( SUBSTR(LAYLINE,NN,1) = ' ' )
   END NN
   DO  MM = NN TO 1 BY -1 WHILE ( SUBSTR(LAYLINE,MM,1) <> ' ' )
   END MM
   MM = MM + 1
   SCANSTR = SUBSTR(LAYLINE,MM,NN-MM+1)
   IF SCANSTR = 'DUMMY-01-LEVEL' THEN SIGNAL GET_LAYOUT
   RETURN

DO_DISKR:
   ADDRESS TSO "EXECIO 1 DISKR" #PRINT
   RET_CD = RC
   IF RET_CD <> 0 THEN SIGNAL SHORT
   PULL LAYLINE
   IF SUBSTR(LAYLINE,1,1) = '1' THEN DO
      DO WHILE ( INDEX(LAYLINE,'FIELD NAME') = 0 )
         CALL DO_DISKR
      END
      CALL DO_DISKR
      RET_CD = RC
   END
   RETURN

GET_COLS:
   START_COL = SUBSTR(LAYLINE,77,4)
   DO SS = 80 TO 75 BY -1 WHILE ( SUBSTR(LAYLINE,SS,1) <> ' ' )
   END SS
   SS = SUBSTR(LAYLINE,SS+1,80-SS)
   DO TT = 87 TO 82 BY -1 WHILE ( SUBSTR(LAYLINE,TT,1) <> ' ' )
   END TT
   TT = SUBSTR(LAYLINE,TT+1,87-TT)
   UU = SS + TT - 1
   END_COL = RIGHT(UU,4,' ')
   RETURN

GET_OCCURS:
   SCANSTR = SUBSTR(SCANSTR,1,LENGTH(SCANSTR)-3)
   START_COL = SUBSTR(LAYLINE,77,4)
   CALL DO_DISKR
   OO = INDEX(LAYLINE,'OCCURS')
   IF OO <> 0 THEN DO
      OO = OO + 6
      DO PP = OO TO 61 BY 1 WHILE ( SUBSTR(LAYLINE,PP,1) = ' ')
      END PP
      DO QQ = PP+1 TO 61 BY 1 WHILE ( SUBSTR(LAYLINE,QQ,1) <> ' ')
      END QQ
      RR = SCANSTR || '(' || SUBSTR(LAYLINE,PP,QQ-PP) || ')'
   END
   CALL DO_DISKR
   DO WHILE ( INDEX(LAYLINE,RR) = 0 )
      CALL DO_DISKR
   END
   DO SS = 80 TO 75 BY -1 WHILE ( SUBSTR(LAYLINE,SS,1) <> ' ' )
   END SS
   SS = SUBSTR(LAYLINE,SS+1,80-SS)
   DO TT = 87 TO 82 BY -1 WHILE ( SUBSTR(LAYLINE,TT,1) <> ' ' )
   END TT
   TT = SUBSTR(LAYLINE,TT+1,87-TT)
   UU = SS + TT - 1
   END_COL = RIGHT(UU,4,' ')
   RETURN

DISPDOC:
   ADDRESS TSO "CLEAR"
   SAY "COBCOLS - PLACE DATA OFFSETS IN COLUMN 73 THRU 80         "
   SAY
   SAY " FORMAT "
   SAY
   SAY "    COBCOLS  ( ? )                                        "
   SAY
   SAY "       INVOKES INSYNC AND OTHER PROGRAMS TO DETERMINE     "
   SAY "       COBOL DATA STRUCTURE OFFSETS AND PLACE THEM IN     "
   SAY "       COLUMNS 73 THROUGH 80 AS ZZZ9ZZZ9.                 "
   SAY
   SAY "       THE RANGE OF OFFSETS IS 1 TO 9999.                 "
   SAY
   SAY "       A QUESTION MARK WILL CAUSE THIS HELP TO BE SHOWN.  "
   SAY "       C/C#/CC PREFIX COMMANDS MAY BE USED TO LIMIT THE   "
   SAY "       LINES PROCESSED.                                   "
   SAY
   EXIT(1)

