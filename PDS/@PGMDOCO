:*  Full formal documentation for all programs included
:PAGESIZE  55
:LINESIZE  80
:TOC       YES
:DOCTITLE  ABENDX
:DOCTITLE2 Force User ABEND
:TLRDATE   September 14, 2002
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for the
 utility to force user abnormal terminations (ABENDX). Some
 understanding of Job Control Language (JCL) is required as well
 as knowledge of how programs are executed.

 ABENDX is mainframe freeware. It's available for any use you
 wish to make of it.

 ABENDX is intended for MVS compatible systems to call the system
 ABEND routine with a parameter specified user code or to force
 specific system abends such as 0C1, allowing testing of JCL and
 restart conditions without having to do program changes. It may
 even be called from REXX or CLIST.

 ABENDX is an Assembler program that accepts a PARM parameter of
 a number between 0 and 4095, the legitimate user ABEND codes
 acceptable to MVS.  ABENDX will also accept PARM values of 0C1,
 0C2, 0C3, 0C4, 0C6, 0C7, 0C8, 0C9 and 0CB and will force that
 specific ABEND.  IF no value or a bad value is passed, the
 return code is set to 4095 and the ABEND occurs.

 Steli Inc. has made its best effort to provide working, tested
 code.  However, nothing is perfect - there may be flaws and
 there certainly could be improvements.  All questions, concerns,
 problems and suggestions are welcome.  Please e-mail them to
 C_Hafner@HotMail.Com.


:HEADER1   EXECUTION JCL

 The job control language (JCL) for ABENDX is:

           //DIE        EXEC     PGM=ABENDX,PARM=#

           //STEPLIB      DD       DISP=SHR,DSN=...

 The name of the program may be changed as desired providing
 that the actual program is linked with the appropriate name
 or alias.

 REGION is optional.  STEPLIB may be optional if ABENDX is
 placed in the system's link list but otherwise simply points to
 where ABENDX is stored.

 The only real input is provided by the PARM statement. The
 number provided will be used to set the user ABEND code or the
 system abend code will be used to force the program's
 termination.  Since ABENDX operates like IEFBR14, file
 allocation or deletion may be performed within its JCL.


:HEADER1   SAMPLE JCL AND OUTPUT

 An example of JCL that may be used is:

      //TEST412   EXEC  PGM=ABENDX,PARM=412

      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB

 The above step will cause the following JES message to be
 generated:

       12.34.56 JOB00123  IEF450I USERNMA ABEND ...
             - ABEND=S000 U0412  REASON=00000000

 An example of how ABENDX might be used to force an ABEND within a
 REXX EXEC is:

      /**  REXX  **/

         ADDRESS TSO

         "CALL 'your-user-ID.LOADLIB(ABENDX)' '0412'"



:HEADER1   PACKAGE CONTENTS

 The files involved specifically with ABENDX are:

     - ABENDX     the Assembler code wrapped in JCL to
                  assemble and link edit it

     - ABENDX$    a JCL skeleton for its execution

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  ADDCC
:DOCTITLE2 Add Carriage Control
:DOCTITLE3 to a Sequential File
:TLRDATE   September 7, 2002
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for adding
 carriage control data and minimal word processing structures to
 a sequential file (ADDCC).  Some understanding of Job Control
 Language (JCL) is required as well as knowledge of how programs
 are executed.

 ADDCC is mainframe freeware. Use it, change it, or rip it
 apart.

 ADDCC is a PL/I program intended for MVS compatible systems to
 add ASCII carriage control to a sequential data set. It allows
 the use of a pseudo text descriptor language to generate a title
 page, to provide a table of contents, to set page and line size,
 and to separate sections.

 ADDCC is intended to simplify documentation maintenance.  It's a
 small, cheap text scripting tool that does page generation so
 you don't have to do all sorts of editing when you add or remove
 a few lines.  And, if asked, it will generate a table of
 contents based on section naming.

 Steli Inc. has made its best effort to provide working,
 tested code.  However, nothing is perfect - there may be
 flaws and there certainly could be improvements.  All
 questions, concerns, problems and suggestions are welcome.
 E-mail may be sent to C_Hafner@HotMail.Com for the preceding.


:HEADER1   EXECUTION JCL

 The job control language (JCL) for ADDCC is:

           //ADDCC      EXEC     PGM=ADDCC,    ( ,REGION=64M, )

           //             PARM='HEAP(01M,01M,ANYWHERE)'

           //I            DD       DISP=SHR,DSN=...

           //O            DD       SYSOUT=*,

           //             DCB=(RECFM=FA,LRECL=...,BLKSIZE=.....)

           //STEPLIB      DD       DISP=SHR,DSN=...

 Optional control language elements are shown in parentheses.
 The name of the program  may be changed as desired providing
 that the actual program is linked with the appropriate name
 or alias.

 REGION is optional but ADDCC does all its processing in core, so
 REGION=64M can't hurt.  STEPLIB may be optional if ADDCC is
 placed in the system's link list but otherwise simply points to
 where ADDCC is stored.

 The I file points to the input file to be processed.  All normal
 text should begin in column 2 or beyond (which allows you to put
 your own carriage control, if desired, in column 1).  The
 descriptor language should be prefixed by a colon (:) and begin
 in column 1 (that colon vanishes when the descriptor is
 resolved).  These are generally described here and samples shown
 below.

 Page size, that is, the number of lines placed on each page, is
 specified as :PAGESIZE ##, where ## defaults to 58.  The first
 page will always have a '1' (new page) as the carriage control -
 this will allow concatenating several runs of ADDCC together.
 The logical record length, AKA line size, is specified as
 :LINESIZE ##, where ## defaults to 72. These may be changed
 within the code.

 :DOCTITLE, :DOCTITLE2 and :DOCTITLE3 may be used to have title
 lines centered and generated on a first page. :TLRDATE may
 specify a date/time to be placed on the left side of the last
 line on the title page, left justified.  Similarly, :TLRDESC
 will place a descriptive entry on the right side of the lowest
 line, right justified.  Obviously, any text may be specified.

 :HEADER1 xxx will signal a chapter heading; :HEADER2 yyy a
 section heading. The chapter name, xxx, will be on the top of
 every page in that chapter with "(Continued)" suffixed on the
 2nd and following pages of that chapter. The section data will
 have its first word underlined and use that word in the table of
 contents, if requested.  :HEADERT zzz are simply expanded 50
 character section descriptions which will be used in the table
 of contents. :HEADERT should immediately follow :HEADER2
 entries.

 :TOC YES (the default) will cause a table of contents to be
 generated after the title page using the chapter and section
 headings and the generated page numbers.

 :RESET allows multiple sets of documentation to be included in
 one run. It will reset the page count to 1 and start the
 carriage control with a new page character ( a 1).

 :* with any following text on that line is treated as a
 comment. It is simply read and ignored.

 The O output file may be directed to any output class or may be
 sent to a new or existing file.  The DCB attributes may be
 whatever's desired, e.g. F, FB, FA or FBA of any length and
 appropriate block size.

 Note that by specifying only the following, ADDCC may be used
 to simply add carriage control to a file with paged breaks
 every PAGESIZE:

      :PAGESIZE  55

      :LINESIZE  80

      :TOC       NO


:HEADER1   SAMPLE JCL AND OUTPUT

 An example of JCL that may be used is:

      //PRINT      EXEC     PGM=ADDCC,REGION=464M,

      //             PARM='HEAP(01M,01M,ANYWHERE)'

      //O            DD       SYSOUT=V,DEST=PRT60,

      //             DCB=(RECFM=FA,LRECL=080,BLKSIZE=00080)

      //STEPLIB      DD       DISP=SHR,DSN=USER213.K12D.LOADLIB

      //I            DD       *

      :PAGESIZE  50

      :LINESIZE  80

      :TOC       YES

      :DOCTITLE  ADDCC SAMPLE

      :DOCTITLE2 Add Carriage Control Sample Input

      :TLRDESC   Freeware from Steli Inc.


      :HEADER1   INTRODUCTION

       This is an introductory paragraph. Note the text begins in
       (logical) column 2 and the next line will cause the word
      + _______
       logical to be underscored!

      :HEADER1 A Mixed Case Chapter heading

       There will be 2 sections following, cleverly named
       FIRST and SECOND. Note this paragraph is in a chapter
       but not in a section. Blank lines and all caps may be
       used to make things more readable...

      :HEADER2 FIRST Section

         This is the first section. Note how I can indent here
         manually to make a point!
             SOME DUMB POINT

      :HEADER2 SECOND Section
      :HEADERT The Second Section Description

         This is the second and last section.

      //******** INPUT ENDS WITH PREVIOUS RECORD... ***********

 The above step has the input instream only for the virtue of the
 example.  Note the Second Section only has a :HEADERT control
 following its :HEADER2.  The actual out, shifted right 6 columns
 and having some odd non meaningful data removed, would be as
 follows:

      1
      -
      -
      -
      -
      -
      -
                                        ADDCC SAMPLE
                              Add Carriage Control Sample Input

      -
      -
      -
      -
      -
      -
      -
      -
                                                Freeware from Steli Inc.
      1                          TABLE OF CONTENTS           Page      2


       INTRODUCTION  . . . . . . . . . . . . . . . . . . . . . . .     3


       A Mixed Case Chapter heading  . . . . . . . . . . . . . . .     4

          FIRST  . . . . . . . . . . . . . . . . . . . . . . . . .     4
          SECOND . . The Second Section Description  . . . . . . .     4

      1                            INTRODUCTION              Page      3


       This is an introductory paragraph. Note the text begins in
       (logical) column 2 and the next line will cause the word
      + _______
       logical to be underscored!

      1                    A Mixed Case Chapter heading      Page      4


       There will be 2 sections following, cleverly named
       FIRST and SECOND. Note this paragraph is in a chapter
       but not in a section. Blank lines and all caps may be
       used to make things more readable...

       FIRST Section
      +_____

         This is the first section. Note how I can indent here
         manually to make a point!
             SOME DUMB POINT

       SECOND Section
      +______

         This is the second and last section.


:HEADER1   PACKAGE CONTENTS

 The files involved specifically with ADDCC are:

     - ADDCC      the PL/I code wrapped in JCL to compile
                  and link edit it

     - ADDCC$     a JCL skeleton for its execution

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  ALPHACNT
:DOCTITLE2 Alphanumeric "Counting"
:TLRDATE   January 3, 1999
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for
 counting alphanumerically (ALPHACNT). Some understanding of
 Job Control Language (JCL) is required as well as knowledge of
 how programs are executed.

 ALPHACNT is mainframe freeware. It's your toy to do with as you
 desire.

 ALPHACNT is a COBOL test program with 3 sub-programs intended
 for MVS compatible systems to provide a counting facility for
 alphanumeric values. The sub-programs are the working parts of
 this facility.  The collating sequence is 'A' through '9'
 keeping the numbers in EBCDIC sequence for sorting purposes.
 Separate sub-programs provide the next and previous value and
 there's another one to verify a value.

 ALPHACNT provides a counting scheme for visible, that is,
 displayable characters. Each byte can represent 36 values,
 'A'...'Z''0'...'9'.  The sequence is meant to be sortable as
 EBCDIC. Its implementation is as sub-programs allowing them to
 be set up as one or more copy books.

 Steli Inc. has made its best effort to provide working,
 tested code.  However, nothing is perfect - there may be
 flaws and there certainly could be improvements.  All
 questions, concerns, problems and suggestions may be sent
 to C_Hafner@HotMail.Com.


:HEADER1   SAMPLE TEST PROGRAM

 The job control language (JCL) provided for ALPHACNT has a main
 COBOL program calling the NXTALPHA, PRVALPHA and VERALPHA
 sub-programs.  It's a standalone, dynamically loaded program
 (uses LOADER rather then linking and executing) that reads a
 test set of 10 digit numbers, their expected next and previous
 values, and calls the sub-programs accordingly.  The verified
 results are then DISPLAYed.

 The test input is a small but varied set including a bad value,
 all periods.  Additionally, once it runs out of test data, it
 counts off and displays the first 100 values and the last 100
 values.

 Obviously, the counting sequence is all encompassing but
 arbitrary.  The counting is performed via translates, INSPECT
 CONVERTING, and the up and down lists may be changed. Some sites
 have chosen to not use I, L, O, and S, and these were simply
 removed.


:HEADER1   PACKAGE CONTENTS

 The file involved specifically with ALPHACNT is:

     - ALPHACNT   the COBOL main wrapped in JCL to compile and
                  execute it

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  COBBITS
:DOCTITLE2 COBOL Bit Manipulation
:TLRDATE   February 22, 2001
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for
 manipulating bits of any length within COBOL (COBBITS). Some
 understanding of Job Control Language (JCL) is required as well
 as knowledge of how programs are executed.

 COBBITS is mainframe freeware. Feel free to do with it as you will.

 COBBITS is a COBOL test program with 4 sub-programs intended for
 MVS compatible systems to provide a bit handling facility for
 COBOL.  The sub-programs allow you to set bits on or off, test
 them to "see" what's set and flip (reverse) a bit setting.  The
 bits are accessed as if they were in an array, but any structure
 or variable of any size may be passed as input.

 The calling program passes the structure containing the bits,
 which bit to process, and a two byte return code field.  The
 receiving program pretends it's processing a 1,000,000 byte
 array which is used to access the passed structure. That would
 allow 8,000,000 million bits. It can be raised if more are
 needed as the largest single COBOL variable can be 16,000,000 or
 so in size.

 Steli Inc. has made its best effort to provide working,
 tested code.  However, nothing is perfect - there may be
 flaws and there certainly could be improvements.  All
 questions, concerns, problems and suggestions are welcome
 and may be sent to C_Hafner@HotMail.Com.


:HEADER1   SAMPLE TEST PROGRAM

 The job control language (JCL) provided for COBBITS has a main
 COBOL program calling the SETON, SETOFF, TESTBIT and FLIPBIT
 sub-programs.  It's a standalone, dynamically loaded program
 (uses LOADER rather then linking and executing) that reads a
 test set of commands and their expected result. The passed
 structure is an 80 byte array which is written to the O file
 each time a command is processed (set hex on within SDSF or
 whatever you're using to view the output).  The verified results
 are then DISPLAYed.

 The test input is a small but representative set, turning bits
 on and off and checking the results.


:HEADER1   PACKAGE CONTENTS

 The files involved specifically with COBBITS are:

     - COBBITS    the COBOL main wrapped in JCL to compile and
                  execute it

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  COBHEXR
:DOCTITLE2 COBOL Hexidecimal Conversion
:TLRDATE   March 17, 2001
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for
 converting character strings to their hexidecimal equivalent,
 that is, 'ABC' to 'C1C2C3' etc. Some understanding of Job
 Control Language (JCL) is required as well as knowledge of how
 programs are executed.

 COBHEXR is mainframe freeware. Feel free to do with it as you will.
 It's a test program with the built in sub-program.

 The calling program passes the input and its length, an output
 field (twice the size of the input), and a two byte return code
 field.  The receiving program checks the length which must be
 greater then zero and less then 5,000.  It then converts the
 string and passes it and a zero return code back.

 Steli Inc. has made its best effort to provide working, tested
 code.  However, nothing is perfect - there may be flaws and
 there certainly could be improvements.  All questions, concerns,
 problems and suggestions are welcome at C_Hafner@HotMail.Com.


:HEADER1   SAMPLE TEST PROGRAM

 The job control language (JCL) provided for COBHEXR has a main
 COBOL program calling the COBHEXR sub-program.  It's a
 standalone, dynamically loaded program (uses LOADER rather then
 linking and executing) that reads a test set of commands and
 their expected result. The input structure is:

      Columns  1 -  2    Length of input

      Columns  5 - 26    Input

      Columns 29 - 72    Expected return value

 For each line of input, COBHEXR is called passing the input
 value. The returned value is checked against the expected value
 and a message is displayed if they're nor equal

 The test input is:

    12  ABCDEFGHIJKL            C1C2C3C4C5C6C7C8C9D1D2D3

    01  .                       4B

    12  LKJIHGFEDCBA            D3D2D1C9C8C7C6C5C4C3C2C1

    20  12345678901234567890    F1F2F3F4F5F6F7F8F9F0F1F2F3F4F5F6F7F8F9F0

    04  ~!@#                    A15A7C7B

    10                          40404040404040404040

 showing that varying lengths may be passed for the same input area.


:HEADER1   PACKAGE CONTENTS

 The files involved specifically with COBHEXR are:

     - COBHEXR    the COBOL main wrapped in JCL to compile and
                  execute it

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  DETAB
:DOCTITLE2 Expand Separator Character
:DOCTITLE3 Delimited File
:TLRDATE   March 12, 2003
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for the
 utility to expand separator character delimited data files
 (DETAB).  Some understanding of Job Control Language (JCL) is
 required as well as knowledge of how programs are executed.

 DETAB is mainframe freeware. It's available for any use you
 wish to make of it.

 DETAB is intended for MVS compatible systems to restructure a
 file containing some special character as a separator.  It can
 examine the file and determine the maximum length of every field
 and then rebuild the file into a new file making every field the
 maximum size, right justifying and zero padding numeric fields
 (keeping the sign, if any, left justified) and left justifying
 alphanumeric fields.
 DETAB will allow the input of a master format that will allow
 overriding the sizes and data types found. When selected, this
 option also checks that numeric fields are in fact always
 numeric and will flag fields that are bigger then specified in
 the format.

 It also generates dummy COBOL and Eastrieve copybooks/file
 layouts matching the new file and it generates a data layout
 that may be changed and input into DETAB again as a master
 format.

 When in non-master format mode, it will not generate elementary
 variable entries if no data at all was specified within the
 input for a given field.  That is, if the field was of zero
 length every time, delimiters back to back, a note is made of
 zero entry for that field and no COBOL or Easytrieve variable is
 generated.  A field will be generated in the layout output for
 an alphabetic field of zero length.

 Up to 1,000 fields may be handled (or the program may be changed
 to allow more).  Any size records of any record format may be
 passed as input and the output file is always a variable file of
 logical record length 27,994 and block size 27,998.  Obviously,
 the actual record sizes are that of the calculated fixed size
 and the resulting file may be copied via sort to a fixed file if
 so desired. But, for reasonableness of programming, the variable
 maximum size was used.

 The separator character is passed as a parameter to the program
 and may be any character.  The separator character is printed as
 input plus as its two hex character equivalent and the size of
 the restructured record is also shown.

 Once the file has been analyzed and the second phase starts
 generating expanded records, DETAB will check to see that every
 record length is the same. If not, it will generate error
 messages to SYSOUT. Some causes have been having separator
 characters within the data thereby confusing the program and
 forgetting that there was a header or trailer.

 Steli Inc. has made its best effort to provide working, tested
 code.  However, nothing is perfect - there may be flaws and
 there certainly could be improvements.  All questions, concerns,
 problems and suggestions are welcome.  Please e-mail them to
 C_Hafner@HotMail.Com.


:HEADER1   EXECUTION JCL

 The job control language (JCL) for DETAB is:

     //DETAB      EXEC     PGM=DETAB,PARM='%NNNNN',REGION=24M
     //*                                   ||||||
     //*  SEPARATOR CHARACTER  ------------+|||||
     //*  PROCESS HEADER  ------------------+||||
     //*  PROCESS TRAILER  ------------------+|||
     //*  MASTER FORMAT AVAILABLE  -----------+||
     //*  REMOVE NUMERIC DECIMAL POINTS  ------+|
     //*  PUT SIGN ON LAST DIGIT  --------------+

     //*

     //STEPLIB      DD       DISP=SHR,DSN=Your.Load.Library

     //I            DD       DISP=SHR,DSN=Your.Delimited.File,
     //             DCB=BUFNO=64

     //MASTER       DD       *
     FIELD00001                      00001  A  00
        . . .
     FIELD00012                      00005  N  03

     //O            DD       DISP=(,CATLG),
     //             DSN=Your.$$$TEMP.DETAB,
     //             UNIT=SYSDA,SPACE=(CYL,(0010,0010),RLSE),
     //             DCB=(RECFM=VB,LRECL=27994,BLKSIZE=27998,BUFNO=64)

     //OCOB         DD       DISP=(,CATLG),
     //             DSN=Your.$$$TEMP.DETAB.COBOUT,
     //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),
     //             DCB=(RECFM=FB,LRECL=80)

     //OEZ          DD       DISP=(,CATLG),
     //             DSN=Your.$$$TEMP.DETAB.EZOUT,
     //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),
     //             DCB=(RECFM=FB,LRECL=80)

     //LAYOUT       DD       SYSOUT=*,DCB=(RECFM=FB,BLKSIZE=80)

     //SYSOUT       DD       SYSOUT=*,DCB=BLKSIZE=121

     //SYSPRINT     DD       SYSOUT=*

 The name of the program may be changed as desired providing
 that the actual program is linked with the appropriate name
 or alias.

 REGION is optional.  STEPLIB may be optional if DETAB is
 placed in the system's link list but otherwise simply points to
 where DETAB is stored.

 The separator character is provided by the first character of
 the PARM statement. The sample shown above is a percent sign for
 easy visualization.  The next character specifies whether a
 header is in the file and needs to be ignored. The 3rd character
 does the same for a trailer record.

 The 4th character of the PARM indicates whether a MASTER format
 is provided which is to override the field sizes found and
 possibly the field types. The MASTER DD card may be left in the
 JCL since it will not be opened if this option is an 'N'.

 The 5th PARM character specifies whether numeric fields with
 decimal points should have the decimal point removed. Whether
 they are removed or not, DETAB will always try to align the
 explicit or implicit decimal place.

 The 6th PARM position indicates that a field with signs, plus or
 minus found in ANY record within that field, will be rolled onto
 the last character. That is, the last character gets the
 appropriate zone value, { for plus zero, } for minus zero A for
 plus one, J for minus one, etc. If only some of the fields have
 signs, the unsigned foelds will be taken as positive.

 The input separator character delimited file is specified to I;
 the O file will contain the expanded data; OCOB and OEZ will
 contain the COBOL and Easytrieve structures.  Note the COBOL and
 Easytrieve layouts should be LRECL 80. The restructured file
 (file O) will be VB/27994/27998 but can be changed as desired.

 Note that if some columns are obviously not what you desire, the
 various macros such as DELCOLS, FILLINS and FILLCOLS of File 357
 of the CBTTape will easily insert or remove columns and data.

 The SYSOUT file will contain any error or warning messages - if
 there are any, the return code for the job will not be zero.
 SYSPRINT contains the summary counts for the job and LAYOUT will
 contain the structure in a format suitable for changing and
 re-entry as the master format. Using the SE option within SDSF
 will allow you to gather the LAYOUT data and insrt in into a PDS
 as a member.


:HEADER1   SAMPLE JCL AND OUTPUT

 An example of the input that may be processed is:

     AAAAA%BBBBBBBBBB%%666666%ZZZ

     AAA%BB%%999999999%ZZZ

     AAAAA%BB%%22%ZZZ

     AAAA%BB%%4444%ZZZ

     A%BB%%1%ZZZ

 Given similar JCL to the sample JCL above, the restructured
 output would be:

     AAAAABBBBBBBBBB000666666ZZZ

     AAA  BB        999999999ZZZ

     AAAAABB        000000022ZZZ

     AAAA BB        000004444ZZZ

     A    BB        000000001ZZZ

 The print out from the job would be:

     **************************************

     ***  030802 DETAB STATS 095411092  ***

     **************************************

     ***  NUMBER RECORDS READ:            5

     ***  NUMBER RECORDS WRITTEN:         5

     ***  NUMBER ZERO LEN FIELDS:         1

       *  FIELD      3 IS ALWAYS ZERO LENGTH

     ***  SEP_CHAR VALUE RECEIVED:     X'6C' (%)

     ***  OUTPUT RECORD SIZE:            27

 The COBOL copybook would be:

     10  POS-00001                        PIC  X(00005).

     10  POS-00006                        PIC  X(00010).

     10  POS-00016                        PIC  9(00009).

     10  POS-00025                        PIC  X(00003).

 and the Easytrieve layout would be:

     POS-00001                            1       5   A

     POS-00006                            6      10   A

     POS-00016                           16       9   N  00

     POS-00025                           25       3   A

 and generated LAYOUT file is:

     FIELD00001                      00005  A  00

     FIELD00002                      00010  A  00

     FIELD00003                      00000  A  00

     FIELD00004                      00009  N  00

     FIELD00005                      00003  A  00

 Another example of the input that may be processed is:

     AAAAA%123.4%123%666666%Z

     AAA%2.3%456%999999999%ZZ

     AAAAA%345.6789%789012%22%ZZZ

     AAAA%-45.67% %4444%ZZZZ

     A%0.0%999%1%ZZZZZ

 Given similar JCL to the sample JCL above, but with a Y for
 eliminating the decimal point and for rolling signs, the
 restructured output would be:

     AAAAA0123400{123   000666666Z

     AAA  0002300{456   999999999ZZ

     AAAAA0345678I789012000000022ZZZ

     AAAA 0045670}      000004444ZZZZ

     A    0000000{999   000000001ZZZZZ

 The print out from the job would be:

     **************************************

     ***  030809 DETAB STATS 140914240  ***

     **************************************

     ***  NUMBER RECORDS READ:            5

     ***  NUMBER RECORDS WRITTEN:         5

     ***  NUMBER ZERO LEN FIELDS:         0

     ***  SEP_CHAR VALUE RECEIVED:     X'6C' (%)

     ***  OUTPUT RECORD SIZE:            33

 The COBOL copybook would be:

     10  POS-00001                        PIC  X(00005).

     10  POS-00006                        PIC S9(00008)V9(04).

     10  POS-00014                        PIC  X(00006).

     10  POS-00020                        PIC  9(00009).

     10  POS-00029                        PIC  X(00005).

 and the Easytrieve layout would be:

     POS-00001                            1       5   A

     POS-00006                            6       8   N  04

     POS-00014                           14       6   A

     POS-00020                           20       9   N  00

     POS-00029                           29       5   A

 and generated LAYOUT file is:

     FIELD00001                      00005  A  00

     FIELD00002                      00008  N  04

     FIELD00003                      00006  A  00

     FIELD00004                      00009  N  00

     FIELD00005                      00005  A  00

 Please note in the immediately previous example, the second
 field is padded on the right with 0's and gets the sign imposed
 on the last digit, the third field appears to be numeric but the
 4th record has a blank in that field causing it to be alphabetic
 and left justified, the forth field is numeric but has no signs
 and no decimal places and thus just gets left padded, and the
 last field is 5 bytes padded on the right with blanks.


:HEADER1   PACKAGE CONTENTS

 The files involved specifically with DETAB are:

     - DETAB      the PL/I code wrapped in JCL to
                  compile and link edit it

     - DETAB$     a JCL skeleton for its execution

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  DIRSCNC/DIRSCNQ
:DOCTITLE2 Read Partitioned Data Set Directory
:DOCTITLE2 and Generate Cards Images Replacing Tokens
:TLRDATE   September 9, 2003
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for the
 paired COBOL and PL/I utilities to read any Partitioned Data Set
 (PDS) directory and replace tokens in a card image input stream
 with member names.  Some knowledge of Job Control Language (JCL)
 is required as well as knowledge of how programs are executed.

 DIRSCNC and DIRSCNQ are mainframe freeware, available for any
 use you wish to make of them. They are intended for MVS
 compatible systems to provide the capability to generate a
 stream of card images for each member in a given PDS. Suggested
 uses are generating compile and link jobs, compare (ala SuperC
 or CompareX) steps, or list steps.

 The reason behind having both a COBOL and a PL/I version is
 partially to show it could be done and partly to eliminate
 complaints from users of one language who just can't do both :)

 Steli Inc. has made its best effort to provide working, tested
 code.  However, nothing is perfect - there may be flaws and
 there certainly could be improvements.  All questions, concerns,
 problems and suggestions are welcome.  Please e-mail them to
 C_Hafner@HotMail.Com.


:HEADER1   EXECUTION JCL

 The job control language (JCL) for DIRSCNC and DIRSCNQ is:

    //DIRSCNx    EXEC     PGM=DIRSCNx,REGION=4M

    //STEPLIB      DD       DISP=SHR,DSN=WHATEVER.LOADLIB

    //I            DD       DISP=SHR,DCB=(RECFM=F,LRECL=256,BLKSIZE=256),

    //             DSN=SOME.PDS

    //SYSIN        DD       DATA,DLM=XX

      ########   FIXED 8 BYTE MEMBER NAME

      ????????   VARIABLE MEMBER NAME

    XX

    //SELMEM       DD       *

    FIRST=000001, LAST=999999, FIRSTMEM='        ', LASTMEM='99999999';

    //O            DD         DISP=(,CATLG),

    //             DSN=USERID.OUTPUT.CARD.IMAGES,

    //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),

    //             DCB=(RECFM=FB,LRECL=80)

 The same JCL works for both DIRSCNC and DIRSCNQ.  The name of
 either program may be changed as desired providing that the
 actual program is linked with the appropriate name or alias.

 REGION is optional.  STEPLIB may be optional if the given load
 module is placed in the system's link list but otherwise simply
 points to where the module is stored.

 The input PDS is specified by the I DD card.  It may be a load
 library, a JCL library or any PDS. The DCB information is there
 because COBOL had a record size disagreement when processing a
 PDS with LRECL not equal to 0.

 The SYSIN file contains the images to be generated for each
 member. Any string of 8 question marks (????????) will be
 replaced by the member name, deleting blanks from the end of the
 name.  Any string of 8 pound sugns (########) will also be
 replaced by the member name but without removing blanks.  The
 samples below show SYSIN having a DLM option. This is only there
 to show JCL could easily be input.

 SELMEM allows ranges of members to be specified, either by
 number (e.g. the first 100) or by name (e.g. FRED through GROK).
 The last named options may both be specified as shown, but it
 would make sense to use 1 through 999999 and then a name range,
 or 1 through 100 with blank through 99999999 as the name range.

 The O DD is the file where the output will be sent. Since we're
 duplicating card images from SYSIN, this is an 80 byte file.


:HEADER1   SAMPLE JCL AND OUTPUT

 An example of JCL that may be used is:

    //***

    //***  CREATE BACKUP IEBCOPY SELECT STATEMENTS

    //***

    //DELETE     EXEC       PGM=IEFBR14

    //SCRATCH      DD         DISP=(MOD,DELETE,DELETE),

    //             DSN=USERID.$$$TEMP.DIRSCNC,

    //             UNIT=SYSDA,SPACE=(TRK,0)

    //***

    //DIRSCNC    EXEC     PGM=DIRSCNC,PARM=NR,REGION=4M

    //STEPLIB      DD       DISP=SHR,DSN=YOUR.LOADLIB

    //I            DD       DISP=SHR,DCB=(RECFM=F,LRECL=256,BLKSIZE=256),

    //             DSN=SOME.PDS.WHERE.YOU.WANT.BKUP.COPIES

    //SYSIN        DD       DATA,DLM=XX

      S  M=((????????,????????O,R))

    XX

    //SELMEM       DD       *

    FIRST=000001, LAST=999999, FIRSTMEM='        ', LASTMEM='99999999';

    //O            DD         DISP=(,CATLG),

    //             DSN=Your.$$$TEMP.DIRSCNC,

    //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),

    //             DCB=(RECFM=FB,LRECL=80)

    //***


 Given that SOME.PDS.WHERE.YOU.WANT.BKUP.COPIES contains members
 AAA, MODGEN2, AKA666 and X, the above step would generate:

      S  M=((AAA,AAAO,R))

      S  M=((MODGEN2,MODGEN2O,R))

      S  M=((AKA666,AKA666O,R))

      S  M=((X,XO,R))

 Given that none of the original PDS member names were over 7
 characters, these IEBCOPY statements could be used to make back
 up copies of each member.


:HEADER1   PACKAGE CONTENTS

 The files involved specifically with ABENDX are:

     - DIRSCNC    the COBOL compile and link JCL for DIRSCNC

     - DIRSCNC$   a JCL skeleton for executing DIRSCNC

     - DIRSCNQ    the PL/I compile and link JCL for DIRSCNQ

     - DIRSCNQ$   a JCL skeleton for executing DIRSCNQ

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  FOREVER
:DOCTITLE2 Generate Job Periodically To Update Last
:DOCTITLE3 Referenced Date for List of Data Sets
:TLRDATE   April 14, 2000
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for the
 utility to update the last referenced date for a list of data
 sets. It's a COBOL program (FOREVER).  Some knowledge of Job
 Control Language (JCL) is required as well as knowledge of how
 programs are executed.

 FOREVER is mainframe freeware. It's available for any use you
 wish to make of it. FOREVER is intended for MVS compatible
 systems to provide the capability to identify a file's name from
 within a COBOL program.

 Steli Inc. has made its best effort to provide working, tested
 code.  However, nothing is perfect - there may be flaws and
 there certainly could be improvements.  All questions, concerns,
 problems and suggestions are welcome.  Please e-mail them to
 C_Hafner@HotMail.Com.


:HEADER1   FOREVER STRATEGY

 Many sites have drop dead dates for files that have not been
 accessed in some time frame, say 3 months. Many organizations
 have data sets which are only accessed on a mid year or even
 yearly basis.

 FOREVER is intended to provide some protection by updating the
 last referenced date of a list of files on some periodic time
 frame, say weekly. The program is invoked via REXX code in a
 logon Exec executed daily. It checks for Friday (easily changed
 to any desired day of the week). It then checks to see if it has
 already been run on that day, and either submits the job with
 the executing user's information for job name and notify, or it
 quits. The FOREVER file's disposition is OLD to prevent multiple
 submissions. The job uses IDCAMS PRINT of one record to cause
 the read access. This works against sequential and pertitioned
 data sets as well as VSAM files. It does give an I/O error when
 doing the read against a PDS since it's reading the directory
 trying to use the LRECL of the data set. It makes no never mind
 since the data set is still accessed as desired.

 When the job runs, it updates the date in the FOREVER file to the
 current date. Obviously, you may or may not want this run weekly,
 semi-monthly or even monthly may be adequate. That would require
 a code change.


:HEADER1   EXECUTION REXX EXEC

 The following REXX Exec code should be placed in an Exec that
 runs every time concerned users logon. It will check for a
 Friday and then check to see if it has already run the job, only
 submitting the job once. Note it passes the executing user ID to
 the program. The actual FOREVER file name and the load module
 library for the program must be changed appropriately.

      /**  FOREVER FILE PROCESSING  **/

         ADDRESS TSO

         "FREE DD(I O SYSOUT)"

         "ALLOC DSN(*) DD(SYSOUT)"

         "ALLOC DSN('SomeHLQ.Forever.File') DD(I) OLD"

         "ALLOC DD(O) SYSOUT(A) WRITER(INTRDR)"

         "CALL 'SomeHLQ.Loadlib(FOREVER)' '"USERID()"'"

         "FREE DD(I O SYSOUT)"


:HEADER1   FOREVER FILE LAYOUT

 The format is straightforward, the first line has the last run
 date in column 1. Each subsequent card has a data set name in
 column 1. The latter do not have to be in any order.

      20000331 --  ENTER DATA SETS BELOW STARTING EACH IN COLUMN 1

      SYS4.BACKUP.SYSTEM.CLISTS

      SOMEUSER.REALLY.NEEDED.DATA

      ...


:HEADER1   PACKAGE CONTENTS

 The file involved specifically with FOREVER is:

     - FOREVER    the COBOL code in JCL to
                  assemble and link edit it

     - FOREVERX   the REXX Ecec code to be
                  executed as part of each
                  user's logon

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  GETDSN
:DOCTITLE2 Get Data Set Name from within COBOL
:TLRDATE   March 23, 2000
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for the
 utility to retrieve the data set name for a given file from
 within a COBOL program (GETDSN).  Some knowledge of Job Control
 Language (JCL) is required as well as knowledge of how programs
 are executed.

 GETDSN is mainframe freeware. It's available for any use you
 wish to make of it. GETDSN is intended for MVS compatible
 systems to provide the capability to identify a file's name from
 within a COBOL program.

 Steli Inc. has made its best effort to provide working, tested
 code.  However, nothing is perfect - there may be flaws and
 there certainly could be improvements.  All questions, concerns,
 problems and suggestions are welcome.  Please e-mail them to
 C_Hafner@HotMail.Com.


:HEADER1   SAMPLE PROGRAM CALLING GETDSN

       IDENTIFICATION DIVISION.
       PROGRAM-ID.  TRYGET.
      *COBOL SAMPLE CODE INVOKING GETDSN
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT I ASSIGN TO I.
           SELECT J ASSIGN TO J.
       DATA DIVISION.
       FILE SECTION.
       FD  I
           RECORDING MODE IS F
           BLOCK CONTAINS 0 RECORDS.
       01  INPUT-REC    PIC X(00080).
       FD  J
           RECORDING MODE IS F
           BLOCK CONTAINS 0 RECORDS.
       01  INPUT-REC2   PIC X(00080).
       WORKING-STORAGE SECTION.
       01  WS-DSNS.
           05  I-NAME          PIC X(44).
           05  I-MEMBER        PIC X(08).
           05  J-NAME          PIC X(44).
           05  J-MEMBER        PIC X(08).
       PROCEDURE DIVISION.
       0000-MAIN.
              DISPLAY '***  TOP OF PROGRAM  ***'

              OPEN INPUT I, J

              CALL 'GETDSN' USING I, I-NAME, I-MEMBER
              DISPLAY 'THE DATA SET ASSOCIATED WITH FILE I IS ' I-NAME
              DISPLAY 'THE MEMBER ASSOCIATED WITH FILE I IS   ' I-MEMBER

              CALL 'GETDSN' USING J, J-NAME, J-MEMBER
              DISPLAY 'THE DATA SET ASSOCIATED WITH FILE J IS ' J-NAME
              DISPLAY 'THE MEMBER ASSOCIATED WITH FILE J IS   ' J-MEMBER

              CLOSE I, J

              DISPLAY '***  END OF PROGRAM  ***'
              GOBACK
              .


:HEADER1   PACKAGE CONTENTS

 The file involved specifically with GETDSN is:

     - GETDSN     the assembler code in JCL to
                  assemble and link edit it

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  PAGES
:DOCTITLE2 Pull Selected Pages
:TLRDATE   March 17, 2000
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for
 retrieving logical pages from a carriage controlled sequential
 file (PAGES).  Given a sequential file containing 5,000 pages,
 that has ASCII carriage controlled lines, PAGES will allow you
 to pull specific pages from the front, middle, end or a specific
 range.  PAGES will do this easily in one run saving paper and/or
 having to customize code.  Some understanding of Job Control
 Language (JCL) is required as well as knowledge of how programs
 are executed.

 PAGES is mainframe freeware.  You may use, change or ignore
 it, as you want.

 Steli Inc. has made its best effort to provide working,
 tested code.  However, nothing is perfect - there may be
 flaws and there certainly could be improvements.  All
 questions, concerns, problems and suggestions are welcome
 and may be sent to C_Hafner@HotMail.Com.


:HEADER1   EXECUTION JCL

 The job control language (JCL) for PAGES is:

      //SELPAGES   EXEC     PGM=PAGES   ( ,REGION=4M )

      //INFILE       DD       DISP=SHR, ( DCB=BUFNO=32, )

      //             DSN=...

        FIRST=50,     LAST=50,      MIDDLE=-1,     FROM=-1,      TO=-1;

      //SYSPRINT     DD       SYSOUT=*

      //OUTFILE      DD       DSN=...,

      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),

      //             DCB=(RECFM=FBA,LRECL=...,BLKSIZE=0,BUFNO=32)

      //STEPLIB      DD       DISP=SHR,DSN=...

 Optional control language elements are shown in parentheses.
 The name of the program  may be changed as desired providing
 that the actual program is linked with the appropriate name or
 alias.  REGION is optional - the default region size may be more
 then adequate depending on your local standards.

 INFILE contains the original ASCII carriage controlled data.
 That is, there's a '1' in column one to indicate the start of a
 new page. The very first line in the file will be recognized as
 the starting page, page 1, whether there is a '1' there or not.
 The BUFNO parameter is useful to speed processing but not
 necessary.

 The SYSIN file contains the specification of the page numbers to
 be selected from INFILE. The "null" indicator, -1, is only shown
 to provide a place holder for subsequent runs - leaving those
 parameters off will not hurt. They are free form but do need to
 be terminated with a semicolon (;).

 FIRST indicates the number of pages to be selected from the
 front of INFILE, MIDDLE from the center section, and LAST from
 the end. FROM and TO determine specific pages to be pulled.  All
 may be specified at one time as shown in the example below.

 SYSPRINT will contain a display of the total number of pages in
 INFILE, the total number of lines and which and how many pages
 were selected.

 OUTFILE receives the selected pages. DCB information may be hard
 coded as shown or may refer back to the cataloged input file.
 Again, BUFNO may help performance if the output is still rather
 large.

 STEPLIB may be optional if PAGES is placed in the system's link
 list but otherwise simply points to where PAGES is stored.


:HEADER1   SAMPLE JCL AND OUTPUT

 A sample of what might be submitted is:

      //CULL       EXEC     PGM=PAGES,REGION=4M

      //INFILE       DD       DISP=SHR,DCB=BUFNO=32,

      //             DSN=USERID.SOME.LARGE.PRINT.FILE

        FIRST=11,     LAST=04,      MIDDLE=20,     FROM=42,      TO=43;

      //SYSPRINT     DD       SYSOUT=*

      //OUTFILE      DD       DSN=USERID.THE.CULLED.FILE,

      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),

      //             DCB=(USERID.SOME.LARGE.PRINT.FILE,BUFNO=32)

      //STEPLIB      DD       DISP=SHR,DSN=SYS4.USERLIB

 Assuming there were 500 6 line pages on the input file, the
 SYSPRINT would look like:

      **************************************
      ***  YYMMDD STATISTICS HHMMSSTTT  ****
      **************************************

      ** TOTAL PAGES ON FILE:            500

      ** TOTAL RECORDS ON FILE:        3,000

      ** FIRST PAGES SELECTED:            11

      ** MIDDLE PAGES SELECTED:           20

      ** LAST PAGES SELECTED:              4

      ** PAGE RANGE SELECTED FROM:        42

      **                      TO:         43

      ** TOTAL PAGES SELECTED:            37

      ** TOTAL LINES SELECTED:           222

 where YYMMDD would contain the run date and HHMMSSTTT the run
 time. Note the DCB information for the output file was acquired
 from the input file and BUFNO was also specified.


:HEADER1   PACKAGE CONTENTS

 The files involved specifically with PAGES are:

     - PAGES      the PL/I code wrapped in JCL to compile
                  and link edit it

     - PAGES$     a JCL skeleton for its execution

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  PDSLIST
:DOCTITLE2 Partitioned Data Set
:DOCTITLE3 List Utility
:TLRDATE   September 14, 2000
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for
 the Partitioned Data Set List utility (PDSLIST). Some
 understanding of Job Control Language (JCL) is required as
 well as knowledge of how programs are executed.

 PDSLIST is mainframe freeware.  You may do anything you want
 with it.

 PDSLIST is intended for MVS compatible systems to print the
 members of one or more partitioned data sets (PDS's) in
 alphabetical order.  It will process concatenated PDS's up
 to the number currently allowed by the operating system and
 data of any size or type, fixed, variable or unformatted.
 Options may be specified through free form control cards.

 The member data is displayed in the middle 100 characters of
 a 120 byte print line and lengths are printed in the first 5
 bytes of the starting  line for fixed data over 100 bytes
 long and for all variable or unformatted data.  An ASCII
 control character prefixes the 120 characters to minimize
 output.

 PDSLIST through its options will also:

    - Provide an index indicating where each member resides
      and the page number on which the member begins printing
      (INDEX)

    - Provide only the index, not printing any member data
      (INDEX(ONLY))

    - Show only a portion of each member (FIRST(.))

    - Display duplicate members, i.e. show members with the
      same name that are in one or more PDS's in the concatenation
      (DUPS)

    - Show only members that have duplicates within the
      concatenation (DUPS(ONLY)

    - Allow a range of members to be selected  (>MEMBER(.)
      and <MEMBER(.))

    - Display member data as both characters and their hex
      equivalent (HEX)

    - Display a footing on each page (FOOTING(.))

    - Print each member on a new page or separated by a few
      blank lines (EJECT)

    - Indicate whether a member is an alias of another member
      (ALIAS)

    - List the options specified as well as the defaulted
      ones (OPTIONS)

    - Change the block size of the printed file (BLKSIZE(.))

    - Cause characters sent to the print file to be only
      printable ones (TRANSLATE)


:HEADER1   VERSION UPDATE

 PDSLIST Version 2 contains a number of changes, mostly internal.
 It is backward compatible with minor output differences.  The
 updates are:

    - The program is now reentrant and will run above the 16
      meg line (AMODE 31 and RMODE ANY)

    - The code and the documentation have been heavily
      revised for clarity and maintainability.  The ability to
      change option defaults and DD names has been enhanced by
      placing them all in one area and automating their
      implementation throughout the code (via SETC and SETA
      statements)

    - Display the options used

    - Show whether a member is an alias

    - Allow SYSIN DD card to be omitted

    - Make HEX and TRANSLATE compatible in same run

    - Display footing on every page

    - Use specified page size for all printed output

    - Show only duplicate members in index for DUPS(ONLY)

 These changes reflect all the comments made so far to Steli Inc.
 for PDSLIST.  Thanks go to several people who actually read the
 documentation and suggested clarifications as well as to the
 folks who suggested the changes and to those who pointed out the
 problems.  There's a fix to the reentrant code, thanks to Tom
 Esela, that corectly initilaized the dynamic work area
 preventing problems when running from an APF (linklist) library.

 Steli Inc. has made its best effort to provide working, tested
 code.  However, nothing is perfect - there may be flaws and
 there certainly could be improvements.  All questions, concerns,
 problems and suggestions are welcome and may be sent to
 C_Hafner@HotMail.Com.


:HEADER1   EXECUTION JCL

 The job control language (JCL) for PDSLIST is:

           //   EXEC   PGM=PDSLIST ( ,REGION=4M )

           //STEPLIB     DD   DISP=SHR,DSN=...

           //SYSPRINT    DD   SYSOUT=*

           //SYSUT1      DD   DISP=SHR,DSN=PDS1

         ( //            DD   DISP=SHR,DSN=PDS2 )

         (    ...   optionally, as many         )

         (    ...      concatenated PDS's       )

         (    ...         as allowed in MVS/ESA )

         ( //SYSIN       DD   *                 )

         (        control cards . . .           )

 Optional control language elements are shown in parentheses.
 The name of the program  may be changed as desired providing
 that the actual program is linked with the appropriate name or
 alias.

 REGION is optional but PDSLIST requires approximately 192,000
 bytes as well as 20 bytes for each member (system required
 resources may increase this amount).  In most cases the default
 region size is adequate to meet these requirements.  STEPLIB may
 be optional if PDSLIST is placed in the system's link list but
 otherwise simply points to where PDSLIST is stored.

 The SYSPRINT file may be directed to any output class or may be
 sent to a new or existing file.  The DCB attributes of SYSPRINT
 will be record format FBA and LRECL 121.  The BLKSIZE may be set
 through the BLKSIZE control card option within PDSLIST but will
 default to 121.

 SYSUT1 points to the one or more PDS's to be processed.  SYSIN
 contains control information and may be omitted, set to //SYSIN
 DD DUMMY or simply be empty.  Full control card descriptions are
 shown below.

 The DD names and SYSPRINT block size may be changed as desired
 in the defaults section of the source code.  If an incorrect
 name is specified, the program will terminate returning the code
 received from opening the data set (the system will generally
 indicate the missing DD name).


:HEADER1   CONTROL CARDS

 The control card values may be specified free form in the first
 72 columns of the records in the SYSIN file in any order and may
 be separated by commas, blanks or simply concatenated together.
 Each option must be contained on one input line, however, as
 continuation is not supported. Blank lines may be interspersed
 as desired for readability.

 The specific keywords are sought and anything else is ignored.
 Keywords must be in upper case but any FOOTING data may be any
 case.  Also, options which require parentheses but where no
 closing parenthesis is supplied will be ignored, as will values
 which require numeric values but are not supplied as such.  The
 last specified value is the one used if the same option is
 repeated.  To change the defaults, please see the section below
 called CHANGING DEFAULTS.

 Control card parameters are:

      ALIAS     Show whether the member is an alias in the
                header line and in the index entry.  The
                default is NOALIAS

      BLKSIZE(#)  Specify the block size to be used for
                the SYSPRINT file output.  It must be a
                multiple of 121.  The default is
                BLKSIZE(121).

      DUPS      Indicate that members with duplicate
                names in concatenated PDS's are to be printed
                and shown in the index.  The alternative,
                NODUPS, is the default.  DUPS(ONLY) may be
                specified to have only the members that exist
                as duplicates within the concatenation listed
                and/or shown in the index.

      EJECT     Causes the printing of each member to
                start at the top of a new page. NOEJECT will
                cause two lines to be skipped before printing
                the next member and is the default.

      FIRST(#)  Only the first # of lines of each member
                will be printed.  The default is to print
                every line of a member.  Note this is NOT
                record count, but literally prints the
                indicated number of lines.

      FOOTING(x)  Indicates that the string x should be
                placed two lines from the end of each page.
                The open parenthesis starts the string and
                the close parenthesis terminates the string.
                The default is no footing.

      HEX       Causes the member data to be printed as usual
                and then followed by 2 additional lines, the
                first showing the first character of the hex
                representation of the character above and the
                second line showing the next hex character.
                NOHEX is the default.

      INDEX     Specifies an index of member names is to
                be printed at the end of the listing.  This
                list will show all members in the selected
                range including those not printed (e.g. if
                NODUPS is chosen).  NOINDEX is the default.
                INDEX(ONLY) indicates that only the index is
                to be printed and the actual member data is
                not to be.

      LINECNT(#)  Indicates the SYSPRINT page size.
                LINECNT(58) is the default.  This value must
                be numeric and greater then 4.

      OPTIONS   Causes the specified and default options to
                be displayed.  NOOPTIONS is the default.

      TRANSLATE Causes all printed lines to be converted on
                a character by character basis to printable
                characters or blanks.   The default is to
                send the characters as they are to the
                printer, namely NOTRANSLATE.  Please see the
                section below titled PRINTABLE CHARACTER
                TRANSLATION to see the default translation.

      VARSEQ    Specifies that the first 8 characters of
                variable data, if numeric, are to be treated
                as sequence numbers and  printed in columns
                113 through 120 of the print line.  Only the
                data following the eight bytes is then
                printed. The default is VARSEQ.  NOVARSEQ
                would cause all of the record to be printed
                as data.

      >MEMBER(member) Indicates the 1 to 8 byte member name,
                to be used as an lower bound - no member
                alphabetically lower then this member will be
                printed.  The default is to print the first
                member and all following members.

      <MEMBER(member) Indicates the 1 to 8 byte member name,
                to be used as an upper bound - no member
                alphabetically higher then this member will
                be printed.  The default is to print all
                members from the starting member onward.


:HEADER1   CHANGING DEFAULTS

 To change the default behavior of PDSLIST, simple changes may be
 made to the assembler source code and the program will need to
 be re-assembled and re-linked.

 To change the default, simply find the variable in the PDSLIST
 source as shown below and change it from `N' to `Y' or vice
 versa.  BLKSIZE, FIRST and LINECNT require a numeric value.  The
 same concept applies to the DD names shown.

 ************************************************************
 *    DEFAULT OPTION VALUES                                 *
 ************************************************************

 &DDOPTS       SETC  'SYSIN'      DDNAME FOR OPTIONS FILE
 &DDPDS        SETC  'SYSUT1'     DDNAME FOR PARTITIONED d/s
 &DDPRINT      SETC  'SYSPRINT'   DDNAME FOR LISTING FILE

 &DEFPGSZ      SETA  58           DATA PAGE SIZE DEFAULT
 &DEF1ST       SETA  999999999    FIRST OPTION CHOSEN DEFAULT

 &DEFALIAS     SETC  'N'          ALIAS DEFAULT
 &DEFBLKSI     SETA  121          SYSPRINT BLOCK SIZE DEFAULT
 &DEFDUPS      SETC  'N'          DUPS DEFAULT
 &DEFDUPSO     SETC  'N'          DUPS ONLY DEFAULT
 &DEFEJECT     SETC  'N'          EJECT DEFAULT
 &DEFFOOT      SETC  'N'          FOOTER USED
 &DEFHEX       SETC  'N'          HEX DEFAULT
 &DEFINDX      SETC  'N'          INDEX DEFAULT
 &DEFINDXO     SETC  'N'          INDEX ONLY DEFAULT
 &DEFOPTNS     SETC  'N'          LIST OPTIONS DEFAULT
 &DEFTRANS     SETC  'N'          TRANSLATE DEFAULT
 &DEFVAR       SETC  'Y'          VARIABLE SEQUENCE DEFAULT
                       00000000
 &DEFMEMGT     SETC   '00000000'  FIRST MEMBER SELECTED (HEX 0'S)
                       FFFFFFFF
 &DEFMEMLT     SETC   'FFFFFFFF'  LAST MEMBER SELECTED (HEX F'S)


:HEADER1   PRINTABLE CHARACTER TRANSLATION

 The table below is used to translate member data sent to
 SYSPRINT when the TRANSLATE option is selected.  Numbers,
 upper and lower case characters and the primary punctuation
 characters print as expected.  Other characters are changed
 to blanks.

 PRTABLE   DC    XL16'40404040404040404040404040404040' 00 - 0F

           DC    XL16'40404040404040404040404040404040' 10 - 1F

           DC    XL16'40404040404040404040404040404040' 20 - 2F

           DC    XL16'40404040404040404040404040404040' 30 - 3F

           DC    XL16'40404040404040404040404B4C4D4E4F' 40 - 4F

           DC    XL16'504040404040404040405A5B5C5D5E5F' 50 - 5F

           DC    XL16'606140404040404040406A6B6C6D6E6F' 60 - 6F

           DC    XL16'404040404040404040407A7B7C7D7E7F' 70 - 7F

           DC    XL16'40818283848586878889404040404040' 80 - 8F

           DC    XL16'40919293949596979899404040404040' 90 - 9F

           DC    XL16'4040A2A3A4A5A6A7A8A9404040404040' A0 - AF

           DC    XL16'B0404040404040404040BABB40404040' B0 - BF

           DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040' C0 - CF

           DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040' D0 - DF

           DC    XL16'E040E2E3E4E5E6E7E8E9404040404040' E0 - EF

           DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040' F0 - FF

 The table above may  be changed by finding the relative position
 of the character and replacing it with whatever character is
 desired or a blank.


:HEADER1   SAMPLE JCL

 An example of JCL that may be used is:

      //LISTPRCS  EXEC  PGM=PDSLIST,REGION=4M

      //SYSIN       DD    *

            DUPS          EJECT          INDEX

            FOOTING(- Top Secret & Confidential & Highly Unlikely -)

      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB

      //SYSPRINT     DD        SYSOUT=C

      //SYSUT1       DD        DISP=SHR,DSN=SYS1.PROCLIB

      //             DD        DISP=SHR,DSN=PLI.V2R3M0.PROCLIB

      //             DD        DISP=SHR,DSN=SYS4.USER.PROCLIB

 The above step will print all the members of the 3 PROCLIB's
 including duplicates, a data set list, and an index of all the
 members with the footing shown.  Note the control card data is
 free form and does not need to be aligned in any way.

 Another example is:

      //LISTPDSS  EXEC  PGM=PDSLIST

           INDEX(ONLY)    DUPS

      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB

      //SYSPRINT     DD        SYSOUT=*

      //SYSUT1       DD        DISP=SHR,DSN=APPLIC.LOADLIB1

      //             DD        DISP=SHR,DSN=APPLIC.LOADLIB2

      //             DD        DISP=SHR,DSN=APPLIC.LOADLIB3

      //             DD        DISP=SHR,DSN=APPLIC.LOADLIB4

 This step will provide an index of the members of the four load
 module libraries input.  In this case it is supposed that the
 data itself is not of interest (load modules don't normally list
 nicely).


:HEADER1   SAMPLE OUTPUT

 Given the following 2 partitioned data sets, PDS.A and PDS.B,
 which contain:

      PDS.A
           Member A -- 10 lines of 10 A's
           Member B -- 10 lines of 10 B's
           Member C -- 10 lines of 10 C's
      PDS.B
           Member B --10 lines 0f 10 2's
           Member D --10 lines of 10 D's

 The JCL immediately following will produce the results below:

      //PDSLIST    EXEC     PGM=PDSLIST,REGION=4M

      //SYSIN        DD       *

           DUPS           EJECT               INDEX

           FIRST(03)

           FOOTING( - - -  Sample output from PDSLIST  - - - )

      /STEPLIB       DD       DISP=SHR,DSN=USER.LOADLIB

      //SYSPRINT     DD       SYSOUT=*

      //SYSUT1       DD       DISP=SHR,DSN=PDS.A

      //             DD       DISP=SHR,DSN=PDS.B

 The header lines on each page are underlined - we left NOEJECT
 on to minimize paper usage and the output shown reflects the
 request to only print the first 3 lines of each member.

      DATE=98/318   VOL=TEST27   DSN=PDS.A   MEMBER=A   PAGE 1
      --------------------------------------------------------
      AAAAAAAAAA
      AAAAAAAAAA
      AAAAAAAAAA
                     - - -  Sample output from PDSLIST  - - -

      DATE=98/318   VOL=TEST27   DSN=PDS.A   MEMBER=B   PAGE 2
      --------------------------------------------------------
      BBBBBBBBBB
      BBBBBBBBBB
      BBBBBBBBBB
                     - - -  Sample output from PDSLIST  - - -

      DATE=98/318   VOL=TEST29   DSN=PDS.B   MEMBER=B   PAGE 3
      --------------------------------------------------------
      2222222222
      2222222222
      2222222222

                     - - -  Sample output from PDSLIST  - - -

      DATE=98/318   VOL=TEST27   DSN=PDS.A   MEMBER=C   PAGE 4
      --------------------------------------------------------
      CCCCCCCCCC
      CCCCCCCCCC
      CCCCCCCCCC

                     - - -  Sample output from PDSLIST  - - -

      DATE=98/318   VOL=TEST29   DSN=PDS.B   MEMBER=D   PAGE 5
      --------------------------------------------------------
      DDDDDDDDDD
      DDDDDDDDDD
      DDDDDDDDDD

                     - - -  Sample output from PDSLIST  - - -



      PDS#      DATA SET NAME                 VOLUME
      -----------------------------------------------------
      1              PDS.A                           TEST27
      2              PDS.B                           TEST29

                     - - -  Sample output from PDSLIST  - - -


      MEMBER   PAGE#   PDS     MEMBER   PAGE#   PDS . . .
      -----------------------------------------------------
      A          1      1
      B          2      1
      B          3      2
      C          4      1
      D          5      2

                     - - -  Sample output from PDSLIST  - - -


:HEADER1   PACKAGE CONTENTS

 The PDSLIST package consists of:

     - PDSLIST    the assembler source code wrapped in JCL
                  to assemble and link it

     - PDSLIST$   sample execution JCL

 PDSLIST was assembled using IBM's High Level Assembler.
 Assembler H may be used although any blank lines in the source
 will have to be removed.  The JCL supplied in PDSLIST does not
 use procedures since many have local changes precluding use of
 specific step names for DD name over-rides.  To change from High
 Level Assembler to Assembler H, simply change the program name
 from ASMA90 to IEV90.  The JCL will accommodate either.

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  PDSMATCH
:DOCTITLE2 Partitioned Data Set
:DOCTITLE3 Match Utility
:TLRDATE   November 04, 1999
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for the
 Partitioned Data Set Match utility (PDSMATCH).  Some
 understanding of Job Control Language (JCL) is required as well
 as knowledge of how programs are executed.

 PDSMATCH is mainframe software obtained from the CBTTAPE online
 internet site.  This version of PDSMATCH has been modified from
 the CBTTAPE version to compare member data in addition to
 directory statistics and member names.  This version has been
 sent to the original provider.

 This program compares the directories of two partitioned data
 sets and prints a report showing which members match and which
 members do not match or are not present in both directories.
 Members are said to match if their names are the same.  If
 PARM=USER, members match if they have the same name and all the
 statistics in their directory entries are equal (except fields
 containing TTR track addresses). If PARM=DATA, they must have
 the same name and their data must be the same.

 PDSMATCH through its PARM specified option specifies which
 compare option will be used.  If PARM=EQO, only members that
 match will be listed.  If PARM=NEO, only members that dont match
 will be listed.  If the default is taken, all members will be
 listed for both libraries.

 If PARM=USER, members that are present in both libraries will be
 compared for matching statistics.  Statistics of up to 62 bytes
 of data in the directory entry which is put there by the linkage
 editor, SPF edit, and others.  Note, with PARM=USER, if two
 members have the same name and neither has any userdata, they
 are treated as unequal, with a unique message for this case.

 If PARM=DATA members that are present in both libraries will be
 compared for matching data.  if two members have the same name
 and both are empty, they are treated as unequal, with a unique
 message for this case.

 Steli Inc. has made its best effort to provide working, tested
 code.  However, nothing is perfect - there may be flaws and
 there certainly could be improvements.  All questions, concerns,
 problems and suggestions are welcome and may be sent to
 C_Hafner@HotMail.Com.


:HEADER1   EXECUTION JCL

The job control language (JCL) for PDSMATCH is:

           //   EXEC   PGM=PDSMATCH ( ,REGION=4M )

           //*                PARM=EQO  TO SHOW EQUALS ONLY

           //*                PARM=NEO  TO SHOW UNMATCHED ONLY

           //*                PARM=USER TO SHOW STAT DIFFERENCES

           //*                PARM=DATA TO SHOW DATA DIFFERENCES

           //STEPLIB     DD   DISP=SHR,DSN=...

           //SYSPRINT    DD   SYSOUT=*

           //SYSLIB1     DD   DISP=SHR,DSN=PDS1

           //SYSLIB2     DD   DISP=SHR,DSN=PDS2

 Optional control language elements are shown in parentheses.
 The name of the program  may be changed as desired providing
 that the actual program is linked with the appropriate name or
 alias.

 REGION is optional but PDSMATCH requires approximately 280,000
 bytes.  In most cases the default region size is adequate to
 meet these requirements.  STEPLIB may be optional if PDSMATCH is
 placed in the system's link list but otherwise simply points to
 where PDSMATCH is stored.

 The SYSPRINT file may be directed to any output class or may be
 sent to a new or existing file.  The DCB attributes of SYSPRINT
 will be record format FBA and LRECL 121.  SYSLIB points to the
 PDS to be processed.

:HEADER1   SAMPLE JCL

 An example of JCL that may be used is:

      //COMPARE   EXEC  PGM=PDSMATCH,REGION=4M,PARM=DATA

      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB

      //SYSPRINT     DD        SYSOUT=C

      //SYSLIB1      DD        DISP=SHR,DSN=A.PROCLIB

      //SYSLIB2      DD        DISP=SHR,DSN=A.PROCLIB.BACKUP

 The above step will compare the members and the data of members
 with the same name.

 Another example is:

      //COMPARE   EXEC  PGM=PDSMATCH,REGION=4M,PARM=NEO

      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB

      //SYSPRINT     DD        SYSOUT=C

      //SYSLIB1      DD        DISP=SHR,DSN=A.PROCLIB

      //SYSLIB2      DD        DISP=SHR,DSN=A.PROCLIB.BACKUP

 This step will provide a list of the members not in both
 libraries.


:HEADER1   SAMPLE OUTPUT

 The following shows the results of a PDSMATCH run against a REXX
 CLIST library and its backup library with option DATA.

    --- PDSMATCH --- PDS DIRECTORY COMPARE UTILITY ---

    CRITERIA FOR MATCHING IS MEMBER NAME AND THE ACTUAL MEMBER DATA
    (SPF STATISTICS ARE NOT COMPARED).

    LIBRARY1 - SUCAHAF.CURR.CLIST ON KLPSF8
    LIBRARY2 - SUCAHAF.CURR.CBKUP ON KK2SF9

                         @@BOFA01  MEMBER IN LIBRARY2 ONLY

                         @TIME     MEMBER IN LIBRARY2 ONLY

                         @TODO     MEMBER IN LIBRARY2 ONLYONLY

    ADDDOTSL             ADDDOTSL

    ADDFLAGS             ADDFLAGS

                         ADD0D0A   MEMBER IN LIBRARY2 ONLY

                         ADP2CLT   MEMBER IN LIBRARY2 ONLY

    ALLMEM               ALLMEM

    ALLMEMC              ALLMEMC

    ALLMEMF              ALLMEMF

                         ALLOC     MEMBER IN LIBRARY2 ONLY

                     . . . . .


:HEADER1   PACKAGE CONTENTS

 PDSMATCH files in this library are:

     - PDSMATCH   the assembler source code wrapped in JCL
                  to assemble and link it and the PDSCOMP
                  program

     - PDSMATC$   sample execution JCL

 PDSMATCH was assembled using IBM's High Level Assembler.
 Assembler H may be used although any blank lines in the source
 will have to be removed.  The JCL supplied in LISTASM does not
 use procedures since many have local changes precluding use of
 specific step names for DD name over-rides.  To change from High
 Level Assembler to Assembler H, simply change the program name
 from ASMA90 to IEV90.  The JCL will accommodate either.

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  PDSPUNCH
:DOCTITLE2 Partitioned Data Set
:DOCTITLE3 Punch Utility
:TLRDATE   March 20, 2000
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for
 the Partitioned Data Set Punch utility (PDSPUNCH). Some
 understanding of Job Control Language (JCL) is required as
 well as knowledge of how programs are executed.

 PDSPUNCH is mainframe freeware. You do not need to register
 to use PDSPUNCH. It may be placed on any archive, web site
 or bulletin board without restraint.  It may be distributed
 by any means, provided that no charge is made other than for
 reasonable distribution costs.

 PDSPUNCH is intended for MVS compatible systems to turn the
 members of one or more partitioned data sets (PDS's) into a
 sequential stream of 80 byte records with IEBUPDTE ./ ADD cards
 preceding each member in alphabetical order.  It will process
 concatenated PDS's up to the number currently allowed by the
 operating system and data of any size or type, fixed, variable
 or unformatted.  Options may be specified through free form
 control cards.

 PDSPUNCH through its options will also:

    - Punch duplicate members, i.e. process members with the
      same name that are in one or more PDS's in the concatenation
      (DUPS)

    - Punch only members that have duplicates within the
      concatenation (DUPS(ONLY))

    - Punch only a portion of each member (FIRST(.))

    - Allow a range of members to be selected  (>MEMBER(.)
      and <MEMBER(.))

    - Specify whether to use ./ ADD or ./ REPL header cards

 Steli Inc. has made its best effort to provide working,
 tested code.  However, nothing is perfect - there may be
 flaws and there certainly could be improvements.  All
 questions, concerns, problems and suggestions are welcome
 and may be sent to C_Hafner@HotMail.Com.


:HEADER1   EXECUTION JCL

The job control language (JCL) for PDSPUNCH is:

           //   EXEC   PGM=PDSPUNCH ( ,REGION=4M )

           //STEPLIB     DD   DISP=SHR,DSN=...

           //SYSPUNCH    DD   ...

           //SYSUT1      DD   DISP=SHR,DSN=PDS1

         ( //            DD   DISP=SHR,DSN=PDS2 )

         (    ...   optionally, as many         )

         (    ...      concatenated PDS's       )

         (    ...         as allowed in MVS/ESA )

         ( //SYSIN       DD   *                 )

         (        control cards . . .           )

 Optional control language elements are shown in parentheses.
 The name of the program  may be changed as desired providing
 that the actual program is linked with the appropriate name
 or alias.

 REGION is optional but PDSPUNCH requires approximately 216,000
 bytes (system required resources may increase this amount).  In
 most cases the default region size is adequate to meet these
 requirements.  STEPLIB may be optional if PDSPUNCH is placed in
 the system's link list but otherwise simply points to where
 PDSPUNCH is stored.

 The SYSPUNCH file may be directed to any output class or may
 be sent to a new or existing file.  The DCB attributes of
 SYSPUNCH will be record format FB and LRECL 80.  The BLKSIZE
 parameter may be specified on the JCL for it.

 SYSUT1 points to the one or more concatenated PDS's to be
 processed.  SYSIN contains control information and may be
 omitted, set to //SYSIN DD DUMMY or simply be empty.  Full
 control card descriptions are shown below.

 The DD names may be changed as desired in the defaults section
 of the source code.  If an incorrect name is specified, the
 program will terminate returning the code received from opening
 the data set (the system will generally indicate the missing DD
 name).


:HEADER1   CONTROL CARDS

 The control card values may be specified free form in the first
 72 columns of the records in the SYSIN file in any order and may
 be separated by commas, blanks or simply concatenated together.
 Each option must be contained on one input line, however, as
 continuation is not supported. Blank lines may be interspersed
 as desired for readability.

 The specific keywords are sought and anything else is ignored.
 Keywords must be in upper case but any FOOTING data may be any
 case.  Also, options which require parentheses but where no
 closing parenthesis is supplied will be ignored, as will values
 which require numeric values but are not supplied as such.  The
 last specified value is the one used if the same option is
 repeated.  To change the defaults, please see the section below
 called CHANGING DEFAULTS.

 Control card parameters are:

      ACTION(x) Indicate that the IEBUPDTE header card should
                specify REPL or ADD.  ACTION(ADD) is the
                default.

      DUPS      Indicate that members with duplicate
                names in concatenated PDS's are to be punched
                and shown in the index.  The alternative,
                NODUPS, is the default.  DUPS(ONLY) may be
                specified to have only the members that exist
                as duplicates within the concatenation.

      FIRST(#)  Only the first # of lines of each member
                will be punched.  The default is to punch
                every line of a member.  Note this is NOT
                record count, but literally punches the
                indicated number of lines.

      >MEMBER(member) Indicates the 1 to 8 byte member name,
                to be used as an lower bound - no member
                alphabetically lower then this member will be
                punched.  The default is to punch the first
                member and all following members.

      <MEMBER(member) Indicates the 1 to 8 byte member name,
                to be used as an upper bound - no member
                alphabetically higher then this member will
                be punched.  The default is to punch all
                members from the starting member onward.


:HEADER1   CHANGING DEFAULTS

 To change the default behavior of PDSPUNCH, simple changes
 may be made to the assembler source code and the program
 will need to be re-assembled and re-linked.

 To change the default, simply find the variable in the
 PDSPUNCH source as shown below and change it from `N' to `Y'
 or vice versa.  BLKSIZE, FIRST and LINECNT require a numeric
 value.  The same concept applies to the DD names shown.

 ************************************************************
 *    DEFAULT OPTION VALUES                                 *
 ************************************************************

 &DDOPTS       SETC  'SYSIN'      DDNAME FOR OPTIONS FILE
 &DDPDS        SETC  'SYSUT1'     DDNAME FOR PARTITIONED d/s
 &DDPUNCH      SETC  'SYSPUNCH'   DDNAME FOR PUNCHED FILE

 &DEF1ST       SETA  999999999    FIRST OPTION CHOSEN DEFAULT

 &DEFDUPS      SETC  'N'          DUPS DEFAULT
 &DEFDUPSO     SETC  'N'          DUPS ONLY DEFAULT
                       00000000
 &DEFMEMGT     SETC   '00000000'  FIRST MEMBER SELECTED (HEX 0'S)
                       FFFFFFFF
 &DEFMEMLT     SETC   'FFFFFFFF'  LAST MEMBER SELECTED (HEX F'S)

:HEADER1   SAMPLE JCL

 An example of JCL that may be used is:

      //PUNCHGAS  EXEC  PGM=PDSPUNCH,REGION=4M

      //SYSIN       DD    *

            >MEMBER($GAS0000)   <MEMBER($GAS9999)

      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB

      //SYSPUNCH     DD        DISP=(,CATLG),DSN=RECOVERED.MEMBERS,

      //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),

      //             DCB=(BLKSIZE=27920,BUFNO=24)

      //SYSUT1       DD        DISP=SHR,DSN=SYS4.USER.PROCLIB

 The above step will punch all the restored members (see PDSGAS)
 of the user PROCLIB.  This would allow removal of the "gas"
 members while still retaining them in a sequential file.  Note
 the control data is free form and does not need to be aligned in
 any way.

 Another example is:
      //PNCHPDSS  EXEC  PGM=PDSPUNCH
          DUPS(ONLY)
      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB
      //SYSPUNCH    DD         SYSOUT=*
      //SYSUT1       DD        DISP=SHR,DSN=APPLIC.COPYLIB1
      //             DD        DISP=SHR,DSN=APPLIC.COPYLIB2
      //             DD        DISP=SHR,DSN=APPLIC.COPYLIB3
      //             DD        DISP=SHR,DSN=APPLIC.COPYLIB4

 This step will provide a sequential file with all the duplicate
 members within the 4 COPYLIBs.

:HEADER1   SAMPLE OUTPUT

 Given the following 2 partitioned data sets, PDS.A and
 PDS.B, which contain:

      PDS.A
           Member A -- 10 lines of 10 A's
           Member B -- 10 lines of 10 B's
           Member C -- 10 lines of 10 C's
      PDS.B
           Member B --10 lines 0f 10 2's
           Member D --10 lines of 10 D's

 The JCL immediately following will produce the results
 below:
      //PDSPUNCH   EXEC     PGM=PDSPUNCH,REGION=4M
      //SYSIN   DD   *
           DUPS
           FIRST(03)
      /STEPLIB       DD       DISP=SHR,DSN=USER.LOADLIB
      //SYSPUNCH   DD       SYSOUT=*
      //SYSUT1            DD       DISP=SHR,DSN=PDS.A
      //                  DD       DISP=SHR,DSN=PDS.B

 ./  ADD  NAME=A
 AAAAAAAAAA
 AAAAAAAAAA
 AAAAAAAAAA
 ./  ADD  NAME=B
 BBBBBBBBBB
 BBBBBBBBBB
 BBBBBBBBBB
 ./  ADD  NAME=B
 2222222222
 2222222222
 2222222222
 ./  ADD  NAME=C
 CCCCCCCCCC
 CCCCCCCCCC
 CCCCCCCCCC
 ./  ADD  NAME=D
 DDDDDDDDDD
 DDDDDDDDDD
 DDDDDDDDDD


:HEADER1   PACKAGE CONTENTS

 PDSPUNCH is generally distributed as a ZIP file, but the
 files distributed easily fit on a 1.4 meg floppy.  The files
 are:

     - PDSPUNCH   the assembler source code wrapped in JCL
                  to assemble and link it

     - PDSPUNC$   sample execution JCL

 PDSPUNCH was assembled using IBM's High Level Assembler.
 Assembler H may be used although any blank lines in the
 source will have to be removed.  The JCL supplied in
 PUNCHASM does not use procedures since many have local
 changes precluding use of specific step names for DD name
 over-rides.  To change from High Level Assembler to
 Assembler H, simply change the program name from ASMA90 to
 IEV90.  The JCL will accommodate either.

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  PULL
:DOCTITLE2 Select Records from Sequential File
:TLRDATE   December 15, 1999
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for
 selecting one or more sets of records from a sequential file
 (PULL).   Given a large sequential file, PULL will allow
 retrieving groups of records in one run without customizing
 code.  Some understanding of Job Control Language (JCL) is
 required as well as knowledge of how programs are executed.

 PULL is mainframe freeware.  Feel free to use it as you will.

 Steli Inc. has made its best effort to provide working,
 tested code.  However, nothing is perfect - there may be
 flaws and there certainly could be improvements.  All
 questions, concerns, problems and suggestions are welcome
 and may be sent to C_Hafner@HotMail.Com.


:HEADER1   EXECUTION JCL

 The job control language (JCL) for PULL is:

      //SELRECS    EXEC     PGM=PULL,  ( REGION=4M )

      //SYSIN        DD       *

      00000001  00000030  STARTING RECORD NUMBER IN 1 - 8

      00000444  00000050  & NUMBER OF RECORDS IN 11 - 18

      //I            DD       DISP=SHR,DCB=BUFNO=32,

      //             DSN=...

      //O            DD       DSN=...,

      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE

      //             DCB=(...,BUFNO=32)

      //STEPLIB      DD       DISP=SHR,DSN=...

 Optional control language elements are shown in parentheses.
 The name of the program  may be changed as desired providing
 that the actual program is linked with the appropriate name or
 alias.  REGION is optional - the default region size may be more
 then adequate depending on your local standards.

 File I contains the original data.  File O will contain the
 selected output; the DCB information may be hard coded or
 patterned (specify the old data set name) and the BUFNO
 parameter is useful to speed processing but not necessary.

 The SYSIN file contains the specification of the records to be
 selected from INFILE. The first 8 columns specify the offset,
 that is, the starting record number of each group.  The second
 parameter specifies the number of records. These MUST be in
 order by starting record number.

 STEPLIB may be optional if PULL is placed in the system's link
 list but otherwise simply points to where PULL is stored.


:HEADER1   SAMPLE JCL AND OUTPUT

 A sample of what might be submitted is:

      //GRABRECS   EXEC     PGM=PULL,REGION=4M

      00000001  00000100

      00004001  00000100

      00160001  00000100

      02000001  00000100

      //I            DD       DISP=SHR,DCB=BUFNO=32,

      //             DSN=USERID.USER.DATA01

      //O            DD       DSN=USERID.SELECTED.DATA01,

      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE

      //             DCB=(USERID.USER.DATA01,BUFNO=32)

      //STEPLIB      DD       DISP=SHR,DSN=SYS4.USER.LINKLIB

 Assuming there were 5,000,000 records in the input file I, the
 above step would create a subset file of 400 records.


:HEADER1   PACKAGE CONTENTS

 The files involved specifically with PULL are:

     - PULL       the PL/I code wrapped in JCL to compile
                  and link edit it

     - PULL$      a JCL skeleton for its execution

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  SETRC
:DOCTITLE2 Set MVS Return Code
:TLRDATE   September 14, 1999
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for the
 utility to set MVS return codes (SETRC).  Some understanding of
 Job Control Language (JCL) is required as well as knowledge of
 how programs are executed.

 SETRC is mainframe freeware.  It's available for any use you
 wish to make of it.

 SETRC is intended for MVS compatible systems to set a step
 return code.  It allows testing of JCL and restart conditions
 without having to do program changes.  Other then setting the
 return code, it does no processing.

 SETRC is an Assembler program that accepts a PARM parameter of a
 number between 0 and 4095, the legitimate condition codes
 acceptable to MVS. IF no value or a bad value is passed, the
 return code is set to 0.

 Steli Inc. has made its best effort to provide working,
 tested code.  However, nothing is perfect - there may be
 flaws and there certainly could be improvements.  All
 questions, concerns, problems and suggestions are welcome
 and may be sent to C_Hafner@HotMail.Com.


:HEADER1   EXECUTION JCL

 The job control language (JCL) for SETRC is:

           //SETCOND    EXEC     PGM=SETRC,PARM=#

           //STEPLIB      DD       DISP=SHR,DSN=...

 The name of the program may be changed as desired providing
 that the actual program is linked with the appropriate name
 or alias.

 REGION is optional.  STEPLIB may be optional if SETRC is
 placed in the system's link list but otherwise simply points to
 where SETRC is stored.

 The only real input is provided by the PARM statement. The
 number provided will be used to set the return code, that is,
 placed in register 15 prior to the program's termination.  Since
 SETRC operates like IEFBR14, file allocation or deletion may be
 performed within its JCL.


:HEADER1   SAMPLE JCL AND OUTPUT

 An example of JCL that may be used is:

      //TEST412   EXEC  PGM=SETRC,PARM=412

      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB

 The above step will cause the following JES message to be
 generated:

       JOBNAME TEST412 - STEP WAS EXECUTED - COND CODE 0412

 An example of how SETRC might be used to test COND code checking
 outcomes is:

      //PROCX2     PROC

      //PS21       EXEC     PGM=IEFBR14

      //PS22       EXEC     PGM=IEFBR14

      //             PEND

      //***

      //PROCX1     PROC

      //PS11       EXEC     PGM=SETRC,PARM=08

      //STEPLIB      DD       DISP=SHR,DSN=SYS4.LINKLIB

      //*

      //PS12       EXEC     PGM=SETRC,PARM=00

      //STEPLIB      DD       DISP=SHR,DSN=SYS4.LINKLIB

      //*

      //PS13       EXEC     PROCX2,COND=(8,LE,EXPRC.PS11)

      //             PEND

      //***

      //EXPRC      EXEC     PROCX1

 showing exactly what will happen if PROCX1's step PS11
 returns a code of 8.


:HEADER1   PACKAGE CONTENTS

 The files involved specifically with SETRC are:

     - SETRC      the Assembler code wrapped in JCL to
                  assemble and link edit it

     - SETRC$     a JCL skeleton for its execution

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  SMARTGN
:DOCTITLE2 Generate Card Images from List
:TLRDATE   November 14, 1999
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for
 generating card images using an input list to replace tokens in
 a skeleton set of those images (SMARTGN).

 For example, if you have a list of 1,000 data set names and wish
 to generate delete cards for an IEFBR14, SMARTGN would do so
 with a minimal set of JCL delete cards. Please see the GETDSNS
 Edit macro for a tool to provide data set names by wildcard
 input.

 SMARTGN also allows substitution of the run date in various
 formats, run time, and the sequence number of the list input
 item.  Some understanding of Job Control Language (JCL) is
 required as well as knowledge of how programs are executed.

 SMARTGN is mainframe freeware.  You do not need to register to
 use SMARTGN. It may be placed on any archive, web site or
 bulletin board without restraint.  It may be distributed by any
 means, provided that no charge is made other than for reasonable
 distribution costs.

 Steli Inc. has made its best effort to provide working,
 tested code.  However, nothing is perfect - there may be
 flaws and there certainly could be improvements.  All
 questions, concerns, problems and suggestions are welcome
 and may be sent to C_Hafner@HotMail.Com.


:HEADER1   EXECUTION JCL

 The job control language (JCL) for SMARTGN is:

      //GENCNTL    EXEC     PGM=SMARTGN  ( ,REGION=4M )

      //SYSCTL       DD       DATA,DLM=XX

      skeleton-item...

      skeleton-item...

      skeleton-item...

            ...

      XX

      //SYSOUT       DD       DSN=USERID.SMARTGN.OUTPUT,

      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE

      //             DCB=(RECFM=FB,LRECL=00080,BLKSIZE=00000)

      //SYSIN        DD       *

      LIST-ITEM.1.

      LIST-ITEM.2.

      LIST-ITEM.3.

          ...

      //STEPLIB      DD       DISP=SHR,DSN=...

 Optional control language elements are shown in parentheses.
 The name of the program  may be changed as desired providing
 that the actual program is linked with the appropriate name or
 alias.  REGION is optional - the default region size may be more
 then adequate depending on your local standards.

 SYSCTL contains the skeleton images to be populated with the
 SYSIN items, that is, the SYSCTL file is generated once for each
 item in the SYSIN file replacing tokens as shown below.  The
 rationale for using DD DATA with a delimiter is that SYSCTL
 could contain JCL with embedded /* cards.

 Any question mark (?) character found in the skeleton is
 replaced by the current list element. An exclamation point (!)
 is replaced by the run date in YYMMDD form, a percent sign (%)
 by the run date in CCYYMMDD form, and an at sign (@) by the run
 time in HHMMSS form.

 One or more contigious pound signs (up to 8) are replaced by the
 number of the current list item, right justified and zero
 padded. For example, if processing the 3rd item in SYSIN,
 finding a ### would cause 003 to replace the ###.

 SYSOUT will contain the generated images.

 SYSIN contains the list of items to be substituted into the
 SYSCTL images one at a time.

 STEPLIB may be optional if SMARTGN is placed in the system's link
 list but otherwise simply points to where SMARTGN is stored.


:HEADER1   SAMPLE JCL AND OUTPUT

 A sample of what might be submitted is:

      //           EXEC     PGM=SMARTGN,REGION=4M

      //SYSCTL       DD       DATA,DLM=XX

      //DEL####  DD  DSN=?,

      //  DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)

      XX

      //SYSOUT       DD       DSN=USERID.SMARTGN.OUTPUT,

      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE

      //             DCB=(RECFM=FB,LRECL=00080,BLKSIZE=00000)

      //SYSIN        DD       *

      SYS1.DSN610.SDSNLINK.MAINT1

      SYS1.DSN610.SDSNLINK

      SYS1.DSN610.SDSNLOAD

      SYS1.DSN610.SDSNLOAD.MAINT2

      //STEPLIB      DD       DISP=SHR,DSN=SYS4.USER.LOADLIB

 Would cause the following to be written to the SYSOUT file:

      //DEL0001  DD  DSN=SYS1.DSN610.SDSNLINK.MAINT1,

      //  DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)

      //DEL0002  DD  DSN=SYS1.DSN610.SDSNLINK,

      //  DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)

      //DEL0003  DD  DSN=SYS1.DSN610.SDSNLOAD,

      //  DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)

      //DEL0004  DD  DSN=SYS1.DSN610.SDSNLOAD.MAINT2,

      //  DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)

 Another sample is:

      //BKUPGEN    EXEC     PGM=SMARTGN,REGION=4M

      //SYSCTL       DD       DATA,DLM=XX

      //***

      //DEL#####   EXEC     PGM=IEFBR14

      //DEL          DD       DSN=?.BK!,

      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)

      //***

      //GEN#####   EXEC     PGM=IEBGENER,REGION=4M

      //SYSPRINT     DD       SYSOUT=*

      //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,

      //             DSN=?

      //SYSUT2       DD       DISP=(,CATLG),

      //             UNIT=SYSDA,SPACE=(CYL,(50,20),RLSE),

      //             DCB=(?,BUFNO=32),

      //             DSN=?.BK!

      //SYSIN        DD       DUMMY

      //***

      XX

      //SYSOUT       DD       DSN=USERID.SMARTGN.OUTPUT,

      //             DISP=(,CATLG),UNIT=SYSDA,SPACE=(CYL,(010,010),RLSE

      //             DCB=(RECFM=FB,LRECL=00080,BLKSIZE=00000)

      //SYSIN        DD       *

      USERID.MASTER.DATA01

      USERID.MASTER.LINK01

      USERID.MASTER.INDEX

      //STEPLIB      DD       DISP=SHR,DSN=SYS4.USER.LOADLIB

 Would cause the following to be written to the SYSOUT file, assuming
 the run date was February 29, 2000:

      //***

      //DEL00001   EXEC     PGM=IEFBR14

      //DEL          DD       DSN=USERID.MASTER.DATA01.BK000229,

      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)

      //***

      //GEN00001   EXEC     PGM=IEBGENER,REGION=4M

      //SYSPRINT     DD       SYSOUT=*

      //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,

      //             DSN=USERID.MASTER.DATA01

      //SYSUT2       DD       DISP=(,CATLG),

      //             UNIT=SYSDA,SPACE=(CYL,(50,20),RLSE),

      //             DCB=(USERID.MASTER.DATA01,BUFNO=32),

      //             DSN=USERID.MASTER.DATA01.BK000229

      //SYSIN        DD       DUMMY

      //***

      //***

      //DEL00002   EXEC     PGM=IEFBR14

      //DEL          DD       DSN=USERID.MASTER.LINK01.BK000229,

      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)

      //***

      //GEN00002   EXEC     PGM=IEBGENER,REGION=4M

      //SYSPRINT     DD       SYSOUT=*

      //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,

      //             DSN=USERID.MASTER.LINK01

      //SYSUT2       DD       DISP=(,CATLG),

      //             UNIT=SYSDA,SPACE=(CYL,(50,20),RLSE),

      //             DCB=(USERID.MASTER.LINK01,BUFNO=32),

      //             DSN=USERID.MASTER.LINK01.BK000229

      //SYSIN        DD       DUMMY

      //***

      //***

      //DEL00003   EXEC     PGM=IEFBR14

      //DEL          DD       DSN=USERID.MASTER.INDEX.BK000229,

      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)

      //***

      //GEN00003   EXEC     PGM=IEBGENER,REGION=4M

      //SYSPRINT     DD       SYSOUT=*

      //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,

      //             DSN=USERID.MASTER.INDEX

      //SYSUT2       DD       DISP=(,CATLG),

      //             UNIT=SYSDA,SPACE=(CYL,(50,20),RLSE),

      //             DCB=(USERID.MASTER.INDEX,BUFNO=32),

      //             DSN=USERID.MASTER.INDEX.BK000229

      //SYSIN        DD       DUMMY

      //***

 Note the use of the date within the back up data set name as
 well as the use of the old data set name within the DCB
 parameter.


:HEADER1   PACKAGE CONTENTS

 The files involved specifically with SMARTGN are:

     - SMARTGN    the PL/I code wrapped in JCL to compile
                  and link edit it

     - SMARTGN$   a JCL skeleton for its execution

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  TOUCH
:DOCTITLE2 Set ISPF Statistics
:DOCTITLE3 For PDS Members
:TLRDATE   October 26, 1999
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for
 setting ISPF PDS member statistics (TOUCH).  Some understanding
 of Job Control Language (JCL) is required as well as knowledge
 of how programs are executed.

 TOUCH is mainframe freeware.  You do not need to register to
 use TOUCH.  It may be placed on any archive, web site or
 bulletin board without restraint.  It may be distributed by any
 means, provided that no charge is made other than for reasonable
 distribution costs.

 TOUCH is a PL/I program intended for MVS compatible systems to
 set any ISPF statistics for one or more members of one or more
 different partitioned data sets from a batch job.  All the
 statistics currently available, including Y2K compatible dates,
 may be set. TOUCH was written to allow clean up of old user ID's,
 provide an easy mechanism for turnover of identifiable members,
 and check out Y2K handling of various dates.

 Please see the TU and TD macros on File 357 of the CBT Tape
 (WWW.CBTTAPE.ORG) for panel driven capabilities of this same
 type for single members.

 Load module libraries, while they have statistics of a kind, are
 NOT supported. Messing with them usually causes nasty and
 painful after-effects. TOUCH will allow you to change editable
 PDS member statistics.

 Steli Inc. has made its best effort to provide working,
 tested code.  However, nothing is perfect - there may be
 flaws and there certainly could be improvements.  All
 questions, concerns, problems and suggestions are welcome
 and may be sent to C_Hafner@HotMail.COM.


:HEADER1   EXECUTION JCL

 The job control language (JCL) for TOUCH is:

      //           EXEC     PGM=TOUCH, ( ,REGION=4M )

      //STEPLIB      DD       DISP=SHR,DSN=...

      //SYSPRINT     DD       SYSOUT=*

      //SYSIN        DD       *

        DSNAME = 'SYS2.CLIST',

          MEMBER = 'MEMNAME',

            ALIAS         = 'N',

            VERSIONNUMBER = 01,

            MAINTNUMBER   = 01,

            CREATEDATE    = 20010101,

            CHANGEDATE    = 20010101,

            CHANGETIME    = 1234,

            INITIALSIZE   = 12345,

            CURRENTSIZE   = 12345,

            MODCOUNT      = 0,

            USERID        = 'SOMEONE';

 Optional control language elements are shown in parentheses.
 The name of the program  may be changed as desired providing
 that the actual program is linked with the appropriate name or
 alias.  REGION is optional - the default region size may be more
 then adequate, but REGION=4M can't hurt.

 STEPLIB may be optional if TOUCH is placed in the system's link
 list but otherwise simply points to where TOUCH is stored.

 The SYSPRINT file mirrors the input and contains any error
 messages; it may be directed to any output class or may be sent
 to a new or existing file.  The DCB attributes of SYSPRINT may
 be either Fixed or Variable, blocked or unblocked, and any
 record length over 60 bytes.  That is, it can be FBA/80/6160 or
 VBA/125/32760, or just leave DCB off and have it default.

 Note there is no DD card pointing to the PDS to be updated.  The
 internal assembler routines dynamically allocate and free the
 PDS for processing.

 SYSIN control cards determine the member to be updated and also
 what values are used. The file is being accessed via PL/I's
 stream I/O facility, is basically free form but does require a
 semi-colon at the end of each member set.

 The DSNAME and MEMBER keywords specify the name of the
 partitioned data set and the member to have its statistics
 updated. If the member has no statistics as it is, dummy
 statistics will be set up for everything except the ones
 specified.

 ALIAS may be used to set the alias switch on or off. If set on,
 ALIAS = 'Y', then the statistics may not be viewable under View
 or Edit.

 VERSIONNUMBER and MAINTNUMBER are self describing numeric
 values, as is MODCOUNT (the modification count).  CREATEDATE and
 CHANGEDATE may be of the form CCYYMMDD (century, year, month and
 day) or of the form CCYYDDD (century, year and Julian # of
 days).  CHANGETIME is of the form HHMM (24 hour HH value
 followed by minutes) but seconds defaults to 0.

 INITIALSIZE and CURRENTSIZE reflect the number of records in the
 original creation and current status. Changing these may not
 make any sense. The maximum value is 65,535 which is shown even
 if there are 100,000 records in the member in question.

 USERID is the creator or last updater. It may only be 7
 characters long.


:HEADER1   SAMPLE JCL AND OUTPUT

 A sample of what might be submitted is:

      //UPDATE     EXEC     PGM=TOUCH,REGION=4M

        DSNAME = 'SYS1.MACLIB',  MEMBER = 'GET',
           CHANGEDATE    = 19940101,
           CHANGETIME    = 1234,
           USERID        = 'COOLGUY';

        DSNAME = 'SYS1.MACLIB',  MEMBER = 'PUT',
           CHANGEDATE    = 20061231,
           USERID        = 'COOLGUY';

        DSNAME = 'SYS4.CLIST',   MEMBER = 'FLOW',
           CHANGEDATE    = 20000101,
           MODCOUNT      = 0,
           USERID        = 'BASEVER';

      //STEPLIB      DD       DISP=SHR,DSN=SYS4.USER.LOADLIB

      //SYSPRINT     DD       SYSOUT=*

 The blank lines shown above are accepted and ignored; they are
 there only for readability.  Assume the original values as seen
 under ISPF View were:

    Name   Prompt   Size    Created           Changed         ID
   ------  ------  -----  ----------  -------------------  -------
   GET                 9  2001/02/18  2001/02/23 10:03:08 KLUTZ
   PUT
 ...................................................................
   FLOW              184  2001/02/23  2001/02/23 10:03:29 SYSTEM

 Note the above have GET/PUT separated from FLOW since they are
 in different data sets and PUT has no statistics.  The results
 would be:

    Name   Prompt   Size    Created           Changed         ID
   ------  ------  -----  ----------  -------------------  -------
   GET                 9  2001/02/18  1994/01/01 12:34:00  COOLGUY
   PUT             65535  2001/02/23  2006/12/31 14:13:00  COOLGUY
 ...................................................................
   FLOW              184  2001/02/23  2000/01/01 10:03:29  BASEVER

 The stats for PUT picked up the date and time of the executuion
 for Create Date and for Change Time. It set the Current Size to
 the maximum value. Note too you can select dates not only in the
 past but also in the future.

 PDSGEN, which generates control cards from directory information,
 might well be used in conjunction with TOUCH by generating the
 skeleton control cards for existing PDS's. It's available from the
 same source as TOUCH.


:HEADER1   PACKAGE CONTENTS

 The files involved specifically with TOUCH are:

     - TOUCH      the PL/I code wrapped in JCL to compile
                  and link edit it

     - BLDR       the Assembler code wrapped in JCL to
                  assemble and link edit it

     - STOWR      the Assembler code wrapped in JCL to
                  assemble and link edit it

     - TOUCH$     a JCL skeleton for its execution

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  UNTOUCH
:DOCTITLE2 Remove Extraneous Directory Information
:DOCTITLE3 From Partitioned Data Sets
:TLRDATE   February 14, 2001
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for the
 utility to remove extraneous directory statistics (UNTOUCH).
 Some understanding of Job Control Language (JCL) is required as
 well as knowledge of how programs are executed.

 UNTOUCH is mainframe freeware.  You do not need to register
 to use UNTOUCH.  It may be placed on any archive, web site
 or bulletin board without restraint.  It may be distributed
 by any means, provided that no charge is made other than for
 reasonable distribution costs.

 UNTOUCH is intended for MVS compatible systems to remove any
 unneeded directory information from partitioned data sets
 (PDS's). If a member has no such information, it is left alone.
 This would be done to enhance access performance to a CLIST,
 PROC library or macro library as well as freeing up directory
 space.  The name, UNTOUCH, refers in a contrary way to the
 ability to "touch" a member, that is, set statistical
 information.  This simply removes everything except the bare
 bones name, TTR and attribute byte.

 UNTOUCH is a PL/I program with an assembler subroutine that can
 process a name range or a specific number of members. It is
 intended to be used on libraries where there's some advantage to
 removing the statistical data.  It should never be used on a
 load module library since the directory information stored
 within is critical to executing those members.

 Steli Inc. has made its best effort to provide working,
 tested code.  However, nothing is perfect - there may be
 flaws and there certainly could be improvements.  All
 questions, concerns, problems and suggestions are welcome
 and may be sent to C_Hafner@HotMail.Com.


:HEADER1   EXECUTION JCL

 The job control language (JCL) for UNTOUCH is:

           //UNTOUCH    EXEC     PGM=UNTOUCH  ( ,REGION=4M )

           //SYSUT1       DD       DISP=SHR,DSN=...

           //SYSIN        DD       *

               FIRST=000001,        LAST=999999,

               FIRSTMEM='        ', LASTMEM='99999999';

           //SYSPRINT     DD       SYSOUT=*

           //STEPLIB      DD       DISP=SHR,DSN=...

 Optional control language elements are shown in parentheses.
 The name of the program  may be changed as desired providing
 that the actual program is linked with the appropriate name
 or alias.

 REGION is optional.  STEPLIB may be optional if UNTOUCH is
 placed in the system's link list but otherwise simply points to
 where UNTOUCH is stored.

 The SYSPRINT file may be directed to any output class or may
 be sent to a new or existing file.  The DCB attributes of
 SYSPRINT will be record format FBA and LRECL 121.  This file
 will show the number of members processed.

 SYSUT1 points to the partitioned data set to be processed.

 SYSIN contains control information on the range or number of
 members to be processed. The default shown will basically
 process the entire PDS, unless there are more then 999,999
 members or the actual member names are outside the range of
 blanks through all 9's.  FIRST and LAST refer to the number of
 the members in the PDS, that is, the very first member is 1.
 FIRSTMEM and LASTMEM refer to the actual names of the members,
 e.g. COPYTO or ASMA90.

 To remove the statistics from the name range of GET through PUT
 inclusive, you'd have:

               FIRST=000001,        LAST=999999,
               FIRSTMEM='GET     ', LASTMEM='PUT     ';

 Note the control card data is free form and does not need to be
 aligned in any way. The sample shown here was aligned for
 readability only.  So the following is equivalent to the
 previous set:

    FIRST=000001, LAST=999999, FIRSTMEM='GET     ', LASTMEM='PUT     ';

 The commas and final semicolon are necessary for PL/I stream
 input.  If an error occurs, the program will terminate returning
 the code received from attempting to replace the member
 information.


:HEADER1   SAMPLE JCL AND OUTPUT

 An example of JCL that may be used is:

      //CLEANUP   EXEC  PGM=UNTOUCH,REGION=4M

      //SYSIN       DD    *

               FIRST=000001,        LAST=999999,

               FIRSTMEM='ELIG001 ', LASTMEM='ELIG999 ';

      //STEPLIB      DD        DISP=SHR,DSN=SYS4.LINKLIB

      //SYSPRINT     DD        SYSOUT=C

      //SYSUT1       DD        DISP=SHR,DSN=SYS1.PROCLIB

 The above step will remove the extra directory information, if
 any, from members in SYS1.PROCLIB from member ELIG001 through
 ELIG999.

 So, if the PDS looked like the following in ISPF Edit:

       Name      Prompt  Size    Created           Changed           ID
      @README@
      ADDDOTSL             42  2001/02/09  2001/02/09 07:35:40  USER002
      ADDFLAG              56  2001/02/09  2001/02/09 07:35:40  USER002
      ADDLINEA              4  2001/02/09  2001/02/09 07:35:40  USER002
      ADDLINEB              4  2001/02/09  2001/02/09 07:35:40  USER002
      ADDLINES             84  2001/02/09  2001/02/09 07:35:40  USER002
      ALLMEM
      ALLMEMC               5  2001/02/09  2001/02/09 07:35:40  USER002
      ALLMEMF

 resulting in the following after UNTOUCH runs:

       Name      Prompt  Size    Created           Changed           ID
      @README@
      ADDDOTSL
      ADDFLAG
      ADDLINEA
      ADDLINEB
      ADDLINES
      ALLMEM
      ALLMEMC
      ALLMEMF


:HEADER1   PACKAGE CONTENTS

 The files involved specifically with UNTOUCH are:

     - STOWU      the assembler source code wrapped in JCL
                  to assemble and link it

     - UNTOUCH    the PL/I code wrapped in JCL to compile
                  and link edit it

     - UNTOUCH$   a JCL skeleton for its execution

:RESET
:PAGESIZE  58
:LINESIZE  80
:TOC       YES
:DOCTITLE  VALUES
:DOCTITLE2 Summarize All Data Values
:DOCTITLE3 From a Sequential File
:TLRDATE   February 29, 2004
:TLRDESC   Freeware from Steli Inc.
:HEADER1   INTRODUCTION

 This document is intended to provide user information for
 summarizing data values from a sequential file (VALUES).  Some
 understanding of Job Control Language (JCL) is required as well
 as knowledge of how programs are executed.

 VALUES is mainframe freeware.   You do not need to register to
 use VALUES.  It may be placed on any archive, web site or
 bulletin board without restraint.  It may be distributed by any
 means, provided that no charge is made other than for reasonable
 distribution costs.

 VALUES is a PL/I program intended for MVS compatible systems to
 list all the distinct values present in specific columns of a
 sequential file.  It processes totally in memory and shows the
 values for one or more sets of columns in the order that the
 values occur, in the order of their EBCDIC collating sequence,
 or in descending order of the number of occurrences for each
 value.  The intention is to provide fast and concise analysis of
 the data.

 Steli Inc. has made its best effort to provide working,
 tested code.  However, nothing is perfect - there may be
 flaws and there certainly could be improvements.  All
 questions, concerns, problems and suggestions are welcome
 and may be sent to C_Hafner@HotMail.Com.


:HEADER1   EXECUTION JCL

 The job control language (JCL) for VALUES is:

      //VALUES     EXEC     PGM=VALUES,REGION=464M,

      //             PARM='HEAP(01M,01M,ANYWHERE)/      '

      //*               -- SORT BY ACTUAL VALUES /VALUES'

      //*               -- SORT BY # OCCURRENCES /OCCURS'

      //I            DD       DCB=BUFNO=32,

      //             DISP=SHR,DSN=...

      00001-00005      * FROM/TO COLUMNS IN 1 THRU 11

      00051-00060      * COMMENTS IN COLUMNS 12 ONWARD

      00021*00023      * ANY NON DASH IN COL 6 SUMS EACH COL & TOTAL

      //STEPLIB      DD       DISP=SHR,DSN=...

      //SYSPRINT     DD       SYSOUT=*

 Optional control language elements are shown in parentheses.
 The name of the program  may be changed as desired providing
 that the actual program is linked with the appropriate name
 or alias.

 REGION is optional but needs to allow for keeping the entire
 linked list of values in memory at one time.

 The PARM reflects getting heap memory in chunks of 1 megabyte -
 this is sent to the language environment.  The slash separates
 the language parameter from the program paramter. A blank
 program parameter causes the values to be listed as they occur.
 VALUES causes them to be sorted by the actual values and OCCURS
 causes the listed items to be sorted descending by their number
 of occurences.

 STEPLIB may be optional if VALUES is placed in the system's link
 list but otherwise simply points to where VALUES is stored.

 The SYSPRINT file may be directed to any output class or may be
 sent to a new or existing file.  The DCB attributes of SYSPRINT
 may be either Fixed or Variable, blocked or unblocked, and any
 record length over 60 bytes.  That is, it can be FBA/80/6160 or
 VBA/125/32760, or just leave DCB off and have it default.

 The SYSIN control cards consist simply of the 5 digit starting
 column of the data, a dash and the 5 digit ending column.  Any
 data beyond column 11 is considered a comment and will only be
 shown in the output listing.


:HEADER1   SAMPLE JCL AND OUTPUT

 An example of JCL that may be used is:

      //SUMMARY    EXEC     PGM=VALUES,REGION=464M,

      //             PARM='HEAP(01M,01M,ANYWHERE)/VALUES'

      //I            DD       *

                02-01-99

                02-11-99

                02-08-00

                02-06-04

                02-03-99

                02-11-01

                02-06-99

                02-11-99

                02-11-99

                02-11-99

      //SYSIN        DD       *

      00011-00012  SUMMARIZE MONTHS IN INPUT

      00014-00015  SUMMARIZE DAY VALUES IN INPUT

      00011-00018  SUMMARIZE THE ENTIRE DATE VALUE

      00011X00018  SUMMARIZE THE CHARACTERS IN 11 TO 18

      //STEPLIB      DD       DISP=SHR,DSN=SYS1.RUBBER.DUCKY

      //SYSPRINT     DD       SYSOUT=*

 The above step will produce the following output:

   RECORD COUNT =           10

   COLUMN(S)    11-   12 CONTAIN             1 UNIQUE VALUE(S) --
   SUMMARIZE MONTHS IN INPUT
                 10 >>02<<

   COLUMN(S)    14-   15 CONTAIN             5 UNIQUE VALUE(S) --
   SUMMARIZE DAY VALUES IN INPUT
                  1 >>01<<
                  1 >>03<<
                  2 >>06<<
                  1 >>08<<
                  5 >>11<<

   COLUMN(S)    11-   18 CONTAIN             7 UNIQUE VALUE(S) --
   SUMMARIZE THE ENTIRE DATE VALUE
                  1 >>02-01-99<<
                  1 >>02-03-99<<
                  1 >>02-06-04<<
                  1 >>02-06-99<<
                  1 >>02-08-00<<
                  1 >>02-11-01<<
                  4 >>02-11-99<<

   COLUMN(S)    11 THRU    18 HAVE             9 UNIQUE VALUE(S) --
   SUMMARIZE THE CHARACTERS IN 11 TO 18
              20 >>-<<
              19 >>0<<
              12 >>1<<
              10 >>2<<
               1 >>3<<
               1 >>4<<
               2 >>6<<
               1 >>8<<
              14 >>9<<

 Note the record count is shown, 10, and the control cards do not
 have to be in any order. Also, the fields may, as in this case,
 overlap. The COLUMN(S) line also shows the number of unique values.

 The first 3 sets of data may be verified against the input to
 see that there are 10 occurrences in each set and that the
 values shown match against the input too. We'd asked that the
 output be sorted by value and that also can be seen easily.

 The 4th control card requests that the individual columns be
 summarized and those summaries combined. This is useful when
 you want to see what characters comprise certain fields or
 even the entire record. You can easily see that the date field
 contained only dashes and the 10 numeric digits.

:HEADER1   PACKAGE CONTENTS

 The files involved specifically with VALUES are:

     - VALUES     the PL/I code wrapped in JCL to compile
                  and link edit it

     - VALUES$    a JCL skeleton for its execution

