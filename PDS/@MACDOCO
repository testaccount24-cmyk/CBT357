:*  Full formal documentation for CLISTs and EXECs
:PAGESIZE  55
:LINESIZE  80
:TOC       YES
:DOCTITLE  TSO
:DOCTITLE2 Productivity
:DOCTITLE3 Extensions
:TLRDATE   June 15, 2004
:TLRDESC   Freeware from Steli Inc.
:HEADER1   Introduction

 This document is intended to provide user information for the
 OS/390 and z/OS MVS freeware REXX and CLIST macros included in
 this package.  Some understanding of the operating system, TSO,
 and ISPF Edit, View and DS List is required.

 These are freeware macros which have been gathered together to
 provide consistent, proven and documented tools to:

    - reduce key strokes

    - improve visualization

    - eliminate custom coding to accomplish a task

    - automate a calculation

 In other words, they're intended to help improve mainframe user
 productivity.  These macros extend various ISPF capabilities to:

    - Manipulate columns of data

    - Convert data

    - Manipulate code

    - Manipulate JCL

    - Display (include/exclude) data differently

    - Consolidate data

    - Format data

    - Find data differently

 These tools were created by Steli or modified from source made
 available by others.  Names were chosen as seemed appropriate
 but nothing prevents changing them to other, hopefully more
 meaningful ones.  Steli has made its best effort to provide
 working, tested code.  However, nothing is perfect - there may
 be flaws due to oversights, system variations, or errors, and
 there certainly could be improvements.  All questions, concerns,
 problems and suggestions are welcome; e-mail may be sent to
 C_Hafner@HotMail.Com.

 Particular thanks for assistance, encouragement, (good) ideas
 and sample code go to Dave Alcock, Larry Dick, Hugh Mitchell,
 Jim Moore, Doug Nadel, Richard Rubin, Gilbert StFlour and Mark
 Zelden.


:HEADER1 Known Problems

 The COBCOLO and COBCOLS macros using InSync and FileAid do not
 always complete correctly when REDEFINES or OCCURS are present.
 We have been working to eliminate these glitches but we may not
 have them all corrected. OCCURS within OCCURS definitely
 presents a challenge. COBCOLV, the direct call to InSync or
 FileAid obviously functions correctly.

 TSO apparently does not have a generic clear screen function
 that exists on every (or most) systems.  The function used
 throughout many macros herein is:

    ADDRESS TSO "CLEAR"

 It is always written exactly as shown!  This may not work at
 your site depending on how/what the systems folks have set up.
 If need be, I'd suggest using ALLMEM (and ALLMEMC with the
 appropriate change command) to either comment the statement out
 or replace it with the call shown in the following paragraph.

 The same CBT Tape File 357 that contains this macro package also
 contains an assembler clear screen program that appears to be
 universal. The program is called CLRSCRN and would be invoked in
 place of the above as :

       "CALL 'YOUR.LOAD.MODULE.LIB(CLRSCRN)'"

 We have also been told many of the macros run slowly as the
 edited data sizes grow. We can only suggest running them in
 batch to alleviate this. As time permits, we will review all of
 the macros again trying to improve their performance.


:HEADER1 Gaining Execution Access

 To use these macros, you may add a library (a Partitioned Data
 Set or Partitioned Data Set Extended) with those macros to your
 SYSPROC DD under TSO or place the macros in an existing library
 already in the SYSPROC concatenation.  Use TSO ISRDDN to check
 the DD files associated with your TSO LOGON.  For the latter,
 simply copy the members you want into an existing library
 (please note these macros are in fixed record format of 80 bytes
 - they will not play nicely with VB/255 libraries).  The
 CONCATDD macro will help do the former.  Assuming that you've
 loaded them to your own library and they're in YOURID.CLIST,
 execute under the TSO command option:

      EX 'YOURID.CLIST(CONCATDD)' 'SYSPROC YOURID.CLIST'

 There are a few CLISTs in this collection so I've always
 concatenated my library to the front of SYSPROC rather then to
 SYSEXEC.  I have also seen problems when trying to concatenate
 to SYSEXEC from within certain LOGON EXEC's (EXEC's specified in
 a sequential file executed when you logon, if it exists with a
 specific pattern, e.g. YourUserID.SIGNON).  Use TSO ISRDDN to
 check the allocation to make sure your file is there if you get
 macro not found messages.

 The above command will dynamically add YOURID.CLIST (note fully
 qualified with no quotes) to the front of the SYSPROC
 concatenation for this current LOGON.  Many sites have a sign-on
 process that will let you execute this line automatically each
 time you logon (please see comment above about using SYSEXEC).

 The following macros, with the exception of the DS List macros
 and member list macros, are executable under either EDIT or VIEW
 (some, such as BS or CC may be invoked anywhere, ala TSO BS
 120).  The benefits of use are available in VIEW and the
 resulting data, even if changed, can use VSAVE or REPLACE to
 save existing data, or CREATE a new member.  Plus VIEW provides
 a safety factor in that an accidental F3 press will not overlay
 good data and you get a warning that data has changed.
 Whatever, when doing extensive changes, saving is always a good
+          _____________________________________________________
 idea!
+_____

 The following PF key assignments are suggested to maximize the
+                                     _________
 effect of the provided tool set.  Note there is no DELETE key!
 Unless you are extremely precise, it's all too easy to
 accidently delete a line.

       F1 . . . HELP           F13  . .  %TSJ
       F2 . . . SPLIT NEW      F14  . .  SWAP LIST
       F3 . . . EXIT           F15  . .  CUT
       F4 . . . :I             F16  . .  %PY
       F5 . . . RFIND          F17  . .  %FALT
       F6 . . . RCHANGE        F18  . .  :R
       F7 . . . UP             F19  . .  %JB
       F8 . . . DOWN           F20  . .  %JT
       F9 . . . SWAP NEXT      F21  . .  %XINDENT
       F10  . . LEFT           F22  . .  %DISPVAR
       F11  . . RIGHT          F23  . .  %ZVW
       F12  . . :COLS          F24  . .  CRETRIEV

 Most of the above key assignments are generic ISPF commands with
 the exception of DISPVAR, FALT, JB, JT, PY, TSJ, XINDENT and ZVW
 which come with this package.

 If you use KEYLIST OFF as I do, please be aware that every
 separate application has its own KEYS settings.


:HEADER1 Column Manipulation Macros

 The following are column oriented macros. If you type the macro
 name on the command line without any parameters, you'll get a
 help screen describing it.

 They also will accept and use line labels like .A and .B as
 shown in their formats (but any legal labels may be used).  The
 ability to set and keep labels was deliberately done to allow for
 repeated changes to the same set of lines.  Optional parameters
 are shown in parentheses.


:HEADER2 COPYCOLS   FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL ( .A .B )
:HEADERT Copy Columns Onto Other Columns

       copies columns over other columns, e.g.

          COPYCOLS  11 20  41

       will leave the data in columns 11 thru 20 as it exists
       and make a copy onto columns 41 thru 50. The columns are
       mandatory but the label ranges are optional. Given the
       following data:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5

       the results of 'COPYCOLS 11 20 41' would be:

          ----+----1----+----2----+----3----+----4----+----5-
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddbbbbbbbbbb
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddbbbbbbbbbb
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddbbbbbbbbbb
          ----+----1----+----2----+----3----+----4----+----5-


:HEADER2 COPYINS   FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL  ( .A .B )
:HEADERT Copy Columns Inserting Before Other Columns

       copies columns into the data, that is, the copied data
       will be inserted at the TO-LEFT-COL column and the columns
       from the TO-LEFT-COL to the right will be shifter
       accorcingly.  The columns are required but the ranges are
       optional. For example:

          COPYINS  11  20  1  .XX .YY

       will take a copy of columns 11 thru 20 in the range of .XX
       through .YY and put them in column 1 through 10 shifting
       what was in column 1 and following 9 columns to the right.
       For example, given:

          000001 AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd
          =COLS> ----+----1----+----2----+----3----+----4----+----5
          .XX    AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd
          000003 AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd
          .YY    AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd
          =COLS> ----+----1----+----2----+----3----+----4----+----5
          000005 AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd

       the result of 'COPYINS  11  20  1  .XX .YY' would be:

          000001 AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd
          =COLS> ----+----1----+----2----+----3----+----4----+----5
          .XX    bbbbbbbbbbAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd
          000003 bbbbbbbbbbAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd
          .YY    bbbbbbbbbbAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd
          =COLS> ----+----1----+----2----+----3----+----4----+----5
          000005 AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd


:HEADER2 CVB  FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2) (-MINUS-COL) (.A .B)
:HEADERT Convert Numeric Display Data to Binary

       converts the numbers in the specified columns to binary.
       The FROM- columns specify the numeric display data and are
       mandatory.  The TO- columns are optional and will receive
       the result; if left off, the result will be placed in the
       FROM- columns.  The receiving field does not have to be a
       multiple of 2, but probably should be 2, 4 or 8.

       The -MINUS-COL value, of the form -17, indicates the
       column from which to pick up the plus or minus sign.  If
       no sign column is specified, the zone of the rightmost
       numeric digit will be used as the sign.  For example,

          CVB  1 7  11 14  -8  .AA .XX

       will convert the numeric data in columns 1 through 7 into
       binary in columns 11 through 14, causing the binary value
       to take on the sign from column 8, in the range of label
       .AA to .XX.

       Note that CAPS will be turned off and a message will be
+      _________________________________
       displayed saying so.

       A message showing the number of overflows and the total
       valid numbers found will appear in the upper right corner.
       F1 may be pressed to see a somewhat fuller explanation.

       CVB may be used after FORMCOLS eliminates commas and
       aligns the data. DELCOLS may be used to remove periods
       after FORMCOLS is complete.

       Given the following data:

          000001 0000001
                 FFFFFFF44444444444444
                 000000100000000000000
          =COLS> ----+----1----+----2-
          .AA    0000002
                 FFFFFFF44444444444444
                 000000200000000000000
          000003 0000003-
                 FFFFFFF64444444444444
                 000000300000000000000
          .XX    0000004
                 FFFFFFF44444444444444
                 000000400000000000000
          =COLS> ----+----1----+----2-
          000005 0000005
                 FFFFFFF44444444444444
                 000000500000000000000

       the results of 'CVB  1 7  11 14  -8  .AA .XX' would be:

          000001 0000001
                 FFFFFFF44444444444444
                 000000100000000000000
          =COLS> ----+----1----+----2-
          .AA    0000002
                 FFFFFFF44400004444444
                 000000200000020000000
          000003 0000003-     Ù
                 FFFFFFF644FFFF4444444
                 0000003000FFFD0000000
          .XX    0000004
                 FFFFFFF44400004444444
                 000000400000040000000
          =COLS> ----+----1----+----2-
          000005 0000005
                 FFFFFFF44444444444444
                 000000500000000000000


:HEADER2 CVD  FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2) (-MINUS-COL) (.A .B)
:HEADERT Convert Binary Data to Numeric Display Data

       converts binary data to numeric display data.  The FROM-
       columns specify the source binary value. The length of the
       FROM- columns does not have to be a multiple of 2. The TO-
       columns specify the destination and will default to the
       FROM- columns if they are not specified.

       The -MINUS-COL, specified as a column number with a minus
       sign, will receive the sign of the result, otherwise the
       sign will be placed as the zone value of the rightmost
       result digit, e.g. 'J' for minus 1. For example,

          CVD  11 18  21 29  -30  .A .B

       will convert the binary data in columns 11 through 18 into
       numeric displayable data in columns 21 through 29, placing
       the appropriate plus/minus sign into column 30 in the line
       range .A through .B.

       A message showing the number of overflows and the number
       of lines processed will appear in the upper right corner.
       F1 may be pressed for an expanded explanation.

       FORMCOLS may be used to neatly format the resultant data
       and FILLINS to insert periods.

       Given the following data:

          000001
                 4444444444000000004444444444444
                 0000000000000000010000000000000
          =COLS> ----+----1----+----2----+----3-
          .A
                 4444444444000000014444444444444
                 0000000000000000000000000000000
          000003
                 4444444444000000004444444444444
                 0000000000000000100000000000000
          .B
                 4444444444000000104444444444444
                 0000000000000000000000000000000
          =COLS> ----+----1----+----2----+----3-
          000005
                 4444444444000000004444444444444
                 0000000000000001000000000000000

       the results of 'CVD  11 18  21 29  -30  .A .B' would be:

          000001
                 4444444444000000004444444444444
                 0000000000000000010000000000000
          =COLS> ----+----1----+----2----+----3-
          .A                         000000016+
                 44444444440000000144FFFFFFFFF44
                 00000000000000000000000000016E0
          000003                     000000256+
                 44444444440000000044FFFFFFFFF44
                 00000000000000001000000000256E0
          .B                         000004096+
                 44444444440000001044FFFFFFFFF44
                 00000000000000000000000004096E0
          =COLS> ----+----1----+----2----+----3-
          000005
                 4444444444000000004444444444444
                 0000000000000001000000000000000


:HEADER2 C2H  FROM-COL1 FROM-COL2  (TO-COL1 TO-COL2)  (.A .B)
:HEADERT Convert Hex Characters to Hex Equivalent

       converts hexidecimal characters, 'A'-'F' and '0'-'9', to
       their hex value, e.g. turns '0123456789ABCDEF' into
       X'0123456789ABCDEF'. The FROM- columns are required.  The
       TO- columns specify the destination and will default to
       the FROM- columns if unspecified.

       Given the following data,

          000000
          FFFFFF444444444444444444444444
          000000000000000000000000000000
          ----+----1----+----2----+----3
          999999
          FFFFFF444444444444444444444444
          999999000000000000000000000000
          ----+----1----+----2----+----3
          012AC3
          FFFCCF444444444444444444444444
          012133000000000000000000000000

       the result of

          C2H  1 6  11 13

       would be:

          000000
          FFFFFF444400044444444444444444
          000000000000000000000000000000
          ----+----1----+----2----+----3
          999999    rrr
          FFFFFF444499944444444444444444
          999999000099900000000000000000
          ----+----1----+----2----+----3
          012AC3      C
          FFFCCF444402C44444444444444444
          01213300001A300000000000000000

       No conversion will take place on lines where the receiving
       field is shorter then the converted data and the lost
       columns would not be hex zeros. Hex zeros will be used to
       left pad short receiving fields.

       A message showing the number of lines processed, overflows
       and the number of lines with bad data (that is, not 'A'
       thru 'F' or '0' thru '9').  F1 may be pressed for an
       expanded explanation. See H2C below for the converse.


:HEADER2 DELCOLS   LEFT-COL1 RIGHT-COL1 (...)  ( .A .B )
:HEADERT Delete Columns

       will remove the specified columns, shifting the remaining
       leftwards, as in

          DELCOLS  11  20

       deleting column 11 through 20 and shifting everything from
       column 21 to the end of each record left 10 columns.
       DELCOLS may be used as a large scale truncating left
       shift, that is,

          DELCOLS  1  20

       will cause all data to be shifted 20 positions to the
       left, but please also see SHIFT for other options.

       DELCOLS is the reverse of KEEPCOLS, removing rather then
       keeping data.  Given the following data:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5

       the results of 'DELCOLS  11 20  31 40' would be:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE
          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE
          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5

       Please note the columns specified are always based on the
       original record.  The process may be limited to ranges of
       line via either labels or C/CC/C# prefix selection. This
       macro may also be invoked against a file under DS List and
       will be shown in that section. The latter is useful when
       the file is too big to be edited.


:HEADER2 FILLCOLS   LEFT-COL  RIGHT-COL  STRING  ( .A .B )
:HEADERT Overlay Columns with a Given String

       overlays the specified columns with the given string, as

          FILLCOLS  2  9  '-*'

       will make columns 2 thru 9 contain -*-*-*-*.  The string
       will overlay as many copies as necessary to fill the
       columns, for example:

          FILLCOLS  2  9  '-=-'

       will only overlay -=--=--= onto columns 2 thru 9.  The
       columns and string are mandatory and the label range
       optional.

       For example, given the following data:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5

       the results following 'FILLCOLS  21 30  123' would be:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAAbbbbbbbbbb1231231231ddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbb1231231231ddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbb1231231231ddddddddddEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5


:HEADER2 FILLINS   LEFT-COL  STRING  ( .A .B )
:HEADERT Insert a Given String Before a Column

       inserts the string before the specified column shifting
       the current data to the right, e.g.

          FILLINS  19  'XXX'

       will insert 3 X's into columns 19, 20 and 21, and shift
       everything in the original column 19 on 3 columns to the
       right. FILLINS may be used as a right shift, namely

          FILLINS  1  '     '

       will shift everything to the right the number of blanks
       between the quotes but please also see the SHIFT macro.
       The columns and string are mandatory and the label range
       optional.  The shifting may result in data loss on the far
       right of the record.

       Given the following data:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5

       the result of 'FILLINS  11  XXXXXXXXXX' would be

          ----+----1----+----2----+----3----+----4----+----5----+----6
          AAAAAAAAAAXXXXXXXXXXbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAXXXXXXXXXXbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAXXXXXXXXXXbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5----+----6


:HEADER2 FORMCOLS FORMAT FROM-LEFT FROM-RIGHT (TO-LEFT TO-RIGHT)(.A .B)
:HEADERT Format Numeric Display Data Using Picture Format

       will reformat the arithmetic display data in the
       FROM- columns into the TO- columns, aligning and right
       justifying the data, using the formatting characters to
       define the output.  If omitted, the to-columns will
       default to the from-columns.  It will eliminate commas in
       the input, strip input of leading and trailing blanks and
       extraneous leading zeros and pick a up sign from anywhere
       in the input columns, including a zoned last character.

       The format specified is filled from the data. The special
       characters used are:

             9   replace with a digit or a zero if no digit

             Z   replace with a digit or a blank if leading
                 digit zero - may be used on far left and/or far
                 right of supplied format

             ,   leave unless no significant digits to left then
                 blank

             .   leave and use to align data

             +   replace with actual sign, either + or -

             -   replace with blank if data not negative else
                 leave

       For example,

          FORMCOLS  'ZZZ,ZZ9.99Z +'  1 10  21 35

       will reformat

             '   123    '              '      123.00  +'
             '1234567890'              '  567,890.00  +'
             '   11.M   '    into      '       11.40  -'
             '2,468.00- '              '    2,468.00  -'
             '  +0      '              '        0.00  +'

       Note FORMCOLS will handle input commas as the 4th example
       above shows and will check for the sign anywhere in the
       input.

       A message showing the total valid numbers found, the
       number of overflows and the number of lines processed
       will appear in the upper right corner. The above would
       produce "5/1/5 FORMATTED" since the second set of data
       would cause an overflow. An overflow is considered to
       be any loss of a significant (non zero) digit. Pressing
       PF1 immediately afterwards will describe the message.

       FORMCOLS can be used with CVD or UNPK to gain access to
       and neatly format originally binary or packed data.  It
       may be used prior to CVB or PK to clean up data.  MOVEINSD
       may be used to move the decimal point or FILLINS to insert
       one, if desired.


:HEADER2 H2C  FROM-COL1 FROM-COL2  (TO-COL1 TO-COL2)  (.A .B)
:HEADERT Convert Characters to Their Hex Equivalent

       converts characters, X'00'-X'FF', to their hex equivalent,
       '00' thru 'FF'.  H2C would turn X'0123456789ABCDEF' into
       '0123456789ABCDEF'. The FROM- columns are required.  The
       TO- columns specify the destination and will default to
       the FROM- columns if unspecified.

       Given the following data,

          02468ACE4444444444444444444444
          13579BDF0000000000000000000000
          ----+----1----+----2----+----3
          000000004444444444444444444444
          000000000000000000000000000000
          ----+----1----+----2----+----3
          000000FC4444444444444444444444
          000000AE0000000000000000000000

       the result of

          H2C  1 8  11 26

       would be:
                    0123456789ABCDEF
          02468ACE44FFFFFFFFFFCCCCCC4444
          13579BDF0001234567891234560000
          ----+----1----+----2----+----3
                    0000000000000000
          0000000044FFFFFFFFFFFFFFFF4444
          000000000000000000000000000000
          ----+----1----+----2----+----3
                    000000000000FACE
          000000FC44FFFFFFFFFFFFCCCC4444
          000000AE0000000000000061350000

       No conversion will take place on lines where the receiving
       field is shorter then the converted data and the lost
       columns would not be zeros. Zeros will be used to
       left pad short receiving fields.

       A message showing the number of lines processed and
       overflows (there can not be bad data since all hex values
       are processed).  F1 may be pressed for an expanded
       explanation. See C2H above for the converse.


:HEADER2 JOINCOLS  COL-1 ( ... )  ( .A  .B )
:HEADERT Concatenate Lines at Given Columns

      this macro will concatenate subsequent lines to the
      preceding line at the column or columns specified. One
      column is required.  For example

         JOINCOLS  21 41 61

      will append the 2nd line to the 1st at position 21, the 3rd
      to the combined 1st and 2nd at position 41, and the 4th to
      the combined 1st, 2nd and 3rd at position 61.  Please note
      SPLTCOLS with the same parameters produces the reverse,
      i.e. it splits them back again given no data was lost when
      the JOINCOLS was done

      For example, given the following data:

         AAAAAAAAAA
         ----+----1----+----2----+----3----+----4----+----5
         bbbbbbbbbb
         CCCCCCCCCC
         dddddddddd
         EEEEEEEEEE
         AAAAAAAAAA
         bbbbbbbbbb
         CCCCCCCCCC
         dddddddddd
         EEEEEEEEEE
         AAAAAAAAAA
         bbbbbbbbbb
         CCCCCCCCCC
         dddddddddd
         ----+----1----+----2----+----3----+----4----+----5
         EEEEEEEEEE

      the results of 'JOINCOLS  11  21  31  41' would be:

         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
         ----+----1----+----2----+----3----+----4----+----5
         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
         ----+----1----+----2----+----3----+----4----+----5


:HEADER2 KEEPCOLS  LEFT-COL1 RIGHT-COL1 (...)  ( .A .B )
:HEADERT Retain Columns Deleting All Other Columns

       will keep the specified columns, shifting them to the
       left, as running the following against a 200 file:

          KEEPCOLS  11 20  101 103  141 142

       effectively deletes columns 1 through 10, 21 through 100,
       104 through 140 and 143 through 200.  The selected columns
       will be in the left-most 15 columns and the other 185
       columns will be blank.

       KEEPCOLS is the reverse of DELCOLS, retaining rather then
       removing data.  Given the following data:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5

       the results of 'KEEPCOLS  11 20' would be:

          ----+----1----+----2----+----3----+----4----+----5
          bbbbbbbbbb
          bbbbbbbbbb
          bbbbbbbbbb
          ----+----1----+----2----+----3----+----4----+----5

       The process may be limited to a range of lines via either
       labels or C/CC/C# prefix selection. This macro may also
       be invoked against a file under DS List and will be
       shown in that section.


:HEADER2 MOVECOLD   FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL ( .A .B )
:HEADERT Move Columns Overlaying Destination and Deleting Source

       will take the specified columns and overlay them onto the
       receiving column, deleting the originating data.  For
       example,

          MOVECOLS  21 25  68

       will replicate what's in columns 21 thru 25 onto columns
       68 thru 72 and then delete columns 21 thru 25, shifting
       the data from column 26 onwards 5 columns to the left.
       (eliminating the original columns).  MOVECOLD is a variant
       of MOVECOLS, MOVEINS and MOVEINSD.

       For example, given:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5

       the results of 'MOVECOLD  31 40  11' would be:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAAddddddddddCCCCCCCCCCEEEEEEEEEE
          AAAAAAAAAAddddddddddCCCCCCCCCCEEEEEEEEEE
          AAAAAAAAAAddddddddddCCCCCCCCCCEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5


:HEADER2 MOVECOLS   FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL ( .A .B )
:HEADERT Move Columns Overlaying Other Columns

       will take the specified columns and overlay them onto the
       receiving column, blanking the originating data.  For
       example,

          MOVECOLS  21 25  68

       will replicate what's in columns 21 thru 25 onto columns
       68 thru 72 and then blank columns 21 thru 25. DELCOLS may
       be used to eliminate the original columns.  MOVECOLS is
       useful if consolidating columns as you can see progress as
       source fields are blanked.

       For example, given the following data:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5

       the result of 'MOVECOLS  31 40  11' would be:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAAddddddddddCCCCCCCCCC          EEEEEEEEEE
          AAAAAAAAAAddddddddddCCCCCCCCCC          EEEEEEEEEE
          AAAAAAAAAAddddddddddCCCCCCCCCC          EEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5


:HEADER2 MOVEINS   FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL  ( .A .B )
:HEADERT Move Columns Inserting Before Other Columns

       will take the specified columns and insert them into the
       receiving column, shifting displaced data to the right,
       and blanking the originating data.  For example,

          MOVEINS  1 5  30  .S .E

       will replicate what's in columns 1 thru 5 into columns 30
       thru 34, shifting the data in columns 30 onward to the
       right 5 columns, and then blank columns 1 thru 5, within
       the .S thru .E range.  DELCOLS may be used to remove the
       original blank columns or MOVEINSD may be used instead of
       MOVECOLS to do the insert and then automatically delete
       the originating columns.

       Given the following:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5

       the result of 'MOVEINS  11 20  31' would be:

          ----+----1----+----2----+----3----+----4----+----5----+----6
          AAAAAAAAAA          CCCCCCCCCCbbbbbbbbbbddddddddddEEEEEEEEEE
          AAAAAAAAAA          CCCCCCCCCCbbbbbbbbbbddddddddddEEEEEEEEEE
          AAAAAAAAAA          CCCCCCCCCCbbbbbbbbbbddddddddddEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5----+----6


:HEADER2 MOVEINSD  FROM-LEFT-COL  FROM-RIGHT-COL  TO-LEFT-COL  ( .A .B )
:HEADERT Move & Delete Columns Inserting Before Other Cols

       will take the specified columns and insert them into the
       receiving column, shifting displaced data to the right,
       and deleting the originating data.  For example,

          MOVEINSD  11 15  1  .BEG .END

       will replicate what's in columns 11 thru 15 into column 1
       thru 5, shifting the other data 5 columns to the right,
       and deleting the original columns 11 thru 15, within the
       .BEG thru .END range. This is a variation of MOVEINS which
       essentially allows moving data around with records.

       Note if the source is to the left of the receiving column,
       the newly inserted data will take part in a shift to the
       left when the source is removed.

       With the following data:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5

       the result of 'MOVEINSD  41 50  1' is:

          ----+----1----+----2----+----3----+----4----+----5
          EEEEEEEEEEAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd
          EEEEEEEEEEAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd
          EEEEEEEEEEAAAAAAAAAAbbbbbbbbbbCCCCCCCCCCdddddddddd
          ----+----1----+----2----+----3----+----4----+----5


:HEADER2 NUMCOLS  START-COL END-COL (START-NUM INCREMENT SKIP) (.A .B)
:HEADERT Place Sequential Numbers in Columns

       puts whole numbers in the specified columns, as in:

          NUMCOLS  1 5   20 5

       will put '   20' in the 1st line's columns 1 thru 5,
       '   25' in the 2nd line's, '   30' etc.  The starting and
       ending columns are mandatory.  The starting number,
       increment and number of lines to skip will default to 1.
       You must specify the starting number and increment if you
       wish to specify the number of lines to skip after the
       first line.


:HEADER2 NUMCOLS0   START-COL  END-COL START-NUM INCREMENT SKIP (.A .B)
:HEADERT Place Zero Padded Numbers in Columns

       puts 0 padded numbers in the specified columns, as in:

          NUMCOLS0  1 5  111  .aa .xx

       will put '00111' in the 1st line's columns 1 thru 5,
       '00112' in the 2nd line's, '00113' etc in the range of
       .AA through .XX.

       The starting and ending columns are mandatory.  The
       starting number, increment and number of lines to skip
       will default to 1. You must specify the starting number
       and increment if you wish to specify the number of lines
       to skip after the first line.

       A sample of its use would be in generating JCL to
       reference a Generation Data Group (GDG) backwards (i.e.
       we can't use the base or we only want part of them).
       Suppose there are 7 entries in a GDG base as follows:

          SYS4.TAMAST.REVISION.TRIAL7.G0029V00
          SYS4.TAMAST.REVISION.TRIAL7.G0030V00
          SYS4.TAMAST.REVISION.TRIAL7.G0031V00
          SYS4.TAMAST.REVISION.TRIAL7.G0032V00
          SYS4.TAMAST.REVISION.TRIAL7.G0033V00
          SYS4.TAMAST.REVISION.TRIAL7.G0034V00
          SYS4.TAMAST.REVISION.TRIAL7.G0035V00

      and we wanted JCL to reference the middle 5 backwards.  We
      could build:

         000001 //             DD       DISP=SHR,DCB=BUFNO=32,
         .A 002 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0000V00
         =COLS> ----+----1----+----2----+----3----+----4----+----5----+
         000003 //             DD       DISP=SHR,DCB=BUFNO=32,
         000004 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0000V00
         000005 //             DD       DISP=SHR,DCB=BUFNO=32,
         000006 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0000V00
         000007 //             DD       DISP=SHR,DCB=BUFNO=32,
         000008 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0000V00
         =COLS> ----+----1----+----2----+----3----+----4----+----5----+
         000009 //             DD       DISP=SHR,DCB=BUFNO=32,
         .B0010 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0000V00

      Please note where we set the label range - on the first
      line to get a number and on the last. Also we just
      specified the G00V00 number as zeros intending to overlay
      them.  The results of 'NUMCOLS0  50 52  34  -1  2  .A .B'
      would be:

         000001 //             DD       DISP=SHR,DCB=BUFNO=32,
         .A     //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0034V00
         =COLS> ----+----1----+----2----+----3----+----4----+----5----+
         000003 //             DD       DISP=SHR,DCB=BUFNO=32,
         000004 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0033V00
         000005 //             DD       DISP=SHR,DCB=BUFNO=32,
         000006 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0032V00
         000007 //             DD       DISP=SHR,DCB=BUFNO=32,
         000008 //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0031V00
         =COLS> ----+----1----+----2----+----3----+----4----+----5----+
         000009 //             DD       DISP=SHR,DCB=BUFNO=32,
         .B     //             DSN=SYS4.TAMAST.REVISION.TRIAL7.G0030V00


:HEADER2 PK FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2) (-MINUS-COL) (.A .B)
:HEADERT Pack Numeric Display Data

       packs the numbers in the specified columns, as in:

          PK   1 7  -8  31 34  .AA .XX

       will pack the data in columns 1 through 7 into columns 31
       through 34, placing the equivalent plus/minus from column
       8 in the sign portion of column 34.  The from columns are
       mandatory.  The to columns will default to the from
       columns, while the minus sign will default to the sign of
       the last from digit.

       Note that CAPS will be turned off and a message will be
+      _________________________________
       displayed saying so.

       A message showing the total valid numbers found, the
       number of overflows and the number of lines processed
       will appear in the upper right corner. Pressing PF1
       will describe the numbers shown

       PK may be used after FORMCOLS eliminates commas and aligns
       the data. DELCOLS may be used to remove periods after
       FORMCOLS is complete and before PK.

       Given the following data:

          00001
          FFFFF44444444
          0000100000000
          ----+----1---
          0000A
          FFFFC44444444
          0000100000000
          ----+----1---
          0000J
          FFFFD44444444
          0000100000000
          ----+----1---
          99999
          FFFFF44444444
          9999900000000
          ----+----1---
          9999R
          FFFFD44444444
          9999900000000

       the results of 'PK  1 5  11 13' would be:

          00001
          FFFFF44444001
          000010000000F
          ----+----1---
          0000A
          FFFFC44444001
          000010000000C
          ----+----1---
          0000J
          FFFFD44444001
          000010000000D
          ----+----1---
          99999     rr€
          FFFFF44444999
          999990000099F
          ----+----1---
          9999R     rr¸
          FFFFD44444999
          999990000099D


:HEADER2 RANCOLS   START-COL  END-COL  ( MIN-NUM  MAX-NUM )  ( .A .B )
:HEADERT Generate Pseudo Random Numbers

       puts pseudo random numbers into the specified columns,
       right justified and left padded with blanks, as in:

          RANCOLS  1  5  0  99

       may put '   21' in the 1st line's columns 1 thru 5, '
       95' in the 2nd line's, '   87' etc.  The defaults are
       minimum number of 1 and maximum number of all 9's.  The
       REXX RANDOM() function is used to generate the numbers.


:HEADER2 RANCOLS0   START-COL  END-COL  ( MIN-NUM  MAX-NUM )  ( .A .B )
:HEADERT Generate Zero Padded Pseudo Random Numbers

       puts 0 padded pseudo random numbers into the specified
       columns, right justified and left padded with zeros, as
       in:

          RANCOLS0  .AAA .BBB  1 5

       may put '01584' in the 1st line's columns 1 thru 5,
       '40089' in the 2nd line's, '24207' etc of the line
       range .AAA through .BBB.  The defaults are minimum
       number of 1 and maximum number of all 9's. The REXX
       RANDOM() function is used to generate the numbers.

       RANCOLS0 might be useful for generating random numeric
       data for testing or for filling columns used to do a
       repeatable random ordering.


:HEADER2 SHIFT  LEFT|RIGHT  (#COLUMNS)  (X|NX)  (.A .B)  (MAX|LEAVE)
:HEADERT Shift Data

       shifts the data left or right the number of columns
       specified, within the BOUNDS in force.  The direction of
       the shift is required and may be entered as LEFT or L, or
       RIGHT or R.

       The number of columns defaults to 1. The label range is
       optional. X or NX may be specified to have the shift
       impact only excluded or unexcluded lines, respectively.
       The default is all lines.

       MAX says to only cut off non blank columns; LEAVE says to
       not shift the line in question at all if any non blank
       data would be lost on that line.  The default is to
       truncate the data.

          SHIFT  LEFT  12  NX  .K .L

       will shift all the unexcluded lines in the line range .K
       through .L 12 columns to the left, within the current
       bounds.

       For example, given the following:

          =COLS> ----+----1----+----2
          .K       Length
          000003           Forth
          .L         Daily
          =COLS> ----+----1----+----2

       the result of 'SHIFT  LEFT  12  NX  .K .L' would be:

          =COLS> ----+----1----+----2
          .K
          000003 rth
          .L
          =COLS> ----+----1----+----2

       Note the above data (in the .K thru .L range) is truncated.
       And, given the same start data shown above, the result of
       'SHIFT  L  12  NX  .K .L MAX' would be:

          =COLS> ----+----1----+----2
          .K     Length
          000003 Forth
          .L     Daily
          =COLS> ----+----1----+----2

       Note the above data (in the .K thru .L range) is not
       truncated but shifted as far left as possible without
       losing any data.  And, finally, given the same start data
       shown above, the result of 'SHIFT  L  12  NX  .K .L LEAVE'
       would be:

          =COLS> ----+----1----+----2
          .K       Length
          000003           Forth
          .L         Daily
          =COLS> ----+----1----+----2

       Note nothing changed since a shift of 12 bytes leftwards
       would cause truncation in every instance.


:HEADER2 SPLTCOLS  COL-1  ( ... )  ( .A  .B )
:HEADERT Split Lines at Given Columns

      this macro will split a line at the given column intervals
      creating multiple lines from one.  For example

         SPLTCOLS  21  41  61

      will split one line into 4,  the 1st having columns 1
      through 20, the 2nd 21 through 40, the 3rd 41 through 60,
      and the 4th 61 through the end of the data.  Useful for
      breaking up columns into more editable data and in
      conjunction with JOINCOLS.

      Assuming the following data:

         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
         ----+----1----+----2----+----3----+----4----+----5----+----6
         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
         ----+----1----+----2----+----3----+----4----+----5----+----6
         AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE

      the result of 'SPLTCOLS  11  21  32  41' would be:

         AAAAAAAAAA
         bbbbbbbbbb
         CCCCCCCCCC
         dddddddddd
         EEEEEEEEEE
         ----+----1----+----2----+----3----+----4----+----5----+----6
         AAAAAAAAAA
         bbbbbbbbbb
         CCCCCCCCCC
         dddddddddd
         EEEEEEEEEE
         ----+----1----+----2----+----3----+----4----+----5----+----6
         AAAAAAAAAA
         bbbbbbbbbb
         CCCCCCCCCC
         dddddddddd
         EEEEEEEEEE

      Also, if faced with the need to break up unstructured data,
      for example:

         In theory, the product configuration baseline adds overriding
         performance constraints to the philosophy of commonality and
         standardization.   Similarly, the product assurance
         architecture adds explicit performance limits to the total
         system rationale.

      use TF2 on the prefix area for that line. It resulted in:

         In
         theory,
         the
         product
         configuration
         baseline
         adds
         overriding
         performance
         constraints
         to
         the
         philosophy
         of
         commonality
         and
         standardization.
         Similarly,
         the
         product
            ... etc ...


:HEADER2 SUMCOLS   1ST-COL 2ND-COL  ...  ( .A .B )
:HEADERT Add Data Arithmetically Within Given Columns

       will arithmetically add the numbers in the given columns.
       At least one pair of columns must be specified.  They
       don't have to be in the precise columns given.  For
       example:

          SUMCOLS  11 20

       where 11 thru 20 might contain:

          11       20
          +--------+
             1K
              123
           200.25
             -1
           2,345 +
          +--------+
          11       20

       will produce

          12:34:56 SUM of COLS  11-20, total is 2655.25
          12:34:56 --------------- Total of SUMS is  2655.25

       Note the lines with 1K and 2,345 (which are not pure
       numerics) are counted.  The 1K value is accepted as -12.
       Prefix or postfix signs are accepted.  Up to 9 pairs of
       columns may be specified.

       If no label range is specified, the macro will look for
       C/CC/C# prefix commands. If none are found, the entire
       file will be processed. Only unexcluded lines will be
       processed (for historical reasons).


:HEADER2 UNPK FROM-COL1 FROM-COL2 (TO-COL1 TO-COL2) (-MINUS-COL) (.A .B)
:HEADERT Unpack Data into Numeric Display Form

       unpacks the numbers in the specified columns, as in:

          UNPK  11 19  31 47  -30  .A .B

       will unpack the data in columns 11 through 19 into columns
       31 through 47, placing the appropriate plus/minus sign
       into column 30 in the line range .A through .B.  The from
       columns are mandatory.  The to columns will default to the
       from columns, while the minus sign location will default
       to the the last TO digit (zoned, that is, -1 equal to J,
       1 equal to A, -2 to K, 2 equal to B, etc).

       A message showing the total valid numbers found, the
       number of overflows and the number of lines processed
       will appear in the upper right corner. Pressing PF1
       will describe the values shown.

       FORMCOLS may be used to neatly format the resultant data
       and FILLINS to insert periods.

       Given the following data as the starting point:

                         î"
          4444444444000135744444444444444444444444
          0000000000000246F00000000000000000000000
          ----+----1----+----2----+----3----+----4
                          @
          4444444444000000744444444444444444444444
          0000000000000004C00000000000000000000000
          ----+----1----+----2----+----3----+----4

          4444444444000111144444444444444444444444
          0000000000000111D00000000000000000000000

       the result of 'UNPK  11 17  21 30  -31', immediately
       followed by 'UNPK  11 17  1 10' would be:

          0001234567     î"   0001234567+
          FFFFFFFFFF0001357444FFFFFFFFFF4444444444
          0001234567000246F0000001234567E000000000
          ----+----1----+----2----+----3----+----4
          0000000047      @   0000000047+
          FFFFFFFFFF0000007444FFFFFFFFFF4444444444
          0000000047000004C0000000000047E000000000
          ----+----1----+----2----+----3----+----4
          000111111J          0001111111-
          FFFFFFFFFD0001111444FFFFFFFFFF6444444444
          0001111111000111D00000011111110000000000


:HEADER1 Display Control Macros

 The following macros will expand both FIND and EXCLUDE/INCLUDE
 capabilities.  None will change the order or the content of the
+               ________________________________________________
 file.  Standard ISPF commands such as DEL ALL X or FLIP may be
+____
 used subsequently to delete or see the opposite lines
 respectively.

 FALT is a pseudo repeat capability for many of the below macros.
 Please see the macro below for full details.

 Built in help is available by either typing the macro name
 without any parameters (if any parameter is mandatory) or with
 just a question mark (?) as the only operand as shown below.


:HEADER2 COUNTXNX  ( ? )  ( .A .B )
:HEADERT Display Number of Unexcluded / Excluded Lines

       shows in the upper right hand corner of the screen the
       number of lines unexcluded and excluded. The lines to be
       processed may be selected via labels or C/CC/C# line
       commands - the entire file is processed if no range is
       specified. A single question mark causes the built in help
       to be displayed. Pressing function key <F1> will show a
       slightly more verbose explanation.

       A sample of the display shown is:

          ...           44 NX / 171 X LINES
          ...              Scroll ===> CSR
          ...         **********************

       A sample of the more readable message shown after <F1>
       is pressed for the preceding would be:

          THERE ARE 44 DISPLAYED LINES & 171 EXCLUDED LINES


:HEADER2 FALT  ( ? )
:HEADERT Pseudo Repeat Function for Certain Find's

       is a dummy macro.  As assigned to a PF Key, it will repeat
       the last FEXC, FGE, FGT, FLE, FLT, FMAX, FMIN, FN or FPEND
       command.  Those macros store parameter information in the
       shared pool. FALT passes a dummy parameter of -=PFK=- to
       the last command executed and the command will pull the
       necessary parameters from the shared pool. It always
       repeats the last of the above find commands.

       It will repeat the command starting from the line on which
       the cursor is positioned.


:HEADER2 FAND   STRING1  STRING2  ...  ( .A .B )
:HEADERT Display Lines With All Specified Values

       excludes all data within the line range or the file and
       unexcludes every line that contains every specified string.
       Up to 10 strings may be specified. For example:

          FAND  UNIT  SPACE=  ' DD '

       will show unexcluded only those lines which contain all
       the strings UNIT, SPACE= and ' DD '. The upper right
       hand side of the screen will show how many were found.


:HEADER2 FEXC  ( ? )
:HEADERT Find Next Excluded Line

       finds the next excluded line from the top line on the
       screen, and will make that excluded line the second from
       the top line.  FALT may be used to repeat the command.  A
       question mark (?) as parameter will cause the built in
       help to display.


:HEADER2 FGE    STRING   ( COL-1 ( COL-2 ) )   ( .A .B )
:HEADERT Find Value Greater Than or Equal

       will find the next line following the top line on the
       displayed page that has a value greater then or equal to
       the specified string. For instance,

          FGE  '231400'  16

       will make the line with a value greater then or equal to
       231400 in columns 16 through 21 the second line on the
       screen. If the value is not found, a not found message
       appeard in the upper right corner. To do a repeat, make
       the "found" line the top line on the screen and retrieve
       and re-execute the command or, if you set a PFKey to
       "FALT", that key may be used as a repeat FGE. Obviously,
       F17 might be a good choice since most PC's use Shift-F5
       for that key and F5 is normally the repeat find key.

       A FOUND or NOT FOUND message will be placed in the upper
       right corner of the screen, as appropriate.


:HEADER2 FGT    STRING   ( COL-1 ( COL-2 ) )   ( .A .B )
:HEADERT Find Value Greater Than

       will find the next line following the top line on the
       displayed page that has a value greater then the specified
       string. For instance,

          FGT  'Johnson'  21

       will make the line with a value greater then 'Johnson' in
       columns 21 through 27 the second line on the screen. If
       the value is not found, a not found message appeard in the
       upper right corner. To do a repeat, make the "found" line
       the top line on the screen and retrieve and re-execute the
       command or, if you set a PFKey to "FALT", that key may be
       used as a repeat FGT. Obviously, F17 might be a good
       choice since most PC's use Shift-F5 for that key and F5 is
       normally the repeat find key.

       A FOUND or NOT FOUND message will be placed in the upper
       right corner of the screen, as appropriate.


:HEADER2 FINDDUPX   COL1 COL2  ...  ( .A .B )
:HEADERT Display Contiguous Duplicate Lines

       will show only those lines with duplicate values in the
       specified columns where the lines follow each other.  No
+                                                            __
       sorting is done.  One pair of columns is mandatory; the
+      _______________
       label range is optional.  A sample is:

          FINDDUPX  1 8  11 12  .A .B

       will show only adjoining lines with the same values in
       columns 1 through 8  and 11 through 12 in line range .A
       through .B. Up to 10 sets of columns may be specified.
       See FINDDUPS for the version that will sort the data first
       by the specified columns.

       Given the following data:

          AAA
          AAA
          BBB
          CCC
          DDD
          DDD
          DDD
          EEE

       the result of 'FINDDUPX  1 3' would be:

          AAA
          AAA
          -  - ... -  2 Line(s) not Displayed
          DDD
          DDD
          DDD
          -  - ... -  1 Line(s) not Displayed

       Note doing a FLIP shows the records that have no dups,
       and no data or ordering is changed.


:HEADER2 FLE    STRING   ( COL-1 ( COL-2 ) )   ( .A .B )
:HEADERT Find Value Less Than or Equal

       will find the next line following the top line on the
       displayed page that has a value less then or equal to the
       specified string. For instance,

          FLE  '30,000'  31

       will make the line with a value less then or equal to
       '30,000' in column columns 31 through 36 the second line
       on the screen. If the value is not found, a not found
       message appeard in the upper right corner. To do a repeat,
       make the "found" line the top line on the screen and
       retrieve and re-execute the command or, if you set a PFKey
       to "FALT", that key may be used as a repeat FLE.
       Obviously, F17 might be a good choice since most PC's use
       Shift-F5 for that key and F5 is normally the repeat find
       key.

       A FOUND or NOT FOUND message will be placed in the upper
       right corner of the screen, as appropriate.


:HEADER2 FLT    STRING   ( COL-1 ( COL-2 ) )   ( .A .B )
:HEADERT Find Value Less Than

       will find the next line following the top line on the
       displayed page that has a value less then the specified
       string. For instance,

          FLT  '  '  1

       will make the line with a value less then '  ' (two
       blanks) in columns 1 and 2 the second line on the screen.
       If the value is not found, a not found message appeard in
       the upper right corner. To do a repeat, make the "found"
       line the top line on the screen and retrieve and
       re-execute the command or, if you set a PFKey to "FALT",
       that key may be used as a repeat FLT. Obviously, F17 might
       be a good choice since most PC's use Shift-F5 for that key
       and F5 is normally the repeat find key.

       A FOUND or NOT FOUND message will be placed in the upper
       right corner of the screen, as appropriate.


:HEADER2 FMAX  LEFT-COL RIGHT-COL  ( TYPE )  ( .A .B )
:HEADERT Find the Largest Value

       will find the first line in the range with the highest
       value.  Columns are mandatory but data type and label
       range are optional.

       The data type (TYPE) defaults to 'C' for character, which
       includes both any character string or signed character
       strings (e.g. +277, 012 or -935). Other types are 'Z' for
       zoned data (e.g. 27G, 012 or 93N), 'P' for packed (COMP-3)
       (recognizing hex D for negative and assuming everything
       else is positive), and 'B' for binary (using the first bit
       for the sign and the rest for 2's complement number if
       negative).

       FALT may be invoked to repeat the find if there are
       multiple high values. The count of the largest value
       found and the number of values scanned is shown in the
       upper right corner as #found/#scanned. A not found message
       will be shown there when all of the largest values are
       exhausted.

          FMAX  P  11 15

       will find the largest packed value in columns 11 through
       15.


:HEADER2 FMIN  LEFT-COL RIGHT-COL  ( TYPE )  ( .A .B )
:HEADERT Find the Smallest Value

       will find the first line in the range with the lowest
       value.  Columns are mandatory but data type and label
       range are optional.

       The data type (TYPE) defaults to 'C' for character, which
       includes both any character string or signed character
       strings (e.g. +277, 012 or -935). Other types are 'Z' for
       zoned data (e.g. 27G, 012 or 93N), 'P' for packed (COMP-3)
       (recognizing hex D for negative and assuming everything
       else is positive), and 'B' for binary (using the first bit
       for the sign and the rest for 2's complement number if
       negative).

       FALT may be invoked to repeat the find if there are
       multiple low values. The count of the smallest value
       found and the number of values scanned is shown in the
       upper right corner as #found/#scanned. A not found message
       will be shown there when all of the smallest values are
       exhausted.

          FMIN  .X .Y  1 23

       will find the smallest value in columns 1 through 23
       within the line range .X through .Y.


:HEADER2 FN    STRING   ( COL-1 ( COL-2 ) )   ( .A .B )
:HEADERT Find a Value Not Equal

       will find the next line that does not contain the
       specified string anywhere in the specified columns.  For
       example:

          FN  ' DD '  2 20  .XX .YY

       will find the next line that does not contain ' DD '
       between columns 2 through 20. Another example, probably
       more realistic, is:

          FN  '747'  16

       which will find the next line that does not contain 747 in
       column2 16 through 18.

       If you set a PFKey to "FALT", that key may be used
       as a repeat FN. Obviously, F17 might be a good choice
       since most PC's use Shift-F5 for that key and F5 is
       normally the repeat find key.

       When at the end of the file, FN will "wrap" to the top of
       the file. If no line is found to satisy the 'not equal'
       condition, a 'NOT FOUND' appears in the upper right hand
       corner of the screen.


:HEADER2 FNB  ( STARTING-COLUMN  ( ENDING-COLUMN ) )  ( ? )
:HEADERT Find Non Blank Values

      finds the non blank character, if any, from column 73
      through the last logical byte of data, by default. If the
      STARTING-COLUMN is specified, it will use that value as the
      beginning column through the last logical byte or through
      the ENDING-COLUMN if specified. The standard repeat
      function key (usually PF Key 5) may be used to continue the
      function.

      For example,

         FNB  47

      will find the first non blank character from column 47
      through the logical record length (LRECL) if any.


:HEADER2 FNOT   STRING1  ...  ( .A .B )
:HEADERT Display Lines With None of Specified Values

       excludes all data within the line range or the file and
       unexcludes every line that does not contain any of the
       specified strings.  Up to 10 strings may be specified. For
       example:

          FNOT  PROC  ' DD '  PEND

       will show unexcluded only those lines which contain
       neither PROC, ' DD ', nor PEND. This relates to both the
       FAND and FOR macros.


:HEADER2 FOR    STRING1  ...  ( .A .B )
:HEADERT Display Lines With Any of Specified Values

       excludes all data within the line range or the file and
       unexcludes every line that contains any of the specified
       strings.  Up to 10 strings may be specified. For example:

          FOR  2314  3350  CART  TAPE

       will show unexcluded only those lines which contain either
       '2314', '3350', CART or TAPE.


:HEADER2 FPEND  ( Next | First | Previous | ? )
:HEADERT Find Line With Pending Prefix Command

       will find a pending line command in the file, i.e.  the
       line that has an unexecuted prefix command such as CC or
       M9999. The direction may be abbreviated as only the first
       character, e.g. F. The default is to find the next pending
       line command.  Specifying a question mark (?) as the
       parameter will cause the built in help to be displayed.

       If you set a PFKey to "FALT", that key may be used as a
       repeat FPEND. Obviously, F17 might be a good choice since
       most PC's use Shift-F5 for that key and F5 is normally the
       repeat find key. If the last direction was First, then the
       Next pending command is found.


:HEADER2 FX     STRING1
:HEADERT Exclude Everything and Show Only those Lines Found

       excludes all lines and shows only lines with the string
       and a few lines above and below those found.  This uses
       the COMPARE EXCLUDE command to perform the line exclude
       function (type COMPARE in Edit).

       For example, given the following data:

          DDD
          BBB
          AAA
          EEE
          CCC
          FFF
          DDD
          DDD
          ZZZ
          AAA
          CCC

       the result of 'FX  CCC' would be:

          -  -  ...  -  3 Line(s) not Displayed
          EEE
          CCC
          FFF
          -  -  ...  -  3 Line(s) not Displayed
          AAA
          CCC

       where the Display Options with Exclude (Compare command)
       is set to 1.


:HEADER2 LESS    ( BEFORE(#) )   ( AFTER(#) )   ( .A .B )  ( ? )
:HEADERT Exclude Additional Lines Around Excluded Lines

       excludes the number of lines specified by BEFORE(#) in
       front of any currently excluded lines and the number of
       lines specified by AFTER(#) following any currently
       excluded lines in the selected range.  A range to be
       processed may be specified via a label range as parameters
       or a C/CC/C# range by data prefix.  The entire file will
       be processed if no explicit range is selected.  The
       defaults are BEFORE(1) and AFTER(1).  Given:

          LESS

       will cause one line before of each group of excluded lines
       to be excluded and one line following each group to be
       excluded.  This is equivalent to typing a prefix command
       of 'X' on the unexcluded lines immediately before and
       after each excluded group of lines.  Another example is:

          LESS  BEFORE(0)  AFTER(2)  .KK .LL

       which will exclude no lines before any group of excluded
       lines and 2 lines following of each group in the line
       range .KK through .LL.

       A parameter of ? causes the built in help to be displayed.

       Given data (from the FX example above):

          -  -  ...  -  3 Line(s) not Displayed
          EEE
          CCC
          FFF
          -  -  ...  -  3 Line(s) not Displayed
          AAA
          CCC

       The result of 'LESS' would be:

          -  -  -  4 Line(s) not Displayed
          CCC
          -  -  -  5 Line(s) not Displayed
          CCC


:HEADER2 LONGEST   ( .A .B )  ( ? )
:HEADERT Find the Longest Line

       makes the first line with the longest length the top line
       on the display.  The actual length is shown in the upper
       right message area as well as the number of such length
       records in the range.

       For fixed record format data, the longest record has the
       smallest number of blanks on the right side of the line.

       Either labels or C/CC/C# may be used to limit the length
       check.  A ? as the only parameter will cause the built in
       help to be displayed.


:HEADER2 MORE    ( BEFORE(#) )   ( AFTER(#) )   ( .A .B )  ( ? )
:HEADERT Unexclude Additional Lines Around Excluded Lines

       unexcludes the number of lines specified by BEFORE(#) at
       the beginning of any currently excluded lines and the
       number of lines specified by AFTER(#) at the end of any
       currently excluded lines within the range selected.  The
       range may be specified via a label range as parameters or
       a C/CC/C# data prefix selection. The entire file will be
       processed if no range is specifically selected.  The
       defaults are BEFORE(1) and AFTER(1).  For example,

          MORE

       will cause one line at the beginning of each group of
       excluded lines to be unexcluded and one line following
       each group will be unexcluded.  Another example is:

          MORE  BEFORE(2)  AFTER(2)

       which will unexclude two lines at the beginning of any
       group of excluded lines and 2 lines at the end of each
       group.

       A parameter of ? causes the built in help to be displayed.
       Given data (from the FX example above):

          -  -  ...  -  3 Line(s) not Displayed
          EEE
          CCC
          FFF
          -  -  ...  -  3 Line(s) not Displayed
          AAA
          CCC

       The result of 'MORE' would be:

          DDD
          -  -  -  -  1 Line(s) not Displayed
          AAA
          EEE
          CCC
          FFF
          DDD
          -  -  -  -  1 Line(s) not Displayed
          ZZZ
          AAA
          CCC


:HEADER2 REALUNIX  COL1 COL2  ...  ( .A .B )
:HEADERT Show Contiguous Lines With No Duplicate Values

       will exclude the specified range of lines or the entire
       file and unexclude the records with no other contiguous
       records with the same values in the specified columns.  No
       sorting is performed before checking for unique values.
       For example:

          REALUNIX  1  8

       will scan the file by columns 1 thru 8 and show only the
       really unique records.  Up to 10 pairs of columns are
       supported.  Please see REALUNIQ for a version that sorts
       prior to processing.  For example, given data as follows:

          111
          222
          222
          333
          444
          444
          444
          555
          555
          555

       doing a REALUNIQ 1 3 will result in:

          111
          -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed
          333
          -  -  -  -  -  -  -  -  -  -  -  6 Line(s) not Displayed

       Please note the data is assumed to be in proper order, And
       see REALUNIQ for the equivalent function that performs a
       sort before processing the data.  Using the standard FLIP
       command will produce those lines that are duplicated, i.e.
       on the above

          -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed
          222
          222
          -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed
          444
          444
          444
          555
          555
          555


:HEADER2 SHORTEST   ( .A .B )  ( ? )
:HEADERT Find the Shortest Line

       makes the first line with the smallest length the top line
       on the display.  The actual length is shown in the upper
       right message area as well as the number of records of
       such size in the range.

       For fixed record format data, the shortest record has the
       largest number of blanks on the right side of the line.

       Either labels or C/CC/C# may be used to limit the length
       check; will process the entire file if neither is
       specified.  Obviously most useful for variable length
       files. A ? will cause the built in help to be displayed.


:HEADER2 SNACK   ( ? )
:HEADERT Display Only Lines Containing the Field the Cursor is On

       does an X ALL and then a FIND ALL against the field the
       cursor was on.  The field must be delimited by blanks or
       at the start or end of a line with a blank toward the
       inside of the data.  Ideally, this macro would be assigned
       to a PF Key.

       For  the following:

           FD  O
               RECORDING MODE IS F
               BLOCK CONTAINS 0 RECORDS.
           01  OUTPUT-REC   PIC X(00080).

           WORKING-STORAGE SECTION.
          *------------------------*

           01  WS-INPUT-REC                 PIC X(00080).
           01  WS-SAVE-REC                  PIC X(00080).

       if the cursor were positioned on OUTPUT-REC, the resulting
       screen might look like:

          -  -  -  -  -  -  -  -  -  -  -  - 60 Line(s) not Displayed
           01  OUTPUT-REC   PIC X(00080).
          -  -  -  -  -  -  -  -  -  -  -  - 72 Line(s) not Displayed
                   WRITE OUTPUT-REC FROM WS-INPUT-REC
          -  -  -  -  -  -  -  -  -  -  -  - 11 Line(s) not Displayed
                   WRITE OUTPUT-REC FROM WS-INPUT-REC
          -  -  -  -  -  -  -  -  -  -  -  - 60 Line(s) not Displayed

       If the macro is specified on the command line with only a
       question mark (?) as its parameter, built in help is
       displayed.


:HEADER2 UNIQUEX   COL1 COL2  ...  ( .A .B )
:HEADERT Show Contiguous Uniquely Valued Lines

       will exclude the specified range of lines or the entire
       file and unexclude the first (or only) record with unique
       values in the specified columns of contiguous records.  No
       sorting is performed before checking for unique values.
       For example:

          UNIQUEX  1  8

       will scan the file by columns 1 thru 8 and show only the
       first occurrence of each value in those columns. Up to 10
       pairs of columns are supported. Data should be in proper
       order by the columns specified. Please also see UNIQUE
       which sorts the data first.

       For example, given the following data:

          DDDDDD
          BBBBBB
          AAAAAA
          EEEEEE
          CCCCCC
          DDDDDD
          DDDDDD
          DDDDDD
          DDDDDD
          AAAAAA
          CCCCCC

       invoking 'UNIQUE  1 10' will result in:

          DDDDDD
          BBBBBB
          AAAAAA
          EEEEEE
          CCCCCC
          DDDDDD
          -  -  -  -      3 Line(s) not Displayed
          AAAAAA
          CCCCCC


:HEADER1 Line Manipulation Macros

 The following macros will change the file being Viewed or
 Edited, removing blank lines, eliminating duplicate lines,
 showing only duplicate records, showing only unique records, and
 pulling all excluded lines to the top of the file.

 Data will be changed, as opposed to display format commands.
+____________________

 Built in help is available by either typing the macro name
 without any parameters (for those with mandatory parameters) or
 with just a question mark (?) as the only operand.


:HEADER2 CONBLANK   ( ? )  ( .A .B )
:HEADERT Consolidate Blank Lines

       will consolidate 2 or more blank lines to 1 within the
       file or within the label range specified.  For example,

          CONBLANK

       will every occurrence of two or more blank lines in the
       file to be consolidated to one.  If ? is specified as the
       first or only parameter, then the inline help is displayed
       without doing any deletions.


:HEADER2 DELBLANK   ( ? )  ( .A .B )
:HEADERT Delete Blank Lines

       will delete all blank lines from the file or from the
       label range specified.  For example,

          DELBLANK

       will cause every blank line in the file to be deleted.  If
       ? is specified as the first or only parameter, then the
       inline help is displayed without doing any deletions.


:HEADER2 DELDUPS   COL1 COL2  ...  ( .A .B )
:HEADERT Sort and Delete All Duplicate Lines

       will sort the selected data, if range labels are
       specified, or the entire file by the specified columns and
       delete all lines with duplicate values in the specified
       columns after the first occurrence.  For example,

          DELDUPS  21 27  1 3

       will sort the file by columns 21 thru 27 and 1 thru 3 and
       delete any duplicate occurrences, i.e.  where the complete
       set of keys is the same.  Up to 10 pairs of columns are
       supported.

       Given the following data:

          DDDDDD    4444
          ----+----1----+----2
          DDDDDD    4444
          EEEEEE    5555
          CCCCCC    3333
          BBBBBB    2222
          DDDDDD    4444
          AAAAAA    1111
          DDDDDD    4444
          AAAAAA    1111
          DDDDDD    4444
          ----+----1----+----2
          CCCCCC    3333

       the result of 'DELDUPS  11 14  1 6' would be:

          AAAAAA    1111
          ----+----1----+----2
          BBBBBB    2222
          CCCCCC    3333
          DDDDDD    4444
          ----+----1----+----2
          EEEEEE    5555

       Please note the data is now in order by the columns
       specified and there are no duplicate entries left.


:HEADER2 DELDUPX    COL1 COL2  ...  ( .A .B )
:HEADERT Delete Contiguous Duplicate Lines

       will scan, without sorting, the entire file using the
       specified columns and delete all lines with duplicate
       values in the specified columns after the first
       occurrence.  For example,

          DELDUPX  11 17  1 3

       will scan the file by columns 11 thru 17 and 1 thru 3 and
       delete any duplicate occurrences.  Up to 10 pairs of
       columns are supported.

       If the following data is the starting point:

          =COLS> ----+----1
          .AA    BBBBBB
          000004 CCCCCC
          000005 CCCCCC
          000006 DDDDDD
          000007 DDDDDD
          000008 DDDDDD
          .BB    DDDDDD
          =COLS> ----+----1

       the result of 'DELDUPX  1 6  .AA .BB' would be:

          =COLS> ----+----1
          .AA    BBBBBB
          000004 CCCCCC
          000005 DDDDDD
          =COLS> ----+----1


:HEADER2 FINDDUPS   COL1 COL2  ...  ( .A .B )
:HEADERT Display All Duplicate Lines

       will sort the entire file, or the range selected lines, by
       the specified columns and exclude any lines that are not
       duplicates. The shown data lines will only be dups. For
       example:

          FINDDUPS  11 17  1 3

       will sort the file by columns 11 thru 17 and 1 thru
       3 and show only the lines with dup values in those
       columns. Up to 10 pairs of columns are supported.
       The label range is optional.

       Given the following data:

          DDDDDD
          BBBBBB
          AAAAAA
          EEEEEE
          CCCCCC
          DDDDDD
          DDDDDD
          DDDDDD
          DDDDDD
          AAAAAA
          CCCCCC

       a 'FINDDUPS  1 10' will have as its result:

          AAAAAA
          AAAAAA
          -  -  -  - ... -  1 Line(s) not Displayed
          CCCCCC
          CCCCCC
          DDDDDD
          DDDDDD
          DDDDDD
          DDDDDD
          DDDDDD
          -  -  -  - ... -  1 Line(s) not Displayed

       Please note the data is sorted, the "unique" BBBBBB and
       EEEEEE lines are excluded while all the duplicate data is
       shown.  FLIP would obviously return the unique values as
       shown and the duplicates as excluded.


:HEADER2 GATHERX  ( ? )
:HEADERT Collect All Excluded Lines

       will cause all excluded lines to be brought to the top of
       the file or to the top of the lines marked by C/CC/C#.  If
       there are none, nothing is changed.  The excluded and
       unexcluded lines are kept in the same order respectively.

       So if the initial file contained:

          AAA
          -  -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed
          BBB
          -  -  -  -  -  -  -  -  -  -  -  -  3 Line(s) not Displayed
          CCC
          -  -  -  -  -  -  -  -  -  -  -  -  4 Line(s) not Displayed

       The file, after GATHERX is executed, would look like:

          -  -  -  -  -  -  -  -  -  -  -  -  9 Line(s) not Displayed
          AAA
          BBB
          CCC

       The nine excluded lines would be in the same order as
       originally seen, just all moved to the top of the file.

       If a question mark (?) is specified as the parameter, the
       inline help is displayed without moving any lines.


:HEADER2 REALUNIQ  COL1 COL2  ...  ( .A .B )
:HEADERT Sort and Show Lines With No Duplicate Values

       will sort and exclude the specified range of lines or the
       entire file and unexclude the records which no other
       records with the same values in the specified columns.
       For example:

          REALUNIQ  1  8

       will sort the file by columns 1 thru 8 and show only the
       really unique records.  Up to 10 pairs of columns are
       supported.  Please see REALUNIX for a version that does
       not sort prior prior to processing.  For example, given
       data as follows (note these are NOT in sorted order):

          444
          555
          555
          333
          111
          555
          444
          222
          222
          444

       doing a REALUNIQ 1 3 will result in:

          111
          -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed
          333
          -  -  -  -  -  -  -  -  -  -  -  6 Line(s) not Displayed

       Using the standard FLIP command will produce those lines
       that are duplicated, i.e. on the above

          -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed
          222
          222
          -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed
          444
          444
          444
          555
          555
          555


:HEADER2 REVERSEX  ( ? )
:HEADERT Reverse Lines

       will cause the marked (via C/CC/C##) range of lines to be
       reversed.  If no range is specified, the entire file is
       reversed.  This is essentially a "flip" command for the
       lines involved. A question mark (?) as parameter will
       cause the built in help to be displayed.

       For example, using REVERSEX on

           AAAAAA
           BBBBBB
           CCCCCC
           DDDDDD
           EEEEEE

       would result in:

           EEEEEE
           DDDDDD
           CCCCCC
           BBBBBB
           AAAAAA


:HEADER2 SHUFFLE  ( ? )
:HEADERT Provide Random Line Re-arrangement

      pseudo randomly rearranges the sequence of an entire file
      or of some subset specified by C, CC or C## prefix
      commands. The only possible parameter is a question mark
      which will cause the built in help to be displayed.

      Uses the REXX random number generator to determine a new
      position for each line selected. This is useful for
      testing when the order of input might be of consequence.

      If a question mark (?) is specified as the parameter, the
      inline help is displayed without moving any lines.  Please
      see RANCOLS0 which would allow repeatable sorting for
      consistent testing.

       For example, using SHUFFLE on

           AAAAAA
           BBBBBB
           CCCCCC
           DDDDDD
           EEEEEE

       could result in:

           BBBBBB
           CCCCCC
           AAAAAA
           DDDDDD
           EEEEEE


:HEADER2 SORTNX   COL1 COL2  ...  ( .A .B )
:HEADERT Sort Unexcluded Lines Keeping With Excluded Lines

       will sort the selected data by the specified columns of
       the non excluded records keeping the excluded records
       following each sorted record with that record. That is:

          SORTNX  1 12

       will sort the following records

          rec#5555
          --- some excluded lines associated with rec#5555 ---
          rec#9999
          --- some excluded lines associated with rec#9999 ---
          rec#4444
          rec#0000
          --- some excluded lines associated with rec#0000 ---

       producing

          rec#0000
          --- some excluded lines associated with rec#0000 ---
          rec#4444
          rec#5555
          --- some excluded lines associated with rec#5555 ---
          rec#9999
          --- some excluded lines associated with rec#9999 ---

       So the excluded records "stick to" their immediately
       preceding non excluded records.  Up to 10 pairs of columns
       are supported. The label range is optional.


:HEADER2 UNIQUE   COL1 COL2  ...  ( .A .B )
:HEADERT Show All Uniquely Valued Lines

       will sort the selected data by the specified columns,
       exclude the range selected or the entire file, and
       unexclude the first (or only) record with unique values in
       the specified columns.  The first pair of columns are
       mandatory.

       For example:

          UNIQUE  1  8

       will sort the file by columns 1 thru 8 and show only the
       first occurrence of each value in those columns. Up to 10
       pairs of columns are supported. Please see UNIQUEX if no
       sort is needed.

       For example, given the following data:

          DDDDDD
          BBBBBB
          AAAAAA
          EEEEEE
          CCCCCC
          DDDDDD
          DDDDDD
          DDDDDD
          DDDDDD
          AAAAAA
          CCCCCC

       invoking 'UNIQUE  1 10' would result in:

          AAAAAA
          -  -  -  - ... -  1 Line(s) not Displayed
          BBBBBB
          CCCCCC
          -  -  -  - ... -  1 Line(s) not Displayed
          DDDDDD
          -  -  -  - ... -  4 Line(s) not Displayed
          EEEEEE


:HEADER1 Code/Data Manipulation Macros

 The following macros are primarily intended for use in coding.
 Some, such as ALIGN or SPLITAFT, may be useful elsewhere.


:HEADER2 ALIGN  ( CHARS | ? )
:HEADERT Align Text at Character(s) Specified

       aligns the text at the right most character(s) specified.
       It will only process C/C#/CC selected lines or the whole
       file if no range is specified.  For example:

          ALIGN  'PIC 9(9)'

       used on the following lines:

          01  WORK-AREAS.
              05  NUMBER-RECORDS-ADDED PIC 9(9)  VALUE 0 COMP-3.
              05  NUMBER-RECORDS-DELETED PIC 9(9)  VALUE 0 COMP-3.
              05  NUMBER-RECORDS-DUPS PIC 9(9)  VALUE 0 COMP-3.
              05  NUMBER-RECORDS-READ PIC 9(9)  VALUE 0 COMP-3.
              05  NUMBER-RECORDS-UPDATED PIC 9(9)  VALUE 0 COMP-3.
              05  NUMBER-RECORDS-WRITTEN PIC 9(9)  VALUE 0 COMP-3.
              05  FINAL-RETURN-CODE PIC 9(4)  VALUE 0 COMP.

       will result in:

          01  WORK-AREAS.
              05  NUMBER-RECORDS-ADDED   PIC 9(9) VALUE 0 COMP-3.
              05  NUMBER-RECORDS-DELETED PIC 9(9) VALUE 0 COMP-3.
              05  NUMBER-RECORDS-DUPS    PIC 9(9) VALUE 0 COMP-3.
              05  NUMBER-RECORDS-READ    PIC 9(9) VALUE 0 COMP-3.
              05  NUMBER-RECORDS-UPDATED PIC 9(9) VALUE 0 COMP-3.
              05  NUMBER-RECORDS-WRITTEN PIC 9(9) VALUE 0 COMP-3.
              05  FINAL-RETURN-CODE PIC 9(4)  VALUE 0 COMP.

       Note the first and last lines are not reformatted since
       they do not contain the specified character(s).  Quotes,
       either single or double, are only necessary if blanks or
       oddball special characters are contained.  No arguments or
       a single question mark will cause built in help to be
       displayed.

       COBOL comment and debug lines will not be re-aligned!
+      _____________________________________________________
       Please see ALIGNS below for a more compact alignment.


:HEADER2 ALIGNALL  CHARS
:HEADERT Align All Text at Character(s) Specified

       aligns the fields of the records selected at the
       character(s) specified based on the maximum size of each
       field in that range.  No argument specified will cause
       built in help to be displayed.  It will only process
       C/C#/CC selected lines or the whole file if no range is
       specified.  For example:

          ALIGNALL  !

       used on the following lines:

          aaa!aaa!aaa!aaa
          b!b!b!b
          ccccc!cc!cccccccc!c
          dddd!dddd!dddd!dddd

       will result in:

          aaa  !aaa !aaa     !aaa
          b    !b   !b       !b
          ccccc!cc  !cccccccc!c
          dddd !dddd!dddd    !dddd

       Note that every field has been expanded to the maximum
       size needed to hold that field, e.g. the 3rd field now
       is 8 characters to hold the 8 c's in the 3rd record and
       the 2nd field is 4 bytes to hold the 4 d's in the last
       record.

       Please see ALIGN above, and ALIGNAX AND ALIGNS below for
       variations on the alignment concept.


:HEADER2 ALIGNAX  CHARS
:HEADERT Align All Text at Character(s) Specified Removing Delimiter

       aligns the fields of the records selected at the
       character(s) specified based on the maximum size of each
       field in that range, removing the delimiter.  No argument
       specified will cause built in help to be displayed.  It
       will only process C/C#/CC selected lines or the whole file
       if no range is specified.  For example:

          ALIGNAX  !

       used on the following lines:

          aaa!aaa!aaa!aaa
          b!b!b!b
          ccccc!cc!cccccccc!c
          dddd!dddd!dddd!dddd

       will result in:

          aaa  aaa aaa     aaa
          b    b   b       b
          ccccccc  ccccccccc
          dddd dddddddd    dddd

       Note that every field has been expanded to the maximum
       size needed to hold that field, e.g. the 3rd field now
       is 8 characters to hold the 8 c's in the 3rd record and
       the 2nd field is 4 bytes to hold the 4 d's in the last
       record.

       Please see ALIGN and ALIGNALL above and ALIGNS below for
       variations on the alignment concept.  This is basically
       the same macro as ALIGNALL with the difference that the
       delimiter is removed.


:HEADER2 ALIGNS  ( CHARS | ? )
:HEADERT Align Text at Character(s) Specified Minimizing Blanks

       aligns the text at the right most character(s) specified
       with minimal spacing.  It will only process C/C#/CC
       selected lines or the whole file if no range is specified.
       For example:

          ALIGNS  'PIC 9(9)'

       used on the following lines:

          01  WORK-AREAS.
              05  NUMBER-RECORDS-ADDED PIC 9(9)  VALUE 0 COMP-3.
              05  NUMBER-RECORDS-DELETED PIC 9(9)  VALUE 0 COMP-3.
              05  NUMBER-RECORDS-DUPS       PIC 9(9)  VALUE 0 COMP-3.
              05  NUMBER-RECORDS-READ  PIC 9(9)  VALUE 0 COMP-3.
              05  NUMBER-RECORDS-UPDATED PIC 9(9)  VALUE 0 COMP-3.
              05  NUMBER-RECORDS-WRITTEN    PIC 9(9)  VALUE 0 COMP-3.
              05  FINAL-RETURN-CODE PIC 9(4)  VALUE 0 COMP.

       will result in:

          01  WORK-AREAS.
              05  NUMBER-RECORDS-ADDED   PIC 9(9) VALUE 0 COMP-3.
              05  NUMBER-RECORDS-DELETED PIC 9(9) VALUE 0 COMP-3.
              05  NUMBER-RECORDS-DUPS    PIC 9(9) VALUE 0 COMP-3.
              05  NUMBER-RECORDS-READ    PIC 9(9) VALUE 0 COMP-3.
              05  NUMBER-RECORDS-UPDATED PIC 9(9) VALUE 0 COMP-3.
              05  NUMBER-RECORDS-WRITTEN PIC 9(9) VALUE 0 COMP-3.
              05  FINAL-RETURN-CODE PIC 9(4)  VALUE 0 COMP.

       Note the first and last lines are not reformatted and only
       one blank is used to separate the chosen characters from
       the preceding text.  Quotes, either single or double, are
       only necessary if blanks or oddball special characters are
       contained.  No arguments or a single question mark will
       cause built in help to be displayed.

       COBOL comment and debug lines will not be re-aligned!
+      _____________________________________________________
       Please see ALIGN above for a slightly different variation
       on separation.


:HEADER2 BC   ( LEFT-COL  RIGHT-COL )  ( .A .B )
:HEADERT Blank Selected Columns

       will place blanks in the selected columns. LEFT-COL and
       RIGHT-COL default to 73 and 80. C/CC/C# or labels may be
       used to select the lines impacted.  If no range is
       specified, the entire file is processed.

          BC

       will cause columns 73 through 80 of every line to be
       blanked. A question mark (?) as the first operand will
       cause inline help to be displayed.


:HEADER2 COBCOLO  ( ? )
:HEADERT Put COBOL Offsets in Columns 73 to 80

      invokes FileAid (COBCOLOF) or InSync (COBCOLOI) programs to
      determine the offsets for COBOL data structures and places
      them in columns 73 through 80 as ZZZ9-ZZ9. The starting
      position goes from 1 to 9999 while the ending position will
      only show the last 3 digits. The C/C#/CC prefix commands
      may be used to limit the columns processed.

      This is the old version of COBCOLS which uses all 8
      positions to show the offsets. Please see its documentation
      below.

      The question mark will cause the built in help to be
      displayed.

      An example is:

       01 REQ-FRM-REQUEST.                                   1- 48
           05 REQ-CCS-KEY.                                   1- 48
               10 REQ-CCS-CALLER          PIC X(01).         1-  1
      *        10 REQ-CCS-CUST-NO         PIC X(18).
               10 REQ-CCS-CUST-NO         PIC X(20).         2- 21
               10 REQ-CCS-GROUP           PIC X(03).        22- 24
               10 REQ-CCS-SUBGROUP        PIC X(15).        25- 39
               10 REQ-CCS-TIME            PIC 9(13) COMP-3. 40- 46
               10 REQ-CCS-TIME-X                            40- 46
                  REDEFINES REQ-CCS-TIME  PIC X(07).
               10 REQ-CCS-SEQ             PIC 9(02).        47- 48

      Note that the commented statement is ignored.

      A limitation on this command is that array sub-structures
      are not processed. Please see COBCOLV below for a variant
      which will show those offsets.


:HEADER2 COBCOLS  ( ? )
:HEADERT Put COBOL Offsets in Columns 73 to 80

      invokes FileAid (COBCOLSF) or InSync (COBCOLSI version) to
      determine the offsets for COBOL data structures and places
      them in columns 73 through 80 as ZZZ9ZZZ9. The starting and
      ending positions run from 1 through 9999.  The C/C#/CC
      prefix commands may be used to limit the columns processed.

      This is the new version of COBCOLO which used less then 4
      positions to show the offsets. Please see its documentation
      above. Also see COBCOLV below.

      The question mark will cause the built in help to be
      displayed but will not invoke the code.

      An example is:

       01 REQ-FRM-REQUEST.                                    1  48
           05 REQ-CCS-KEY.                                    1  48
               10 REQ-CCS-CALLER          PIC X(01).          1   1
      *        10 REQ-CCS-CUST-NO         PIC X(18).
               10 REQ-CCS-CUST-NO         PIC X(20).          2  21
               10 REQ-CCS-GROUP           PIC X(03).         22  24
               10 REQ-CCS-SUBGROUP        PIC X(15).         25  39
               10 REQ-CCS-TIME            PIC 9(13) COMP-3.  40  46
               10 REQ-CCS-TIME-X                             40  46
                  REDEFINES REQ-CCS-TIME  PIC X(07).
               10 REQ-CCS-SEQ             PIC 9(02).         47  48

      Note that the commented statement is ignored.

      A limitation on this command is that array sub-structures
      are not processed. Please see COBCOLV below for a variant
      which will show those offsets.


:HEADER2 COBCOLV  ( ? )
:HEADERT View FileAid/InSync Layout of COBOL Data Structure

      invokes FileAid (COBCOLVF) or InSync (COBCOLVI) to generate
      a record layout and then View that output in a separate
      session.  The C/C#/CC prefix commands may be used to limit
      the columns processed.

      This is a variant of the COBCOLO and COBCOLS macros above
      without the array sub-structure limitation.

      The question mark will cause the built in help to be
      displayed but will not invoke the code.

      A sample input for which COBCOLVF was invoked follows:

       01 REQ-FRM-REQUEST.
           05 REQ-CCS-KEY.
               10 REQ-CCS-CALLER          PIC X(01).
      *        10 REQ-CCS-CUST-NO         PIC X(18).
               10 REQ-CCS-CUST-NO         PIC X(20).
               10 REQ-CCS-GROUP           PIC X(03).
               10 REQ-CCS-SUBGROUP        PIC X(15).
               10 REQ-CCS-TIME            PIC 9(13) COMP-3.
               10 REQ-CCS-TIME-X
                  REDEFINES REQ-CCS-TIME  PIC X(07).
               10 REQ-CCS-SEQ             PIC 9(02).
               10 REQ-ARRAY  OCCURS 5 TIMES.
                   15 REQ-CCS-REP         PIC X(03).
                   15 REQ-CCS-REP-STAT    PIC 9(01).
               10                         PIC X(12).

      And the resultant output, for the InSync version, slightly
      truncated to fit here, looks like:

         01  REQ-FRM-REQUEST                 G            1     80
           05  REQ-CCS-KEY                   G            1     80
             10  REQ-CCS-CALLER              C    1       1      1
             10  REQ-CCS-CUST-NO             C   20       2     20
             10  REQ-CCS-GROUP               C    3      22      3
             10  REQ-CCS-SUBGROUP            C   15      25     15
             10  REQ-CCS-TIME                P   13      40      7
             10  REQ-CCS-TIME-X              C    7      40      7
                     REDEFINES REQ-CCS-TIME
             10  REQ-CCS-SEQ                 Z    2      47      2
             10  REQ-ARRAY(1)                G           49      4
                     OCCURS     5 TIMES
               15  REQ-CCS-REP(1)            C    3      49      3
               15  REQ-CCS-REP-STAT(1)       Z    1      52      1
             10  REQ-ARRAY(2)                G           53      4
               15  REQ-CCS-REP(2)            C    3      53      3
               15  REQ-CCS-REP-STAT(2)       Z    1      56      1
             10  REQ-ARRAY(3)                G           57      4
               15  REQ-CCS-REP(3)            C    3      57      3
               15  REQ-CCS-REP-STAT(3)       Z    1      60      1
             10  REQ-ARRAY(4)                G           61      4
               15  REQ-CCS-REP(4)            C    3      61      3
               15  REQ-CCS-REP-STAT(4)       Z    1      64      1
             10  REQ-ARRAY(5)                G           65      4
               15  REQ-CCS-REP(5)            C    3      65      3
               15  REQ-CCS-REP-STAT(5)       Z    1      68      1
             10  FILLER                      C   12      69     12

      Note the data types, starting position, ending position
      and length shown for a non commented data items.

      The above example shows the expanded array layout.


:HEADER2 DELPARA
:HEADERT Deletes COBOL DISPLAY Statements from DISPARA & DISPVAR

       will delete all DISPLAY statements inserted by DISPARA
       and DISPVAR in COBOL code.  For example:

          DELPARA

       will delete DISPLAY '~DEBUG~ 0100-INITIALIZATION. ' which
       had been inserted by DISPARA immediately after paragraph
       0100-INITIALIZATION. Please see DISPARA and DISPVAR below.


:HEADER2 DISPARA
:HEADERT Insert COBOL DISPLAY at Each Paragraph

       will insert a DISPLAY statement after each paragraph in
       COBOL code.  For example:

          DISPARA

       will insert DISPLAY '~DEBUG~ 0100-INITIALIZATION'
       immediately after paragraph 0100-INITIALIZATION.  The
       DELPARA command will remove all the inserted lines.
       Please see DELPARA above.

       If the code contains exit paragraphs of the form

           0100-INITIALIZATION-EXIT.  EXIT.

       DISPARA will split the line leaving the EXIT. on the
       second line and then add the DISPLAY line after the
       paragraph name line.  So the result from the above would
       be:

           0100-INITIALIZATION-EXIT.
               DISPLAY '~DEBUG~ 0100-INITIALIZATION'
                                      EXIT.


:HEADER2 DISPVAR
:HEADERT Insert a DISPLAY for the Variable at the Cursor

       inserts a DISPLAY statement for the variable with the
       cursor on it.  For example if invoked with the cursor
       anywhere on NUMBER-RECORDS-READ, the next two lines will
       be inserted:

               NOT AT END ADD 1 TO NUMBER-RECORDS-READ
           DISPLAY '~DEBUG~ NUMBER-RECORDS-READ = >'
             NUMBER-RECORDS-READ '< ~DEBUG~'

       Note all lines generated contain ~DEBUG~ so DELPARA may be
       used to delete them when no longer necessary.  Variables
       named like WS-DATA (12) (2:5) will work just fine.  If there
       are spaces within or outside the parentheses in the
       subscript and/or reference modification, DISPVAR will
       handle it appropriately but the cursor MUST be positioned
+                                             ____
       on the name, i.e. WS-DATA in WS-DATA ( 12 ) ( 2 : 5 ).

       IN or OF constructs are also handled even if on the line
       below where the cursor is positioned. For example, if the
       cursor is on WS-SECURITY-NUMBER in the following:

           ADD WS-INCR TO WS-SEC-NUMBER
               OF WS-INPUT-RECORD ( ITEM - 3 )

       the resultant code would be:

           ADD WS-INCR TO WS-SEC-NUMBER
               OF WS-INPUT-RECORD ( ITEM - 3 )
           DISPLAY '~DEBUG~ WS-SEC-NUMBER OF WS-INPUT-RECORD (* = >'
             WS-SEC-NUMBER OF WS-INPUT-RECORD ( ITEM - 3 ) '< ~DEBUG~'

       Note extra blanks are removed and the generated code
       starts in column 12. This keeps the inserted number of
       lines to a minimum. Please note the truncation of
       extremely long names above.

       DISPVAR is probably best utilized from a function key,
       <F22> is suggested.


:HEADER2 IE  ( Indent )
:HEADERT Adds a COBOL EVALUATE Structure Following the Cursor

       inserts the following code immediately after the line on
       which the cursor is positioned. It will line up with
       the previous line, making that line the top line on
       the screen and placing the cursor on the first leader
       dots (...).

          EVALUATE ...
              WHEN ...
                  ...
              WHEN ...
                  ...
              WHEN OTHER
                  ...
          END-EVALUATE

       The indentation may be specified but defaults to 4.  The
       inserted statements are indented that value if the
       preceding statement can be identified as an IF, ELSE or
       PERFORM.


:HEADER2 II  ( Indent )
:HEADERT Adds a COBOL IF Structure Following the Cursor

       inserts the following code immediately after the line on
       which the cursor is positioned. It will line up with
       the previous line, making that line the top line on
       the screen and placing the cursor on the first leader
       dots (...).

          IF
              ...
          ELSE
              ...
          END-IF

       The indentation may be specified but defaults to 4.  The
       inserted statements are indented that value if the
       preceding statement can be identified as an IF, ELSE or
       PERFORM.


:HEADER2 IP  ( Indent )
:HEADERT Adds a COBOL PERFORM Structure Following the Cursor

       inserts the following code immediately after the line on
       which the cursor is positioned. It will line up with
       the previous line, making that line the top line on
       the screen and placing the cursor on the first leader
       dots (...).

          PERFORM
              VARYING ... FROM 1 BY 1
                  UNTIL ...
              ...
          END-PERFORM

       The indentation may be specified but defaults to 4.  The
       inserted statements are indented that value if the
       preceding statement can be identified as an IF, ELSE or
       PERFORM.


:HEADER2 IS  ( Indent )
:HEADERT Adds a COBOL SEARCH Structure Following the Cursor

       inserts the following code immediately after the line on
       which the cursor is positioned. It will line up with
       the previous line, making that line the top line on
       the screen and placing the cursor on the first leader
       dots (...).

          SET ... TO 1
          SEARCH ...
              AT END
                  ...
              WHEN ...
                  ...
          END-SEARCH

       The indentation may be specified but defaults to 4.  The
       inserted statements are indented that value if the
       preceding statement can be identified as an IF, ELSE or
       PERFORM.


:HEADER2 ISA  ( Indent )
:HEADERT Adds a COBOL SEARCH ALL Structure Following the Cursor

       inserts the following code immediately after the line on
       which the cursor is positioned. It will line up with
       the previous line, making that line the top line on
       the screen and placing the cursor on the first leader
       dots (...).

          SEARCH ALL ...
              AT END
                  ...
              WHEN ...
                  ...
          END-SEARCH

       The indentation may be specified but defaults to 4.  The
       inserted statements are indented that value if the
       preceding statement can be identified as an IF, ELSE or
       PERFORM.


:HEADER2 IST  ( Indent )
:HEADERT Adds a COBOL STRING Structure Following the Cursor

       inserts the following code immediately after the line on
       which the cursor is positioned. It will line up with
       the previous line, making that line the top line on
       the screen and placing the cursor on the first leader
       dots (...).

          STRING
              ...
              ...
              ...
                  DELIMITED BY SIZE
              INTO ...
          END-STRING

       The indentation may be specified but defaults to 4.  The
       inserted statements are indented that value if the
       preceding statement can be identified as an IF, ELSE or
       PERFORM.


:HEADER2 JB     ( ? )
:HEADERT Jump Back to PERFORM Statement

       will place the display back at the COBOL PERFORM statement
       where the JT command was invoked. Please see the JT
       command description below. A question mark (?) supplied as
       the only parameter will cause built in help to be
       displayed. JB uses labels to position itself.

       It is strongly suggested that this macro be assigned
       to a PF Key, e.g. assign %JB to PF 19 (pseudo back).


:HEADER2 JT     ( ? )
:HEADERT Jump to PERFORMed Paragraph or View Copybook

       determines the paragraph specified in a COBOL PERFORM on
       the line where the cursor is positioned and changes the
       code displayed to the start of that paragraph.  The JB
       command is used in conjunction to return to the previous
       PERFORM statement. Please see the description of JB above.

       If the cursor is on a line with a COPY, the macro will
       View the copybook in a site's hard coded copybook library
       (defaulted to -YOUR-COPYLIB-1- through -YOUR-COPYLIB-4-).

       A question mark (?)  supplied as the only parameter will
       cause built in help to be displayed.

       It is strongly suggested that this macro be assigned to a
       PF Key, e.g. assign %JT to PF 20 (pseudo forward).


:HEADER2 SPLITAFT  STRING  ( INDENT )
:HEADERT Split Lines After the String Specified

      will split the specified lines after the string provided. A
+                                    _____
      range of lines may be specified by C/CC/C## or the entire
      file will be processed.  Quotes may be used around the
      string.  INDENT must be a whole number; otherwise it
      defaults to 4. COBOL comments ('*' or '/' in column 7) or
      COBOL debug lines ('D' in column 7) will be ignored

      For example, if SPLITAFT THRU 7 is run against:

               PERFORM 100-INIT-PARA    THRU   999-INIT-EXIT
               PERFORM 200-PROC-PARA    THRU   999-PROC-EXIT
               PERFORM 900-QUIT-PARA    THRU   999-QUIT-EXIT

      the following will result:

               PERFORM 100-INIT-PARA    THRU
                      999-INIT-EXIT
               PERFORM 200-PROC-PARA    THRU
                      999-PROC-EXIT
               PERFORM 900-QUIT-PARA    THRU
                      999-QUIT-EXIT

      If no parameters are specified, built-in help will
      be displayed. Please also see SPLITAT below.


:HEADER2 SPLITAT  STRING  ( INDENT )
:HEADERT Split Lines On a Specified String

      will split the specified lines at the string provided. A
+                                    __
      range of lines may be specified by C/CC/C## or the entire
      file will be processed.  Quotes may be used around the
      string.  INDENT must be a whole number; otherwise it
      defaults to 4. COBOL comments ('*' or '/' in column 7) or
      COBOL debug lines ('D' in column 7) will be ignored.

      For example, if SPLITAT ' TO ' is run against:

               MOVE  WS-LEADER-DOTS     TO     OUT-NAME0
               MOVE  WS-FIRST-NAME      TO   OUT-NAME1
               MOVE  WS-MIDDLE-INIT        TO   OUT-NAME2
               MOVE  WS-LAST-NAME       TO   OUT-NAME3
               MOVE  WS-TRAILER-DOTS      TO   OUT-NAME9

      the following will result:

               MOVE  WS-LEADER-DOTS
                    TO     OUT-NAME0
               MOVE  WS-FIRST-NAME
                    TO   OUT-NAME1
               MOVE  WS-MIDDLE-INIT
                    TO   OUT-NAME2
               MOVE  WS-LAST-NAME
                    TO   OUT-NAME3
               MOVE  WS-TRAILER-DOTS
                    TO   OUT-NAME9

      Note the indentation of 4 blanks is placed before the
      string, ' TO ', resulting in 5 blanks.  If no parameters
      are specified, built-in help will be displayed. Please
      also see SPLITAFT above.


:HEADER2 STRUCT   Language  ( .A .B )
:HEADERT Show Significant Structural Code Elements

       excludes everything and then unexcludes any lines that
       have structural constructs for the specified language such
       as IF, ELSE, or PROC.  The languages specified are COB or
       COBOL for COBOL; EZ for Easytrieve; PL1, PLI, PL/1 or PL/I
       for PL/I; or REX or REXX for REXX.  Comments in COBOL and
       Easytrieve will be left excluded.  Similarly, all JCL (//
       in column 1) will also be left excluded.  For example,

          STRUCT  COB

       will show the logical structure of the edited COBOL
       program. A label range may be specified.

       For example, given the following:

       IDENTIFICATION DIVISION.
       PROGRAM-ID.  BASE INITIAL.
       CONFIGURATION SECTION.
       SPECIAL-NAMES.
           CLASS ALPHA-CHARS
               IS 'A' THRU 'Z', '0' THRU '9', ' ', '.'.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT I
               ASSIGN TO I.
           SELECT O
               ASSIGN TO O.
       DATA DIVISION.
       FILE SECTION.
       FD  I
           RECORDING MODE IS F
           BLOCK CONTAINS 0 RECORDS.
       01  INPUT-REC    PIC X(00080).
       FD  O
           RECORDING MODE IS F
           BLOCK CONTAINS 0 RECORDS.
       01  OUTPUT-REC   PIC X(00080).
       WORKING-STORAGE SECTION.
       01  WS-INPUT-REC                 PIC X(00080).
       01  WS-SAVE-REC                  PIC X(00080).
       01  WORK-AREAS.
           05  NUMBER-RECORDS-ADDED     PIC 9(9)      VALUE 0 COMP-3.
           05  NUMBER-RECORDS-DELETED   PIC 9(9)      VALUE 0 COMP-3.
           05  NUMBER-RECORDS-DUPS      PIC 9(9)      VALUE 0 COMP-3.
           05  NUMBER-RECORDS-READ      PIC 9(9)      VALUE 0 COMP-3.
           05  NUMBER-RECORDS-UPDATED   PIC 9(9)      VALUE 0 COMP-3.
           05  NUMBER-RECORDS-WRITTEN   PIC 9(9)      VALUE 0 COMP-3.
           05  FINAL-RETURN-CODE        PIC 9(4)      VALUE 0 COMP.
           05  END-OF-FILE-STATUS       PIC X         VALUE 'N'.
               88  AT-END-OF-FILE                     VALUE 'Y'.
           05  REWRITE-REC              PIC X         VALUE 'Y'.
       01  WEEK-DAY-NUMBER              PIC 9.
       01  YYMMDD                       PIC 9(6).
       01  HHMM                         PIC 9(8).
       01  DAYS-OF-WEEK.
           05  MONDAY    PIC X(9)       VALUE 'MONDAY'.
           05  TUESDAY   PIC X(9)       VALUE 'TUESDAY'.
           05  WEDNESDAY PIC X(9)       VALUE 'WEDNESDAY'.
           05  THURSDAY  PIC X(9)       VALUE 'THURSDAY'.
           05  FRIDAY    PIC X(9)       VALUE 'FRIDAY'.
           05  SATURDAY  PIC X(9)       VALUE 'SATURDAY'.
           05  SUNDAY    PIC X(9)       VALUE 'SUNDAY'.
       01  WEEK-DAYS                    REDEFINES DAYS-OF-WEEK.
           05 WEEK-DAY   OCCURS 7 TIMES PIC X(9).
       LINKAGE SECTION.
       01  PARM-DATA.
           05  PARM-LENGTH              PIC 9(4)              COMP.
           05  PARM-PASSED              PIC X(100).
       PROCEDURE DIVISION USING PARM-DATA.
       0000-MAIN.
           PERFORM 0100-INITIALIZATION
           PERFORM 0200-READ-WRITE-LOOP
               UNTIL AT-END-OF-FILE
           PERFORM 0900-TERMINATION
           MOVE FINAL-RETURN-CODE TO RETURN-CODE
           GOBACK
           .
       0100-INITIALIZATION.
           OPEN  INPUT  I
                 OUTPUT O
           READ  I INTO WS-INPUT-REC
               AT END SET AT-END-OF-FILE TO TRUE
               NOT AT END ADD 1 TO NUMBER-RECORDS-READ
           END-READ
           .
       0200-READ-WRITE-LOOP.
           MOVE 'Y' TO REWRITE-REC
           PERFORM 0200-PROCESS
           IF REWRITE-REC = 'Y'
               WRITE OUTPUT-REC FROM WS-INPUT-REC
               ADD 1 TO NUMBER-RECORDS-WRITTEN
           ELSE
               ADD 1 TO NUMBER-RECORDS-DELETED
           END-IF
           READ  I INTO WS-INPUT-REC
               AT END SET AT-END-OF-FILE TO TRUE
               NOT AT END ADD 1 TO NUMBER-RECORDS-READ
           END-READ
           .
       0200-PROCESS.
           CONTINUE
           .
       0900-TERMINATION.
           CLOSE I
                 O
           ACCEPT WEEK-DAY-NUMBER FROM DAY-OF-WEEK
           ACCEPT YYMMDD FROM DATE
           ACCEPT HHMM FROM TIME
           DISPLAY 'PROGRAM STATISTICS:  '
               '                         '
               WEEK-DAY(WEEK-DAY-NUMBER) ' '
               YYMMDD '-' HHMM(1:2) ':' HHMM(3:2)
           DISPLAY '    PARM LENGTH               = '
               PARM-LENGTH
           IF PARM-LENGTH NOT = 0
               DISPLAY '    PARM PASSED TO PROGRAM    = '
                   PARM-PASSED(1:PARM-LENGTH)
           END-IF
           DISPLAY ' '
           DISPLAY '    NUMBER OF RECORDS READ    = '
               NUMBER-RECORDS-READ
           DISPLAY '    NUMBER OF RECORDS WRITTEN = '
               NUMBER-RECORDS-WRITTEN
           DISPLAY '    NUMBER OF RECORDS UPDATED = '
               NUMBER-RECORDS-UPDATED
           DISPLAY '    NUMBER OF RECORDS DELETED = '
               NUMBER-RECORDS-DELETED
           DISPLAY '    NUMBER OF RECORDS ADDED   = '
               NUMBER-RECORDS-ADDED
           DISPLAY '    NUMBER OF DUPLICATE RECS  = '
               NUMBER-RECORDS-DUPS
           .

       The following would be displayed:

             PROCEDURE DIVISION USING PARM-DATA.
               -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed
                 PERFORM 0100-INITIALIZATION
                 PERFORM 0200-READ-WRITE-LOOP
                     UNTIL AT-END-OF-FILE
                 PERFORM 0900-TERMINATION
               -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed
                 GOBACK
               -  -  -  -  -  -  -  -  -  -  - 11 Line(s) not Displayed
                 PERFORM 0200-PROCESS
                 IF REWRITE-REC = 'Y'
               -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed
                 ELSE
               -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed
                 END-IF
               -  -  -  -  -  -  -  -  -  -  - 20 Line(s) not Displayed
                 IF PARM-LENGTH NOT = 0
               -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed
                 END-IF
               -  -  -  -  -  -  -  -  -  -  1457 Line(s) not Displayed


:HEADER2 SUFFLINE  STRING  ( ? )
:HEADERT Append a String to the End of Selected Line(s)

       will append the specified string to the end of every line
       selected via C/CC/C# range selection or to every line in
       the file. Blank lines will be left unchanged.

       The words COMMA, APOST and QUOTE may be used to append
       , or ' or " respectively. For example,

          SUFFLINE  )

       will cause the following lines

          MOVE 0      TO  FAR-TBL(SUB1
          MOVE 0      TO  NEAR-TABLE(VAR11A
          MOVE 0      TO  SOME-ARRAY-NAME(11 23
          MOVE 0      TO  EASY(1

       to become

          MOVE 0      TO  FAR-TBL(SUB1)
          MOVE 0      TO  NEAR-TABLE(VAR11A)
          MOVE 0      TO  SOME-ARRAY-NAME(11 23)
          MOVE 0      TO  EASY(1)

       SUFFLINE could be used to suffix an odd character, say !,
       on which a C '!' '...' ALL could be executed for
       simplicity.

       If a question mark (?) is specified as the parameter, the
       inline help is displayed without moving any lines.


:HEADER2 XINDENT  ( ? )
:HEADERT Exclude to Similarly Indented Line

      based on IBM freeware, has been revamped to specifically
      handle COBOL code, ignoring comments and junk in columns 1
      through 6.  Most useful when assigned to a PF Key.

      The general concept is to place the cursor anywhere on a
      line and have the code excluded to the corresponding start
      or end line of that construct.

      if the first non blank after column 7 is an 'IF', the lines
      downward to the next similarly indented ELSE or END-IF will
      be excluded.  If placed on an 'END-IF' line, it will
      exclude upwards to a preceding 'ELSE' or 'IF'. If placed on
      an 'ELSE' line, it will check to see if the preceding line
      is excluded already and, if so, will exclude downwards to
      the next similarly indented 'IF'. If not, it will exclude
      downwards to an 'END-IF'.

      If the cursor is positioned on a PERFORM, the scan proceeds
      downwards to the similarly indented END-PERFORM. If on an
      END-PERFORM, it scans upwards for a PERFORM.

      If the cursor is positioned on a EVALUATE, the scan proceeds
      downwards to the similarly indented END-EVALUATE. If on an
      END-EVALUATE, it scans upwards for a EVALUATE.

      A parameter of a question mark (?) will cause the built in
      help to be displayed.

      So if the cursor were placed anywhere on the line with the
      'IF' in the following text, and XINDENT invoked,

           IF REWRITE-REC = 'Y'
               WRITE OUTPUT-REC FROM WS-INPUT-REC
               ADD 1 TO NUMBER-RECORDS-WRITTEN
           ELSE
               ADD 1 TO NUMBER-RECORDS-DELETED
           END-IF

      The following would be displayed:

          IF REWRITE-REC = 'Y'
           -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed
          ELSE
              ADD 1 TO NUMBER-RECORDS-DELETED
          END-IF

      If the cursor were now to be placed on the 'END-IF' or
      'ELSE' line:

          IF REWRITE-REC = 'Y'
           -  -  -  -  -  -  -  -  -  -  -  -  2 Line(s) not Displayed
          ELSE
           -  -  -  -  -  -  -  -  -  -  -  -  1 Line(s) not Displayed
          END-IF

      would result. Obviously, the various constructs must line
      up, i.e. the indentation must be the same.  While this
      demands some precision, the benefits of using XINDENT as
      well as having consistent code are well worth the cost.


:HEADER1 JCL Manipulation Macros

 These macros are useful with JCL, either adding lines or
 reformatting them.


:HEADER2 CU  ( ###  |  ? )
:HEADERT Add Clean Up IEFBR14 JCL after Cursor Position

      will add an IEFBR14 step after the line on which the cursor
      is positioned with ### MOD/DELETE DD cards with ###
      defaulting to 1.  A solitary question mark will cause built
      in help to display.  At the end, the cursor will be placed
      on the first set of dots.

      For example, CU 4 will insert the following immediately
      after the cursor:

      //***
      //***
      //CLEANUP    EXEC     PGM=IEFBR14
      //DEL001       DD       DSN=...,
      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)
      //DEL002       DD       DSN=...,
      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)
      //DEL003       DD       DSN=...,
      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)
      //DEL004       DD       DSN=...,
      //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)

      Please see CUD below for dynamically generated delete
      images.


:HEADER2 CUD  ( ? )
:HEADERT Dynamically Add Clean Up IEFBR14 JCL after Cursor

      will add IEFBR14 step after where the cursor is positioned
      for every NEW CATLG data set in the file.  C/CC/C# may be
      used to limit the search for new data sets to only those
      lines.  A solitary question mark will cause built in help
      to display.  At the end, the cursor will be placed where it
      was initially positioned.

      For example, given the following somewhere in the searched
      area of the file:

      //CREATION   EXEC     PGM=SOMEPGM
      //FILE01       DD       DSN=SYS4.LIMITED.DATA,DISP=(NEW,CATLG),
      //             UNIT=SYSDA,SPACE=(CYL,10)
      //XX       DD       DISP=(,CATLG),
      //          UNIT=TESTPK,
      //          VOL=SER=TP0037,
      //          DCB=(RECFM=VBS,BLKSIZE=27998),
      //          DSNAME=YOURID.SOME.DATA.SET.NAME
      //         DD       DISP=(,CATLG),DSN=YOURID.VBSFILE,
      //          UNIT=SYSDA,SPACE=(TRK,(1000,1000),RLSE)
         ... some other irrelevant lines ...
      //             DD       DISP=(NEW,CATLG,DELETE),
      //             UNIT=SYSDA,
      //             SPACE=(CYL,5),
      //             DSN=YOURID.RUBBER.DUCKY,
      //             DCB=BLKSIZE=0

      CUD will insert the following lines after the line where
      the cursor is positioned:

      //***
      //***
      //CLEANUP  EXEC  PGM=IEFBR14
      //DEL001           DSN=SYS4.LIMITED.DATA,
      //           DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)
      //DEL002           DSN=YOURID.SOME.DATA.SET.NAME,
      //           DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)
      //DEL003           DSN=YOURID.VBSFILE,
      //           DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)
      //DEL004           DSN=YOURID.RUBBER.DUCKY,
      //           DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)

      CUD has a problem with JCL where certain parts were left as
      comments, e.g. leaving DISP=SHR on the end of the
      DISP=(,CATLG) line. Clean JCL is good JCL!


:HEADER2 CHDEL ( ? )
:HEADERT Dynamically Add HDELETE JCL after Cursor

      will add an HDELETE command after where the cursor is
      positioned for every NEW CATLG data set in the file.
      C/CC/C# may be used to limit the search for new data sets
      to only those lines.  A solitary question mark will cause
      built in help to display.  At the end, the cursor will be
      placed where it was initially positioned.

      Including this in the JCL stream before clean up JCL
      (IEFBR14 MOD DELETE's) will greatly reduce recall time.

      For example, given the following somewhere in the searched
      area of the file:

      //CREATION   EXEC     PGM=SOMEPGM
      //FILE01       DD       DSN=SYS4.LIMITED.DATA,DISP=(NEW,CATLG),
      //             UNIT=SYSDA,SPACE=(CYL,10)
      //XX       DD       DISP=(,CATLG),
      //          UNIT=TESTPK,
      //          VOL=SER=TP0037,
      //          DCB=(RECFM=VBS,BLKSIZE=27998),
      //          DSNAME=YOURID.SOME.DATA.SET.NAME
      //         DD       DISP=(,CATLG),DSN=YOURID.VBSFILE,
      //          UNIT=SYSDA,SPACE=(TRK,(1000,1000),RLSE)
         ... some other irrelevant lines ...
      //             DD       DISP=(NEW,CATLG,DELETE),
      //             UNIT=SYSDA,
      //             SPACE=(CYL,5),
      //             DSN=YOURID.RUBBER.DUCKY,
      //             DCB=BLKSIZE=0

      CHDEL will insert the following lines after the line where
      the cursor is positioned:

      //***
      //BATCHTSO   EXEC     PGM=IKJEFT01,REGION=4M,DYNAMNBR=32
      //SYSTSIN      DD       *
        HDEL  'SYS4.LIMITED.DATA'
        HDEL  'YOURID.SOME.DATA.SET.NAME'
        HDEL  'YOURID.VBSFILE'
        HDEL  'YOURID.RUBBER.DUCKY'
        CALL  *(IEFBR14)
      //SYSTSPRT     DD       SYSOUT=*
      //***

      If the dataset does not exist, a NOT IN CATALOG message
      is issued from HDELETE; if the dataset is not migrated,
      a DATA SET NOT MIGRATED is issued; if the dataset does
      exist and the request is queued, a message showing
      DELETE REQUEST 00031371 SENT TO DFSMSHSM is shown.


:HEADER2 DISPDSN  ( ? )
:HEADERT Place DSN Value after DISP=SHR

       forces DSN=...,DISP=SHR into the reverse format, namely
       DISP=SHR,DSN=...; this macro uses FAND to assure both DISP
       and DSN are present. Useful for getting data set names to
       the end of the line, making it easy to cut and paste. For
       example, the following:

          //XX  DD  DSN=SYS1.USERLIB,DISP=SHR
          //    DD  DSN=SYS2.USERLIB,DISP=SHR
          //YY  DD  DSN=SYS1.MACLIB,DISP=SHR

       would be changed to:

          //XX  DD  DISP=SHR,DSN=SYS1.USERLIB
          //    DD  DISP=SHR,DSN=SYS2.USERLIB
          //YY  DD  DISP=SHR,DSN=SYS1.MACLIB

       Please see NEATJCL below for additional formatting.


:HEADER2 GETDSNS  ( Wild-Card-String | ? )  ( STATS | DD )
:HEADERT Paste a List of Cataloged Data Sets after Cursor

      pulls a list of the data sets matching the wildcard string
      and pastes the list after the line after where the cursor
      is positioned. For example,

         GETDSNS  SYS2.SAS.**.TEMP

      might show (starting each line in column 1):

         SYS2.SAS.ELGREQ.V1R1.CLIDVSAM.TEST
         SYS2.SAS.ELGREQ.V1R1.CUSTOMER.TEST
         SYS2.SAS.ELGREQ.V1R1.DATA.TEST
                   ...

      The STATS option will append the volume serial and number
      of tracks for non-migrated data sets with a total. The DD
      option will cause DD card images to be generated, for
      example:

         GETDSNS  SYS1.AOC  DD

      might cause:

         //             DD       DISP=SHR,
         //             DSN=SYS1.AOC.SEVEINST
         //             DD       DISP=SHR,
         //             DSN=SYS1.AOC.SEVEMOD1
         //             DD       DISP=SHR,
         //             DSN=SYS1.AOC.SEVEMOD2
                   ...

      Note the data set name is placed on a second line and no
      DD name is on the very first DD card image.

      A ? as the only argument or no arguments at all causes the
      internal help to be displayed.


:HEADER2 GETGDGS  ( Base-GDG-String | ? )  ( STATS | DD )
:HEADERT Paste a List of Cataloged GDG Names after Cursor

      pulls a list of the data sets matching the base Generation
      Data Group string and pastes the list on the line after
      where the cursor is positioned.  For example,

         GETGDGS  SOMEUSER.HIGH.LEVEL.GDG.ENTRY

      might show (starting each line in column 1):

         SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0007V00
         SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0008V00
         SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0009V00
                   ...

      The STATS option will append the volume serial and number
      of tracks for non-migrated data sets with a total. The DD
      option will cause DD card images to be generated, for
      example:

         GETGDGS  SOMEUSER.HIGH.LEVEL.GDG.ENTRY  DD

      might cause:

         //             DD       DISP=SHR,
         //             DSN=SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0007V00
         //             DD       DISP=SHR,
         //             DSN=SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0008V00
         //             DD       DISP=SHR,
         //             DSN=SOMEUSER.HIGH.LEVEL.GDG.ENTRY.G0009V00
                   ...

      Note the data set name is placed on a second line and no
      DD name is on the very first DD card image. Also, they are
      generated in oldest first order.

      A ? as the only argument or no arguments at all causes the
      internal help to be displayed.


:HEADER2 GETMEMS  Data-Set-Name
:HEADERT Retrieve List of Member Names after the Cursor

      pulls a list of all or a selected set of member names from
      a given Data-Set-Name and places them after where the cursor
      is positioned. A wild card of * may be used to do selection,
      for example, GETMEMS 'SYS1.MACLIB(GET*)' would retrieve
      only those member names that started with GET.

         GETMEMS  SOME.PDS.UNDER.YOUR.USERID

      might show (starting each line in column 1):

         ABENDX
         ABENDX$
         ADDCC
         ADDCC$
         ADDFLAG
         ADDLINEA
         ADDLINEB
         ADDLINES
                   ...

      A ? as the only argument or no arguments at all causes the
      internal help to be displayed.


:HEADER2 ISORT
:HEADERT Insert a Sort Step Immediately After the Cursor Position

      inserts a full sort step after where the cursor is
      positioned in the file and places the cursor on the first
      set of dots. If the following was the displayed screen of
      file data and the cursor was anywhere on the second line,

         //SYSOUT       DD       SYSOUT=*
         //***                       <=== Cursor anywhere here ...
         //***
         //ADDHDTLR   EXEC     EZTPCG,REGION=2M
         //INFILE       DD       DISP=SHR,DSN=USERID.INPUT.WOHDRTLR
         //OUTFILE      DD       DSN=USERID.OUTPUT.WHDRTLR,
         //             DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,
         //             SPACE=(CYL,(12,12),RLSE),
         //             DCB=(RECFM=FB,LRECL=1234)
         //STEPLIB      DD
         //             DD       DISP=SHR,DSN=USERID.LOADLIB

      the result of invoking ISORT would be:

         //SYSOUT       DD       SYSOUT=*
         //***                       <=== Cursor anywhere here ...
         //***
         //SORT        EXEC     PGM=SORT,REGION=256M
         //SORTIN       DD       DISP=SHR,DSN=...<=== Cursor here now...
         //SORTOUT      DD       DISP=(,CATLG),UNIT=SYSDA,
         //             SPACE=(CYL,(0010,0010),RLSE),
         //             DSN=...,
         //             DCB=(...)
         //SYSIN        DD       *
            SORT    FIELDS=(0001,0001,CH,A)
              INCLUDE  COND=(....,....,CH,EQ,C'...',OR,
                             ....,....,CH,EQ,C'...')
            SUM     FIELDS=NONE
         //SYSPRINT     DD       SYSOUT=*
         //SORTLIST     DD       SYSOUT=*
         //SYSOUT       DD       SYSOUT=*
         //SORTWK01     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))
         //SORTWK02     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))
         //SORTWK03     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))
         //SORTWK04     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))
         //SORTWK05     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))
         //SORTWK06     DD       UNIT=SYSDA,SPACE=(CYL,(050,050))
         //***
         //***
         //ADDHDTLR   EXEC     EZTPCG,REGION=2M
         //INFILE       DD       DISP=SHR,DSN=USERID.INPUT.WOHDRTLR
         //OUTFILE      DD       DSN=USERID.OUTPUT.WHDRTLR,
         //             DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,
         //             SPACE=(CYL,(12,12),RLSE),
         //             DCB=(RECFM=FB,LRECL=1234)
         //STEPLIB      DD
         //             DD       DISP=SHR,DSN=USERID.LOADLIB


:HEADER2 JC  ( ? )
:HEADERT Insert a Job Card at the Top of the File Being Edited

      inserts a job card as shown below with a separator comment
      line. The job name, the descriptive user information, and
      the NOTIFY are set to the TSO user ID. The user ID is also
      placed within the name information.

         //User-ID    JOB      (ACCT-INFO),'User-ID',
         //             CLASS=2,MSGCLASS=X,NOTIFY=User-ID
         //***

      No suffix character is generated but the cursor will be
      positioned there on completion.  A question mark (?) as the
      only argument causes the internal help to be displayed.


:HEADER2 NEATJCL  ( ? )
:HEADERT Neaten JCL

       will cause JCL within the marked (via C/CC/C##) range of
       lines to be formatted.  If no range is specified, the
       entire file is processed.  The block operations, like EXEC
       or PROC, are placed in column 14, other operations like DD
       in column 16.  Operands are shifted to column 25 unless
       there's no operation present, when they're placed in
       column 16.

       Comments (//*), terminators (/*) and data are left as
       found.  Where long names are formed of STEP.DDNAME, the
       column formatting is as close as possible to the standards
       above.

       For the following file:

          //***  BACKUP INPUT FILE...
          //IDCAMS EXEC PGM=IDCAMS,REGION=0M
          //SYSPRINT DD SYSOUT=*
          //INFILE DD DSN=SOME.INPUT.FILE,DISP=SHR
          //OUTFILE DD DSN=SOME.OUTPUT.FILE,
          // DISP=(,CATLG),
          // UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),
          // DCB=(RECFM=FB,LRECL=120,BLKSIZE=0)
          //SYSIN DD *
          REPRO INFILE(INFILE ) OUTFILE(OUTFILE )
          //***

       the result of applying NEATJCL would be:

          //*** BACKUP INPUT FILE...
          //IDCAMS     EXEC     PGM=IDCAMS,REGION=0M
          //SYSPRINT     DD       SYSOUT=*
          //INFILE       DD       DSN=SOME.INPUT.FILE,DISP=SHR
          //OUTFILE      DD       DSN=SOME.OUTPUT.FILE,
          //             DISP=(,CATLG),
          //             UNIT=SYSDA,SPACE=(CYL,(10,10),RLSE),
          //             DCB=(RECFM=FB,LRECL=120,BLKSIZE=0)
          //SYSIN        DD       *
          REPRO INFILE(INFILE ) OUTFILE(OUTFILE )
          //***

       While not perfect, it generally provides an instant
       readability improvement.


:HEADER2 SUBCAN  ( ? )
:HEADERT Submit File and Cancel Edit Session

      will submit the job being edited and cancel the edit.  It
      saves the pain of an inadvertent save.  If a question mark
      (?) is specified as the parameter, the built in help is
      displayed.


:HEADER2 SUBO  ( ? )  ( ABEND(COND) )  ( CODE(#) )
:HEADERT Substitute Date/Time/User Variables and Submit Job

      will temporarily change date, time and/or user tokens as
      specified below and submit the job. The changes are NOT
+                                                         ___
      made to the file - the changes are made dynamically as the
      file is written to the internal reader.  It is the same as
      SUBX but with ORIGIN always turned on - please see SUBX
      below.  It may be used in Edit or View mode, or from DS
      List or a member list.  The last, a member list in Browse,
      Edit or View, will not allow any options.  This macro is
      useful for keeping a master set of JCL that places today's
      date/time as part of dataset names.  And, if ABEND is
      specified, generate a step that will force an abnormal
      termination with a specified user code.

      The variables substituted are shown here with sample
      examples using a date of 1999/12/31, a time of 12:34:56 and
      a TSO user ID of YourID.

         &CCYY/MM/DD    <turns into>    1999/12/31
         &CCYY/DDD      <turns into>    1999/034
         &CCYYDDD       <turns into>    1999034
         &CCYYMMDD      <turns into>    19991231
         &DAYOFWK       <turns into>    FRIDAY
         &DD/MM/YY      <turns into>    31/12/99
         &DOW           <turns into>    FRI
         &HH:MM         <turns into>    12:34
         &HH:MM:SS      <turns into>    12:34:56
         &HHMM          <turns into>    1234
         &HHMMSS        <turns into>    123456
         &MM/DD/YY      <turns into>    12/31/99
         &MMDDYY        <turns into>    123199
         &MON           <turns into>    DEC
         &MONTH         <turns into>    DECEMBER
         &USERID        <turns into>    YourID
         &YEAR          <turns into>    1999
         &YY/MM/DD      <turns into>    99/12/31
         &YYDDD         <turns into>    99365
         &YYMMDD        <turns into>    991231

      ORIGIN, which may be abbreviated as ORG or O, will cause
      the following JCL to be inserted after the JOB statement
      (even if the JOB statement extends to 2 or more lines):

      //***
      //***  SUBMITTED BY YourID ON FRIDAY DECEMBER 31ST, 1999 (DAY 365)
      //***     AT 12:34:56 FROM SOME.PDS.JCL(MEMNAME)
      //***

      If ABEND is specified, with or without a parameter, the
      following JCL is added to the end of the submitted job.
      The parameter may be used to specify the COND for the step.
      It defaults to '0,LT'. The specific code to be used in the
      abend may be specified via CODE(#). The default is 666.
      Assuming ABEND(8,LT) and CODE(37) were specified, the JCL
      generated would be:

      //***
      //ABEND      EXEC     PGM=ABENDX,PARM=0037,COND=(8,LT)
      //STEPLIB      DD       DISP=SHR,DSN=YOURID.LOADLIB
      //***

      The ABENDX code is found on the same CBT Tape file as this
      macro.

      If a question mark (?) is supplied as the only parameter,
      the built in help is displayed.

      Given the following tokenized JCL:

         //&USERIDG   JOB      (AcctInfo),'&USERID -- BKUPS',
         //             CLASS=A,MSGCLASS=Y,NOTIFY=&USERID
         //***
         //CLEANUP    EXEC     PGM=IEFBR14
         //DEL01        DD       DSN=&USERID.YR&YEAR.&MON.BKUP
         //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)
         //***
         //GENER      EXEC     PGM=IEBGENER,REGION=4M
         //SYSPRINT     DD       SYSOUT=*
         //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,
         //             DSN=ARKV.TAMASTER.DATA
         //SYSUT2       DD       DISP=(,CATLG),
         //             UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),
         //             DCB=(ARKV.TAMASTER.DATA)
         //             DSN=&USERID.YR&YEAR.&MON.BKUP
         //SYSIN        DD       DUMMY
         //***

      the following would be submitted by executing SUBO:

         //USER077G   JOB      (AcctInfo),'USER077 -- BKUPS',
         //             CLASS=A,MSGCLASS=Y,NOTIFY=USER077
         //***
         //CLEANUP    EXEC     PGM=IEFBR14
         //DEL01        DD       DSN=USER077.YR2002.JUL.BKUP
         //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)
         //***
         //GENER      EXEC     PGM=IEBGENER,REGION=4M
         //SYSPRINT     DD       SYSOUT=*
         //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,
         //             DSN=ARKV.TAMASTER.DATA
         //SYSUT2       DD       DISP=(,CATLG),
         //             UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),
         //             DCB=(ARKV.TAMASTER.DATA)
         //             DSN=USER077.YR2002.JUL.BKUP
         //SYSIN        DD       DUMMY
         //***

      Note the year and month portions filled within the new
      dataset name as well as several user-id uses.


:HEADER2 SUBX  ( ? )  ( ABEND(COND) )  ( CODE(#) )  ( ORIGIN )
:HEADERT Substitute Date/Time/User Variables and Submit Job

      will temporarily change date, time and/or user tokens as
      specified below and submit the job. The changes are NOT
+                                                         ___
      made to the file - the changes are made dynamically as the
      file is written to the internal reader.  It may be used in
      Edit or View mode, or from DS List or a member list.  The
      last, a member list in Browse, Edit or View, will not allow
      any options.  This macro is useful for keeping a master set
      of JCL that places today's date/time as part of dataset
      names.  It will also, if ORIGIN specified, place JCL
      comment statements just after the job statement providing
      date and time of submission as well as submitting user and
      library/file from which the job was submitted.  And, if
      ABEND is specified, generate a step that will force an
      abnormal termination with a specified user code.

      The variables substituted are shown here with sample
      examples using a date of 1999/12/31, a time of 12:34:56 and
      a TSO user ID of YourID.

         &CCYY/MM/DD    <turns into>    1999/12/31
         &CCYY/DDD      <turns into>    1999/034
         &CCYYDDD       <turns into>    1999034
         &CCYYMMDD      <turns into>    19991231
         &DAYOFWK       <turns into>    FRIDAY
         &DD/MM/YY      <turns into>    31/12/99
         &DOW           <turns into>    FRI
         &HH:MM         <turns into>    12:34
         &HH:MM:SS      <turns into>    12:34:56
         &HHMM          <turns into>    1234
         &HHMMSS        <turns into>    123456
         &MM/DD/YY      <turns into>    12/31/99
         &MMDDYY        <turns into>    123199
         &MON           <turns into>    DEC
         &MONTH         <turns into>    DECEMBER
         &USERID        <turns into>    YourID
         &YEAR          <turns into>    1999
         &YY/MM/DD      <turns into>    99/12/31
         &YYDDD         <turns into>    99365
         &YYMMDD        <turns into>    991231

      ORIGIN, which may be abbreviated as ORG or O, will cause
      the following JCL to be inserted after the JOB statement
      (even if the JOB statement extends to 2 or more lines):

      //***
      //***  SUBMITTED BY YourID ON FRIDAY DECEMBER 31ST, 1999 (DAY 365)
      //***     AT 12:34:56 FROM SOME.PDS.JCL(MEMNAME)
      //***

      If ABEND is specified, with or without a parameter, the
      following JCL is added to the end of the submitted job.
      The parameter may be used to specify the COND for the step.
      It defaults to '0,LT'. The specific code to be used in the
      abend may be specified via CODE(#). The default is 666.
      Assuming ABEND(8,LT) and CODE(37) were specified, the JCL
      generated would be:

      //***
      //ABEND      EXEC     PGM=ABENDX,PARM=0037,COND=(8,LT)
      //STEPLIB      DD       DISP=SHR,DSN=YOURID.LOADLIB
      //***

      The ABENDX code is found on the same CBT Tape file as this
      macro.

      If a question mark (?) is supplied as the only parameter,
      the built in help is displayed.

      Given the following tokenized JCL:

         //&USERIDG   JOB      (AcctInfo),'&USERID -- BKUPS',
         //             CLASS=A,MSGCLASS=Y,NOTIFY=&USERID
         //***
         //CLEANUP    EXEC     PGM=IEFBR14
         //DEL01        DD       DSN=&USERID.YR&YEAR.&MON.BKUP
         //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)
         //***
         //GENER      EXEC     PGM=IEBGENER,REGION=4M
         //SYSPRINT     DD       SYSOUT=*
         //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,
         //             DSN=ARKV.TAMASTER.DATA
         //SYSUT2       DD       DISP=(,CATLG),
         //             UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),
         //             DCB=(ARKV.TAMASTER.DATA)
         //             DSN=&USERID.YR&YEAR.&MON.BKUP
         //SYSIN        DD       DUMMY
         //***

      the following would be submitted by executing SUBX:

         //USER077G   JOB      (AcctInfo),'USER077 -- BKUPS',
         //             CLASS=A,MSGCLASS=Y,NOTIFY=USER077
         //***
         //CLEANUP    EXEC     PGM=IEFBR14
         //DEL01        DD       DSN=USER077.YR2002.JUL.BKUP
         //             DISP=(MOD,DELETE,DELETE),UNIT=SYSDA,SPACE=(TRK,0)
         //***
         //GENER      EXEC     PGM=IEBGENER,REGION=4M
         //SYSPRINT     DD       SYSOUT=*
         //SYSUT1       DD       DISP=SHR,DCB=BUFNO=32,
         //             DSN=ARKV.TAMASTER.DATA
         //SYSUT2       DD       DISP=(,CATLG),
         //             UNIT=SYSDA,SPACE=(CYL,(05,02),RLSE),
         //             DCB=(ARKV.TAMASTER.DATA)
         //             DSN=USER077.YR2002.JUL.BKUP
         //SYSIN        DD       DUMMY
         //***

      Note the year and month portions filled within the new
      dataset name as well as several user-id uses.


:HEADER1 Format Control Macros

 The following macros will justify, format and add data.  C/CC/C#
 range control is used to limit the changes since most usage will
 probably be a single instance.  FLAGREVS will only handle the
 entire file since it uses SuperC compare to determine changes.

 Built in help is available by either typing the macro name
 without any parameters or with just a question mark (?) as the
 only operand.


:HEADER2 ADDFLAG    FLAG  ( END-COL )
:HEADERT Place a Flag Value on Selected Lines

       will add a change flag on the lines marked with C/CC/C##
       or the entire file if no range is specified.  The supplied
       flag will be right justified to the specified end column.
       The flag, within quotes if blanks are included, is
       mandatory but the ending column defaults to 72.  The flag
       will simply overlay what's in the columns, so doing a FIND
       on non blanks should be done first (FIND P'¬' ## END-COL)
       if needed data may be in those columns.

          ADDFLAG  '/*  99-12-31  */'

       Will place /*  99-12-31  */ in columns 57 thru 72 of the
       specified C range. Note the receiving location does not
       have to be at the end of the line.


:HEADER2 CENTER   ( LEFT-COLUMN  RIGHT-COLUMN )  ( ? )
:HEADERT Justify Data to Center

       will cause the marked (via C/CC/C##) range of lines to be
       centered within the BOUNDS then in force unless other
       columns are specified as parameters.  If no range is
       specified, the entire file is processed.  The first and
       the last non-blank characters within the bounds determine
       the size of the data to be centered. Specifying a left
       column and right column will cause only the data in those
       columns to be centered. For example:

          CENTER  11 40

       will cause the data in columns 11 through 40 to be
       centered within those columns. A parameter of ? causes
       the built in help to be displayed.


:HEADER2 FLAGREVS   REVISION-FLAG  ( REVISION-COL )
:HEADERT Flag Revisions

       overlays changed records with the REVISION-FLAG.  The
       revision flag is mandatory. The revision column defaults
       to 65. All non changed lines will be excluded and one line
       above and one below will be shown. Non blanks will not be
       overlaid by the flag.  Only the entire file may be flagged
+                             ___________________________________
       since they're generated by comparing the existing file to
       the data being edited in storage. An example is:

          FLAGREVS  |  2

       will place a vertical bar in column 2 of every line in the
       file being edited that's different from the original saved
       file. The entire file will be excluded and the lines with
       the revision flag added will be included with a line above
       and below shown to establish context.

       Deleted lines obviously can not be flagged.


:HEADER2 LJUST   ( LEFT-COLUMN  RIGHT-COLUMN )  ( ? )
:HEADERT Justify Data to Left

       will cause the marked (via C/CC/C##) range of lines to be
       left justified within the BOUNDS then in force or within
       the columns specified.  If no range is specified, the
       entire file is processed.  The first and the last non
       blank characters within the bounds determine the size of
       the data to be left justified.  Specifying a left column
       and right column will cause only the data in those columns
       to be justified. For example:

          LJUST  11 20

       will cause the data in columns 11 through 20 to be left
       justified within those columns, that is, the first non
       blank will be placed in column 11, padding on the right
       with blanks.


:HEADER2 RJUST   ( LEFT-COLUMN  RIGHT-COLUMN )  ( ? )
:HEADERT Justify data to Right

       will cause the marked (via C/CC/C##) range of lines to be
       right justified within the BOUNDS then in force.  If no
       range is specified, the entire file is processed.  The
       first and the last non blank characters within the bounds
       determine the size of the data to be right justified.
       This chunk of data is shifted as is.

       Specifying a left column and right column will cause only
       the data in those columns to be justified. For example:

          RJUST   1 20

       will cause the data in columns 1 through 20 to be right
       justified within those columns, that is, the last non
       blank will come to rest in column 20.


:HEADER2 SQUSH   ( LEFT-COLUMN  RIGHT-COLUMN ) ( ? )
:HEADERT Remove Extraneous Blanks From Data

       will cause the marked (via C/CC/C##) range of lines to be
       left justified within the BOUNDS then in force or within
       the columns specified and multiple consective blanks
       changed to one blank.  If no range is specified, the
       entire file is processed. A question mark will cause the
       built in help to be displayed.

       For example, given the following somewhat implausable
       heavily edited text:

          It is further assumed
          that any associated   supporting element
          necessitates                  that urgent consideration be
          applied
          to the total
          system rationale.   However, the fully integrated test
          program
          must utilize and be       functionally interwoven with the
          overall
          negative profitability.

       the result of SQUSH's being issued would be:

          It is further assumed
          that any associated supporting element
          necessitates that urgent consideration be applied
          to the total
          system rationale. However, the fully integrated test
          program
          must utilize and be functionally interwoven with the overall
          negative profitability.

       A better use would be compressing the blanks out of code
       or JCL that requires substantial insertions during
       editing, but, given the above, you could then use text
       format (TF) on the result of the SQUSH and get decent
       output.


:HEADER1 Inter/Intra Dataset Macros

 The macros in this group will acquire one or more lines of data
 through use of the (now) standard system CUT command or the CUTX
 macro provided in this package.  The (now) standard system PASTE
 command and the PA and PY macros may be used to insert the CUT
 lines, or the PASTEX, PASTEAFT and PASTY macros in this pacakge
 may be used to insert the CUTX lines.

 The system provided CUT/PASTE commands (and the PA/PY macros)
 will allow use across ISPF applications such as going from
 standard View to SDSF SJ.  Unfortunately, the
 CUTX/PASTEX/PASTEAFT/PASTY macros, while working fine within an
 application such as View to Edit, can't handle the cross
 application connection since they use the PROFILE to store data.

 The reason both sets are still provided is that there are folks
 who use the older set and don't want to change.

 PASTEAFT and PA allows the pasting of CUTX and CUT data
 respectively after one or more lines in a range. PASTY and PY
 will allow pasting data after the line the cursor is on,
 optimally done with an assigned PFKey.

 The CUT and PASTE commands have built in ISPF help that may be
 accessed by pressing <F1> within an Edit session.  The macros in
 this package provide built in help by typing the macro followed
 by a '?', e.g. CUTX ?. XCOPY may simply be typed without any
 parameters to get help.

 Please note that the use of CUT and PASTE allows you to use
+___________
 EDITSET (or EDSET) within Edit or View to set the default
 behaviors for these macros such as whether to replace or append
 data with CUT and to delete or keep data with PASTE. It is
 strongly suggested that they be used.


:HEADER2 CUTX   ( A | APPEND )  ( ? )
:HEADERT Place Lines Into Profile for Pasting

       write lines from a file to the PROFILE pool for later
       inclusion by the paste macros PASTEX, PASTEAFT and PASTY.
       Enter CUTX on the COMMAND line and use the C or M line
       commands (in any form) to select the lines to be cut.  If
       the M line command is used, the lines will be deleted from
       the originating file.

       A parameter of A or APPEND can be specified to add to any
       previously CUTX lines with the newly selected lines.
       Otherwise, the selected lines will replace any previously
       CUTX lines. A ? will cause the built in help to display.


:HEADER2 PA   ( #-LINES-TO-SKIP )  ( ? )
:HEADERT Copy Lines From Default Clipcoard Into Multiple Places

       pull lines from the default ISPF clipboard into the
       current file.  This macro is used in conjunction with the
       CUT command.  Enter PA on the COMMAND line and use
       C/CC/C## line commands to specify where the lines are to
       be inserted.  The data will be copied after each line
       within the range skipping #-LINES-TO-SKIP lines each copy.
       #-LINES-TO-SKIP defaults to 1.

       A parameter of a question mark will cause the built in
       help to be displayed.

       Given you've CUT the following line:

          //            DD        DISP=SHR,DCB=BUFNO=32,

       use 'PA' on the following lines (with the selected
       range shown by the CC'd lines:

          CC0001 //***
          000002 //             DSN=SYS6.STKVTS2.BKUP.G0123V00
          000003 //             DSN=SYS6.STKVTS2.BKUP.G0124V00
          000004 //             DSN=SYS6.STKVTS2.BKUP.G0125V00
          000005 //             DSN=SYS6.STKVTS2.BKUP.G0126V00
          000006 //             DSN=SYS6.STKVTS2.BKUP.G0127V00
          CC0007 //             DSN=SYS6.STKVTS2.BKUP.G0128V00
          000008 //             DSN=SYS6.STKVTS2.BKUP.G0129V00
          000009 //***

       to get:

          000001 //***
          000002 //            DD        DISP=SHR,DCB=BUFNO=32,
          000003 //             DSN=SYS6.STKVTS2.BKUP.G0123V00
          000004 //            DD        DISP=SHR,DCB=BUFNO=32,
          000005 //             DSN=SYS6.STKVTS2.BKUP.G0124V00
          000006 //            DD        DISP=SHR,DCB=BUFNO=32,
          000007 //             DSN=SYS6.STKVTS2.BKUP.G0125V00
          000008 //            DD        DISP=SHR,DCB=BUFNO=32,
          000009 //             DSN=SYS6.STKVTS2.BKUP.G0126V00
          000010 //            DD        DISP=SHR,DCB=BUFNO=32,
          000011 //             DSN=SYS6.STKVTS2.BKUP.G0127V00
          000012 //            DD        DISP=SHR,DCB=BUFNO=32,
          000013 //             DSN=SYS6.STKVTS2.BKUP.G0128V00
          000014 //            DD        DISP=SHR,DCB=BUFNO=32,
          000015 //             DSN=SYS6.STKVTS2.BKUP.G0129V00
          000016 //***

       Note in the above how the CC's lines are chosen to add
       lines and skip appropriately.


:HEADER2 PASTEAFT   ( D | DELETE )  ( #-LINES-TO-SKIP )  ( ? )
:HEADERT Copy Lines From Profile Into Multiple Places

       pull lines from the user PROFILE pool into the current
       file.  This macro is used in conjunction with the CUTX
       macro.  Enter PASTEAFT on the COMMAND line and use
       C/CC/C## line commands to specify where the lines are to
       be pasted.  The pasted data will be copied after each line
       within the range skipping #-LINES-TO-SKIP lines each copy
       with #-LINES-TO-SKIP defaulting to 1.

       A parameter of D or DELETE can be specified to cause the
       macro to set the profile variables to null after the lines
       have been pasted into the file.  The order of the operands
       or absence of either is not material.

       A parameter of a question mark will cause the built in
       help to be displayed.

       Given you've CUTX'd the following line:

          //            DD        DISP=SHR,DCB=BUFNO=32,

       use 'PASTEAFT' on the following lines (with the selected
       range shown by the CC'd lines:

          CC0001 //***
          000002 //             DSN=SYS6.STKVTS2.BKUP.G0123V00
          000003 //             DSN=SYS6.STKVTS2.BKUP.G0124V00
          000004 //             DSN=SYS6.STKVTS2.BKUP.G0125V00
          000005 //             DSN=SYS6.STKVTS2.BKUP.G0126V00
          000006 //             DSN=SYS6.STKVTS2.BKUP.G0127V00
          CC0007 //             DSN=SYS6.STKVTS2.BKUP.G0128V00
          000008 //             DSN=SYS6.STKVTS2.BKUP.G0129V00
          000009 //***

       to get:

          000001 //***
          000002 //            DD        DISP=SHR,DCB=BUFNO=32,
          000003 //             DSN=SYS6.STKVTS2.BKUP.G0123V00
          000004 //            DD        DISP=SHR,DCB=BUFNO=32,
          000005 //             DSN=SYS6.STKVTS2.BKUP.G0124V00
          000006 //            DD        DISP=SHR,DCB=BUFNO=32,
          000007 //             DSN=SYS6.STKVTS2.BKUP.G0125V00
          000008 //            DD        DISP=SHR,DCB=BUFNO=32,
          000009 //             DSN=SYS6.STKVTS2.BKUP.G0126V00
          000010 //            DD        DISP=SHR,DCB=BUFNO=32,
          000011 //             DSN=SYS6.STKVTS2.BKUP.G0127V00
          000012 //            DD        DISP=SHR,DCB=BUFNO=32,
          000013 //             DSN=SYS6.STKVTS2.BKUP.G0128V00
          000014 //            DD        DISP=SHR,DCB=BUFNO=32,
          000015 //             DSN=SYS6.STKVTS2.BKUP.G0129V00
          000016 //***

       Note in the above how the pasted lines follow the CC'd
       lines and skip appropriately.


:HEADER2 PASTEX   ( D | DELETE )  ( ? )
:HEADERT Copy Lines From Profile

       pull lines from the user profile into the current file.
       This macro is used in conjunction with the CUTX macro.
       Enter PASTEX on the COMMAND line and use the A or B line
       command to specify where the lines are to be pasted.

       An option of D or DELETE can be specified to cause the
       macro to erase the cut profile variables after the lines
       have been pasted into the file.  A parameter of a question
       mark will cause the built in help to be displayed.

       See PASTY below for a PF Key driven paste at the cursor
       position and PASTEAFT above for pasting after multiple
       lines.


:HEADER2 PY  ( ? )
:HEADERT Copy Lines From Default Clipboard by Cursor Position

       pull lines from the default ISPF clipboard into the
       current file after where the cursor is positioned.  This
       macro is used in conjunction with the CUT command.  Enter
       PY on the command line and position the cursor on the line
       after which the cut lines are to be inserted.  The command
       is best used when assigned to a PF key (e.g.  use KEYS
       under Edit to assign %PY to PF16 as shown in the sample
       key set above).  It never removes the cut lines from the
       clipboard, and is intended to allow easy, repeatable
       insertions of the same data multiple times, and across
       multiple files and applications.

       If the cursor is above the top data line showing on the
       screen, the data will be pasted after that data line.
       This uses the ZScreenC and ZScreenI variables which may
       not be available in all ISPF releases.


:HEADER2 PASTY  ( ? )
:HEADERT Copy Lines From Profile by Cursor Position

       pull lines from the user PROFILE pool into the current
       file after where the cursor is positioned.  This macro is
       used in conjunction with the CUTX macro.  Enter PASTY on
       the COMMAND line and position the cursor on the line after
       which the cut lines are to be inserted.  The command is
       best used when assigned to a PF key (e.g.  use KEYS under
       Edit to assign %PASTY to PF16 as shown in the sample key
       set above).  It obviously never removes the cut lines from
       the profile, and is intended to allow easy, repeatable
       insertions of the same data multiple times and across
       multiple files.

       If the cursor is above the top data line showing on the
       screen, the data will be pasted after that data line.
       This uses the ZScreenC and ZScreenI variables which may
       not be available in all ISPF releases.


:HEADER2 VERASE
:HEADERT Clear Profile Pool CUTX Entries & Zero CutCnt

       clears the lines cut via CUTX and resets the counter
       normally maintained. Useful when the system returns an
       oddball message saying the profile is full.


:HEADER2 XCOPY   DATA-SOURCE  ( FROM-REC# ( TO-REC# ) )
:HEADERT Retrieve Data Into File From Command Line

       copy a dataset or member directly into the file being
       edited without going through the COPY screens.  The data
       source is mandatory. A destination (either an 'A' or 'B'
       in the prefix area) may be specified; if neither is
       specified, the data is copied to the front of the edited
       file. For example,

          XCOPY 'SYS1.MACLIB(GET)'

       will retrieve the GET macro into the currently edited
       file.

       The starting record and the ending record of the input may
       be specified. If not, they default to the first and last.
       If only the starting number is specified, the copy will
       proceed through the end of the input file.  For example,

          XCOPY  DATAFILE  45

       will copy the 45th record through the end of your user
       ID's DATAFILE.

       The number of lines inserted is shown in the upper right
       corner of the screen.

       The current ISPF COPY facility provides the same
       functionality with the exception of
       specifying specific records.

:HEADER1 DSList Macros

 These macros are executed under option 3.4, the DataSet List,
 just like specifying a "B" to browse the file. They will count
 the number of records, show the longest and shortest lengths,
 perform a scan of a PDS to find a string, show the last
 referenced date without causing it to change, and create a copy
 of an existing sequential or partitioned data set copying the
 associated data or not.

 Built in help is available by either typing the macro name
 without any parameters or with just a question mark (?) as the
 only operand.


:HEADER2 CLONE  NEWDSN  ( # | +# | -# )  ( EMPTY )  ( RELEASE ) ( Q# )
:HEADERT Duplicate Sequential or Partitioned Data Set

       creates a new data set with the same attributes as the one
       overtyped. Sequential, partitioned data sets extended
       (PDSE's) or partitioned data sets (PDS's) may be
       duplicated. NEWDSN may be fully qualified with quotes,
       e.g.  'SYS4.MACLIB', or allowed to take on the user
       prefix, e.g. TEST.DATA. Please note you must have
       sufficient access authority to create a dataset under
       whatever security system is in use.

       The original name may be used as a prefix by typing an
       equal sign (=) followed by the intended suffix in place of
       NEWDSN.  Overtyping SYS4.MACLIB with =.BKUP will produce a
       new data set named SYS4.MACLIB.BKUP; the new data set name
       must not exist and should be a legitimate name for the
       invoking user to create.

       The original data set may be used as a suffix by typing
       the intended prefix followed by an equal sign (=).
+                          ___________
       Overtyping SYS4.MACLIB with YOURUID.= will create a new
       data set named YOURID.SYS4.MACLIB.

       Using either the above mentioned prefixing or suffixing
       options will always cause the resultant new data set name
       to be fully qualified, i.e. as if it were input within
       quotes. Use a blank following the new data set choice if
       there is any doubt about how it will be "seen" by the
       system.

       An option of Q# will reduce the initial qualifiers of the
       original data set by # for prefixed XXX= or the final
       qualifiers for suffixed =XXX new data set names.  Given
       the preceding example, a Q1 will cause YOURUID.MACLIB to
       be created.

       Optionally, EMPTY may be specified with the new name to
       not cause data to be copied.

       Optionally, RELEASE may be specified to release unused
       space following copying data (useful for back up
       versions).

       You may also specify a change to directory blocks; for
       partitioned data sets only, a new number or an
       increment/decrement may be specified (no sign means
       replace, a '+' causes that number to be added and a '-' to
       be subtracted).  The new number may not be below the
       currently used directory size when causing data to be
       copied.

       So, if SYS1.MACLIB is the data set shown in the data set
       list, entering the command over ot of

          CLONE  +17  RUBBER.DUCKY  EMPTY

       will create a new PDS under your ID (assuming your prefix
       is the default) with the name RUBBER.DUCKY with no members
+                                                 _______________
       and with 17 more directory blocks then the original.

       For sequential data sets, specifying a number or a number
+          __________
       prefixed by a plus(+) or minus(-) will cause a change to
       the logical record length. An unsigned number will cause
       the resultant data set to have that number as its LRECL. A
       plus value, +#, will cause # to be added to the LRECL; a
       minus value, -#, will cause that # to be subtracted from
       the LRECL. If the new record length is greater then the
       old, blanks will be used to pad on the right. Variable
       lengths are the LRECL, so for a maximum 1,000 bytes of
       data, specify 1004.

       If the following were overtyped on SYS1.MACLIB

          CLONE  'SYS2.MACLIB'

       a new PDS named SYS2.MACLIB would be created and all the
       SYS1.MACLIB members copied to it.

       Entering

          CLONE  +90  =X

       on SYS1.MACLIB, a new PDS named SYS1.MACLIBX would be
       created with 90 more directory blocks then the current
       allocation of SYS1.MACLIB and all the SYS1.MACLIB members
       copied to it.

       Entering an equal sign on subsequent data set lines under
       DS List would cause the same command to be executed
       against them. This is useful if you want to create back up
       versions by date, e.g. CLONE =.D991231.


:HEADER2 CLONER  NEWDSN  ( # | +# | -# )  ( EMPTY )  ( RELEASE ) ( Q# )
:HEADERT Copy/Replace Sequential or Partitioned Data Set

       creates a new data set with the same attributes as the one
       overtyped, deleting the data set if it exists.
       Sequential, partitioned data sets extended (PDSE's) or
       partitioned data sets (PDS's) may be duplicated. NEWDSN
       may be fully qualified with quotes, e.g.  'SYS4.MACLIB',
       or allowed to take on the user prefix, e.g.  TEST.DATA.
       Please note you must have sufficient access authority to
       create a dataset under whatever security system is in use.

       The original name may be used as a prefix by typing an
       equal sign (=) followed by the intended suffix in place of
       NEWDSN.  Overtyping SYS4.MACLIB with =.BKUP will produce a
       new data set named SYS4.MACLIB.BKUP; the new data set name
       may exist, but will be deleted if so, and should be a
       legitimate name for the invoking user to create.

       The original data set may be used as a suffix by typing
       the intended prefix followed by an equal sign (=).
+                          ___________
       Overtyping SYS4.MACLIB with YOURUID.= will create a new
       data set named YOURID.SYS4.MACLIB.

       Using either the above mentioned prefixing or suffixing
       options will always cause the resultant new data set name
       to be fully qualified, i.e. as if it were input within
       quotes. Use a blank following the new data set choice if
       there is any doubt about how it will be "seen" by the
       system.

       An option of Q# will reduce the initial qualifiers of the
       original data set by # for prefixed XXX= or the final
       qualifiers for suffixed =XXX new data set names.  Given
       the preceding example, a Q1 will cause YOURUID.MACLIB to
       be created.

       Optionally, EMPTY may be specified with the new name to
       not cause data to be copied.

       Optionally, RELEASE may be specified to release unused
       space following copying data (useful for back up
       versions).

       You may also specify a change to directory blocks; for
       partitioned data sets only, a new number or an
       increment/decrement may be specified (no sign means
       replace, a '+' causes that number to be added and a '-' to
       be subtracted).  The new number may not be below the
       currently used directory size when causing data to be
       copied.

       So, if SYS1.MACLIB is the data set shown in the data set
       list, entering the command over ot of

          CLONER  +17  RUBBER.DUCKY  EMPTY

       will create a new PDS under your ID (assuming your prefix
       is the default) with the name RUBBER.DUCKY with no members
+                                                 _______________
       and with 17 more directory blocks then the original,.
       replacing RUBBER.DUCKY if it exists.

       For sequential data sets, specifying a number or a number
+          __________
       prefixed by a plus(+) or minus(-) will cause a change to
       the logical record length. An unsigned number will cause
       the resultant data set to have that number as its LRECL. A
       plus value, +#, will cause # to be added to the LRECL; a
       minus value, -#, will cause that # to be subtracted from
       the LRECL. If the new record length is greater then the
       old, blanks will be used to pad on the right.

       If the following were overtyped on SYS1.MACLIB

          CLONER  'SYS2.MACLIB'

       a new PDS named SYS2.MACLIB would be created and all the
       SYS1.MACLIB members copied to it.

       Entering

          CLONER  +90  =X

       on SYS1.MACLIB, a new PDS named SYS1.MACLIBX would be
       created with 90 more directory blocks then the current
       allocation of SYS1.MACLIB and all the SYS1.MACLIB members
       copied to it.

       Entering an equal sign on subsequent data set lines under
       DS List would cause the same command to be executed
       against them.  This is useful if you want to recreate back
       up versions by date, e.g. CLONER =.D991231.


:HEADER2 COUNTX  ( ? )
:HEADERT Provide Count of Records in File

       will cause a message to be written as:

          '-the-dataset-name-' (FBA /  133/27930)      3,225,818

       with the record format, logical record length and block
       size as well as the number of records for sequential
       datasets. For VSAM ESDS's or KSDS's, it will only show:

          '-the-dataset-name-'                           123,456

       Subsequent files may be indicated using the equal sign as
       in normal DS List usage. If a question mark immediately
       follows the COUNTX, built in help will be displayed.


:HEADER2 DELCOLS   LEFT-COL1 RIGHT-COL1 (...)
:HEADERT Delete Columns

       will remove the specified columns, shifting the remaining
       leftwards, as in

          DELCOLS  11  20

       deleting column 11 through 20 and shifting everything from
       column 21 to the end of each record left 10 columns.
       DELCOLS may be used as a large scale truncating left
       shift, that is,

          DELCOLS  1  20

       will cause all data to be shifted 20 positions to the
       left.

       DELCOLS is the reverse of KEEPCOLS, removing rather then
       keeping data.  Given the following data:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5

       the results of 'DELCOLS  11 20  31 40' would be:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE
          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE
          AAAAAAAAAACCCCCCCCCCEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5

       This macro is intended to be used from DS List when the
       data set is too large to be edited.  Once the data set has
       been "reduced," CLONE may be used to recreate it with its
       new size.


:HEADER2 EMPTY  ( ? )
:HEADERT Null Sequential or Partitioned Data Set

       removes all data from sequential or partitioned data sets
       (PDS's or PDSE's).  It will open and immediately close a
       sequential file, thereby writing only an end of file
       indicator. It will allocate a new PDS identical to the
       original for partitioned data sets and then delete the
       original and rename the new one to the original name.

       It will display the name(s) of the data set(s) emptied.
       If the question mark parameter is specified, the built in
       help will be displayed but no data deleted.


:HEADER2 FINDNSTR   STRING   ( ? )
:HEADERT Scan a PDS For Members Without a Given String

       will cause a SuperC PDS scan to be invoked for the
       specified string against the PDS(E) and the resultant scan
       opened in Browse.  showing which members did not contain
+                                                   ___
       the string.  If it's not found at all, a simple message
       indicates that.

       The string may be specified by simply typing it without
       quotes.  For example:

          FINDNSTR  REXX

       with 'REXX' overtyping the dataset name.  The results will
       be placed in the default dataset from the Search-For
       Utility option or SRCHFOR.LIST under the current user's ID
       as well as opened in Browse mode.

       If there's any doubt about how the string will be
       recognized by DS List, simply place it in single quotes,
       e.g.

          FINDNSTR  'TRANSLATE('

       An ampersand, &, must be doubled, i.e. && specified.

       Both the string sought and the file name will be
       displayed.  If a question mark (?) is specified or no
       string at all, help will be shown. To search for a single
       question mark, place it within quotes. For example,
       'FINDNSTR  REXX' might generate (if looking for non REXX
       executables):

          MEMBER-SEARCHED         LINES-FOUND   LINES-PROC

          FAND                            0          203
          FNOT                            0          207
          FOR                             0          203

          ...

          LINES-FOUND  LINES-PROC  MEMBERS-W/LNS  MEMBERS-WO/LNS
                206        20476          136              3

       The above shows that the 3 members listed did NOT contain
       the string REXX.


:HEADER2 FINDSTRX   STRING   ( ? )
:HEADERT Scan a PDS For a Given String

       will cause a PDS(E) scan to be invoked for the specified
       string and the resultant scan opened in browse if any
       instances are found (a message will indicate none were
       found if so).  The string may be specified by simply
       typing it without quotes.  For example:

          FINDSTRX SOME DUMB STRING

       with 'SOME DUMB STRING' overtyping the dataset name.  The
       results will be placed in the default dataset from the
       Search-For Utility option or SRCHFOR.LIST under the
       current user's ID as well as opened in Browse mode.

       If there's any doubt about how the string will be
       recognized by DS List, simply place it in single quotes,
       e.g.

          FINDSTRX  'TRANSLATE('

       Both the string sought and the file name will be
       displayed.  If a question mark (?) is specified
       or no string at all, help will be shown. To
       search for a single question mark, place it
       within quotes.

       The Browse will show the member name(s) where the string
       was found as well as the individual lines where it was
       found.

       Please see the FS macro below which will submit the
       equivalent scan of a PDS(E) as a regular job.


:HEADER2 HOWLONG  ( ? )
:HEADERT Show Longest and Shortest Lengths

       for variable length data sets, HOWLONG will cause a
       message to be written as:

          '-the-dataset-name-' - LONGEST/SHORTEST IS 860/204

       The lengths do not include the 4 byte length field nor the
       4 byte block length field for variable (RECFM=V) files.
       Note that the actual record length is often far larger
       then the longest record on the file.

       For a fixed record format file,a message such as:

          '-the-dataset-name-' - LONGEST/SHORTEST IS 80/0
            ----- BASED ON BLANKS AT END OF RECORDS (FIXED DATA SET)

       will be produced. The macro counts the number of blanks
       at the end of each line and considers the longest record
       to be the one with the least number of blanks and the
       shortest to be the one with the most number of blanks.
       Assuming the '-the-dataset-name-' was an 80 byte file,
       the 80/0 indicates that some record(s) had all 80 bytes
       filled and some were all blank.

       Subsequent files may be indicated using the equal sign as
       in normal DS List usage.  A question mark as the only
       parameter will cause the built in help to be displayed.


:HEADER2 KEEPCOLS  LEFT-COL1 RIGHT-COL1 (...)
:HEADERT Retain Columns Deleting All Other Columns

       will keep the specified columns, shifting them to the
       left, as running the following against a 200 file:

          KEEPCOLS  11 20  101 103  141 142

       effectively deletes columns 1 through 10, 21 through 100,
       104 through 140 and 143 through 200.  The selected columns
       will be in the left-most 15 columns and the other 185
       columns will be blank.

       Given the following data:

          ----+----1----+----2----+----3----+----4----+----5
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          AAAAAAAAAAbbbbbbbbbbCCCCCCCCCCddddddddddEEEEEEEEEE
          ----+----1----+----2----+----3----+----4----+----5

       the results of 'KEEPCOLS  11 20' would be:

          ----+----1----+----2----+----3----+----4----+----5
          bbbbbbbbbb
          bbbbbbbbbb
          bbbbbbbbbb
          ----+----1----+----2----+----3----+----4----+----5

       KEEPCOLS is also documented under Column Manipulation
       macros since it can be invoked in Edit/View. Please see
       CLONE to see how to copy a data set changed by KEEPCOLS to
       a smaller version quickly.


:HEADER2 LASTREF
:HEADERT Display Last Reference Date under DS List

       will cause a message to be written as:

          FILE -the-dataset-name- WAS LAST REFERENCED 1999/11/12

       This will not cause the date to be updated.  Subsequent
       files may be indicated using the equal sign as in normal
       3.4 usage.


:HEADER2 QCLONE  NEWDSN  ( # | +# | -# )  ( EMPTY )  ( RELEASE ) ( Q# )
:HEADERT Duplicate Sequential or Partitioned Data Set via Job

       will submit a job to create a new data set with the same
       attributes as the one overtyped.  If the EMPTY option is
       specified, the allocation will be done immediately in the
       EXEC.  Sequential, partitioned data sets extended (PDSE's)
       or partitioned data sets (PDS's) may be duplicated. NEWDSN
       may be fully qualified with quotes, e.g.  'SYS4.MACLIB',
       or allowed to take on the user prefix, e.g.  TEST.DATA.
       Please note you must have sufficient access authority to
       create a dataset under whatever security system is in use.
       This is essentially the same as CLONE except that the copy
       is done in batch.

       The original name may be used as a prefix by typing an
       equal sign (=) followed by the intended suffix in place of
       NEWDSN.  Overtyping SYS4.MACLIB with =.BKUP will produce a
       new data set named SYS4.MACLIB.BKUP; the new data set name
       must not exist and should be a legitimate name for the
       invoking user to create.

       The original data set may be used as a suffix by typing
       the intended prefix followed by an equal sign (=).
+                          ___________
       Overtyping SYS4.MACLIB with YOURUID.= will create a new
       data set named YOURID.SYS4.MACLIB.

       Using either the above mentioned prefixing or suffixing
       options will always cause the resultant new data set name
       to be fully qualified, i.e. as if it were input within
       quotes. Use a blank following the new data set choice if
       there is any doubt about how it will be "seen" by the
       system.

       An option of Q# will reduce the initial qualifiers of the
       original data set by # for prefixed XXX= or the final
       qualifiers for suffixed =XXX new data set names.  Given
       the preceding example, a Q1 will cause YOURUID.MACLIB to
       be created.

       Optionally, EMPTY may be specified with the new name to
       not cause data to be copied (this is done in the TSO
       session since it is only an allocate).

       Optionally, RELEASE may be specified to release unused
       space following copying data (useful for back up
       versions).

       You may also specify a change to directory blocks; for
       partitioned data sets only, a new number or an
       increment/decrement may be specified (no sign means
       replace, a '+' causes that number to be added and a '-' to
       be subtracted).  The new number may not be below the
       currently used directory size when causing data to be
       copied.

       So, if SYS1.MACLIB is the data set shown in the data set
       list, entering the command over ot of

         QCLONE  +17  RUBBER.DUCKY  EMPTY

       will create a new PDS under your ID (assuming your prefix
       is the default) with the name RUBBER.DUCKY with no members
+                                                 _______________
       and with 17 more directory blocks then the original.

       For sequential data sets, specifying a number or a number
+          __________
       prefixed by a plus(+) or minus(-) will cause a change to
       the logical record length. An unsigned number will cause
       the resultant data set to have that number as its LRECL. A
       plus value, +#, will cause # to be added to the LRECL; a
       minus value, -#, will cause that # to be subtracted from
       the LRECL. If the new record length is greater then the
       old, blanks will be used to pad on the right. Variable
       lengths are the LRECL, so for a maximum 1,000 bytes of
       data, specify 1004.

       If the following were overtyped on SYS1.MACLIB

         QCLONE  'SYS2.MACLIB'

       a new PDS named SYS2.MACLIB would be created and all the
       SYS1.MACLIB members copied to it.

       Entering

         QCLONE  +90  =X

       on SYS1.MACLIB, a new PDS named SYS1.MACLIBX would be
       created with 90 more directory blocks then the current
       allocation of SYS1.MACLIB and all the SYS1.MACLIB members
       copied to it.

       Entering an equal sign on subsequent data set lines under
       DS List would cause the same command to be executed
       against them. This is useful if you want to create back up
       versions by date, e.g. CLONE =.D991231.


:HEADER2 QCLONER  NEWDSN  ( # | +# | -# )  ( EMPTY )  ( RELEASE ) ( Q# )
:HEADERT Copy/Replace Sequential or Partitioned Data Set via Job

       will submit a job to create a new data set with the same
       attributes as the one overtyped, deleting the NEWDSN if it
       exists.  If the EMPTY option is specified, the allocation
       will be done immediately in the EXEC.  Sequential,
       partitioned data sets extended (PDSE's) or partitioned
       data sets (PDS's) may be duplicated. NEWDSN may be fully
       qualified with quotes, e.g.  'SYS4.MACLIB', or allowed to
       take on the user prefix, e.g.  TEST.DATA.  Please note you
       must have sufficient access authority to create a dataset
       under whatever security system is in use.  This is
       essentially the same as CLONER except that the copy is done
       in batch.

       The original name may be used as a prefix by typing an
       equal sign (=) followed by the intended suffix in place of
       NEWDSN.  Overtyping SYS4.MACLIB with =.BKUP will produce a
       new data set named SYS4.MACLIB.BKUP; the new data set name
       must not exist and should be a legitimate name for the
       invoking user to create.

       The original data set may be used as a suffix by typing
       the intended prefix followed by an equal sign (=).
+                          ___________
       Overtyping SYS4.MACLIB with YOURUID.= will create a new
       data set named YOURID.SYS4.MACLIB.

       Using either the above mentioned prefixing or suffixing
       options will always cause the resultant new data set name
       to be fully qualified, i.e. as if it were input within
       quotes. Use a blank following the new data set choice if
       there is any doubt about how it will be "seen" by the
       system.

       An option of Q# will reduce the initial qualifiers of the
       original data set by # for prefixed XXX= or the final
       qualifiers for suffixed =XXX new data set names.  Given
       the preceding example, a Q1 will cause YOURUID.MACLIB to
       be created.

       Optionally, EMPTY may be specified with the new name to
       not cause data to be copied (this is done in the TSO
       session since it is only an allocate).

       Optionally, RELEASE may be specified to release unused
       space following copying data (useful for back up
       versions).

       You may also specify a change to directory blocks; for
       partitioned data sets only, a new number or an
       increment/decrement may be specified (no sign means
       replace, a '+' causes that number to be added and a '-' to
       be subtracted).  The new number may not be below the
       currently used directory size when causing data to be
       copied.

       So, if SYS1.MACLIB is the data set shown in the data set
       list, entering the command over ot of

         QCLONER  +17  RUBBER.DUCKY  EMPTY

       will create a new PDS under your ID (assuming your prefix
       is the default) with the name RUBBER.DUCKY with no members
+                                                 _______________
       and with 17 more directory blocks then the original.

       For sequential data sets, specifying a number or a number
+          __________
       prefixed by a plus(+) or minus(-) will cause a change to
       the logical record length. An unsigned number will cause
       the resultant data set to have that number as its LRECL. A
       plus value, +#, will cause # to be added to the LRECL; a
       minus value, -#, will cause that # to be subtracted from
       the LRECL. If the new record length is greater then the
       old, blanks will be used to pad on the right. Variable
       lengths are the LRECL, so for a maximum 1,000 bytes of
       data, specify 1004.

       If the following were overtyped on SYS1.MACLIB

         QCLONER  'SYS2.MACLIB'

       a new PDS named SYS2.MACLIB would be created and all the
       SYS1.MACLIB members copied to it.

       Entering

         QCLONER  +90  =X

       on SYS1.MACLIB, a new PDS named SYS1.MACLIBX would be
       created with 90 more directory blocks then the current
       allocation of SYS1.MACLIB and all the SYS1.MACLIB members
       copied to it.

       Entering an equal sign on subsequent data set lines under
       DS List would cause the same command to be executed
       against them. This is useful if you want to create back up
       versions by date, e.g. CLONE =.D991231.


:HEADER1 Member List Macros

 The following macros may be entered on any Browse, Edit or
 View member list.


:HEADER2 LKDT LoadLib(Member)  ( ? )
:HEADERT Display When a Load Module Was Linked

      displays the date and time a load module was link edited.
      This depends on the AMBLIST LISTIDR function and will fail,
      providing an error message, if the module's IDR is
      corrupted or non-existent.  It may be invoked by direct
      call, e.g.

         TSO LKDT 'SYS1.LINKLIB(IEHPROGM)'

      or by entering it on a member list under Browse, Edit or
      View, e.g.

         BROWSE            USERID.X.LOADLIB
         Command ===>
                    Name     Prompt        Alias-of     Size      TTR
         _________ ABENDX                             00000278   001E23
         lkdt_____ ADDCC                              008AF378   002109
         _________ ALIAS                              00000498   00012E

      which might result in the following being displayed:

         ADDCC in 'USERID.X.LOADLIB' was linked
             Friday May 23rd, 2003 (day 143)

      A ? as the only argument causes the internal help to be
      displayed. Obviously, this macro applies only to load
      modules. As for other member commands, equal signs (=) may
      be used to repeat the command against other members.

      LKDT might fail if no IDR data is found; an appropriate
      message is displayed.


:HEADER2 TD
:HEADERT Display and Remove Member Statistics

      displays the statistics associated with a member and, if
      not cancelled, will remove the statistics from that member.
      It is invoked by entering it on a member list under Browse,
      Edit or View, e.g.

         VIEW              USERX.CLIST
         Command ===>
                    Name     Prompt       Size   Created
         td_______ ADDLINEB                  4  2002/09/14  2002/...
         _________ ADDLINES                 90  2002/09/14  2002/...
         _________ ALIGN                    68  2002/09/14  2002/...

      which might result in the following being displayed:

            -- PDS Statistics Display/Delete                   --

          PDS:  USERX.CLIST
          MEM:  ADDLINEB

          Version:     12
          Mod Count:   00
          Create Dt:   02/09/14
          Change Dt:   02/09/14
          Change Tm:   07:56
          Initial Sz:  4
          Current Sz:  4
          UserID:      USERX

            -- Press <ENTER> to delete or <PF3> (END) to Quit  --

      which, if <Enter> is pressed, will result in the member's
      statistics being removed. Please see TU below to change or
      update statistics.


:HEADER2 TU
:HEADERT Display and Update Member Statistics

      displays the statistics associated with a member and, if
      not cancelled, will update the statistics for that member.
      It is invoked by entering it on a member list under Browse,
      Edit or View, e.g.

         VIEW              USERX.CLIST
         Command ===>
                    Name     Prompt       Size   Created
         tu_______ ADDLINEB                  4  2002/09/14  2002/...
         _________ ADDLINES                 90  2002/09/14  2002/...
         _________ ALIGN                    68  2002/09/14  2002/...

      which might result in the following being displayed:

            -- PDS Statistics Display/Update                   --

          PDS:  USERX.CLIST
          MEM:  ADDLINEB

          Version:     12
          Mod Count:   00
          Create Dt:   02/09/14
          Change Dt:   02/09/14
          Change Tm:   07:56
          Initial Sz:  4
          Current Sz:  4
          UserID:      USERX

            -- Press <ENTER> to update or <PF3> (END) to Quit  --

      which, if any statistics are changed and <Enter> is
      pressed, will result in the member's statistics being
      updated. Please see TD above to remove statistics. If there
      were no statistics and only some are entered, ISPF will
      enter reasonable default values.


:HEADER1 Miscellaneous Macros

 The following macros are not easily classifiable. Against that,
 they are often useful.

 Built in help is available by either typing the macro name
 without any parameters or with just a question mark (?) as the
 only operand.


:HEADER2 ADDLINES   MEMBER  ( LOCATION )  ( PREFIX )
:HEADERT Copy a Member Before/After All Other Members

       will copy a member of a PDS being edited before or after
       every other member in that PDS except the copied member.
       MEMBER is the data member to be copied. LOCATION must be
       either BEFORE or AFTER (BEFORE is the default). PREFIX may
       be used to limit the members changed to only those that
       begin with the specified prefix.  For example,

          ADDLINES  JOBCARD  BEFORE  JCL

       will copy the member named JOBCARD to the beginning of
       every member with the prefix JCL.

       Two associated macros are ADDLINEA and ADDLINEB, used
       to do the copy after and copy before, respectively.


:HEADER2 ALLMEM   MACRO  ( PREFIX )
:HEADERT Execute a Macro Against All Members

       will execute a macro against every member of a PDS being
       edited (edit any member and then invoke ALLMEM).  MACRO is
       the macro code to be executed.  PREFIX is optional and may
       be used to limit the members processed to only those that
       begin with the specified prefix.  For example,

          ALLMEM  ALLMEMC

       will execute the macro ALLMEMC against every member of the
       PDS.  The macro might look like:

          /*** REXX  --  CHANGE STRINGS  --  USE WITH ALLMEM  ***/
             "ISREDIT MACRO"
             "ISREDIT C  ALL 'OLD ACCOUNT INFO' 'NEW ACCOUNT INFO' "
             "ISREDIT END"

       Note the END which forces the member to be saved and
       allows processing to go on to the next member.  Two
       associated macros in this package are ALLMEMC which
       resembles the above code for changes and ALLMEMF which
       does a find for a string and only brings up the members
       that have the string, like:

          /*** REXX  --  FIND SOME STRING  --  USE WITH ALLMEM  ***/
             "ISREDIT MACRO"
             "ISREDIT SEEK  'DB2 ENVIRONMENT' "
             IF RC <> 0 THEN "ISREDIT END"

       An example follows to scan members whose first character
       is an 'A' and then delete all lines within those members
       that contain 15 dots (...............).

          /*** REXX  --  FIND AND DELETE LINES OF 'A' MEMBERS  ***/
             "ISREDIT MACRO"
             "ISREDIT (PARMS) = MEMBER"
             "ISREDIT SEEK  '...............'"
             DO WHILE RC = 0
                "ISREDIT (LINE,COL) = CURSOR"
                IF SUBSTR(PARMS,1,1) = 'A' THEN DO
                   "ISREDIT DELETE &LINE"
                END
                "ISREDIT SEEK  '...............'"
             END
             "ISREDIT END"

       Please also see XALLMEM below for a macro that does the
       same function but may be executed from outside the PDS.


:HEADER2 ALLOCGDX  DSN | ? ( other Allocate parameters )
:HEADERT Allocate a Relative GDG as an Absolute Data Set

       does equivalent of Allocate for a relative GDG entry
       translating the relative numbered data set into a fully
       qualified G....V00 name. For example:

          AllocGDx 'rubber.ducky(-1)' dd(...) ...

       would allocate the -1 file as the fully named
       'rubber.ducky.g0011v00' (if appropriate).

       Any additional normal Allocate parameters are passed as
       is. The DSN may be quoted as shown or not, i.e. picking up
       the prefix.  Use no parameters or a standalone ? to get
       built-in help.


:HEADER2 BS   ( RECORD-LENGTH )  ( ? )
:HEADERT Determine Optimal Block Size

       will ask for a record length, if not provided, and display
       back the maximum normal (based on 32,760) block size, a
       reasonably optimal block size based on 3390 half track
       blocking (27,998 is half a track), and a large tape block
       size based on 262,144 (256K appears to be the normal site
       default). An example for "TSO BS 333" is:

            LRECL 333, MAX BLKSZ= 32634,
               OPT 3390 BLKSZ=27972 & LARGE BLKSZ=262071

       Specifying a question mark as the parameter will cause the
       built in help to be displayed.


:HEADER2 CC
:HEADERT Provide Simple Calculator Functions

       will allow REXX arithmetic by direct input. It will
       provide a quick intro line:

          **  ENTER CALCUATIONS AND NULL ENTER TO QUIT...  **

       All standard REXX arithmetic statements may then be
       entered and the response immediately follows.  For
       example,

          (233+17)**2

      returns 62500, effectively 250 squared.  Obviously,
      parentheses may be used to force the order of operations
      and/or make the logic of the operation more apparent.

      In addition to + for addition, - for subtraction, * for
      multiplication and / for division, // does a remainder
      equivalent operation (16//5 is 1) and % does pure integer
      division (16%5 is 3).  ** performs exponentiation.

      The formula, courtesy of REXX, does not need to be
      completely contiguous, so the following produce the same
      result.

         ( 233 + 17 ) ** 2

      is equivalent to

         (233+17)**2

      As many calculations as desired may be entered and a simple
      null (press of <ENTER> without any input) entry terminates.


:HEADER2 CLS
:HEADERT Clear the TSO Screen

      hopefully a generic TSO clear screen invocation. It uses
      the CLRSCRN program also from File 357 on the CBT Tape,
      simply invoking it as:

            "CALL 'your.loadlib(CLRSCRN)'"


:HEADER2 COMPRS   ( PDS-NAME )  ( ? )
:HEADERT Compress a PDS Under Edit or From Outside

      compresses either the PDS of the member being edited, the
      default when no PDS-NAME is specified, or the specified
      PDS-NAME.  IEBCOPY is invoked to do the actual compress.
      The question mark will cause the built in help to be
      displayed but will not invoke the compress.


:HEADER2 CONCATDD   DDNAME  DATASET-NAME  ( BOTTOM-OPTION )
:HEADERT Add Files to an Allocation

      concatenates a data set to the DDNAME provided, either at
      the beginning or at the end of the concatenation.  If the
      BOTTOM-OPTION is B, the file is concatenated at the bottom.
      The default is to put it at the top. If the only parameter
      passed is a question mark (?), then built in help will be
      displayed. It will check whether the data set exists and
      whether the dd name is actually allocated and issue
      appropriate messages.

      The DATASET-NAME should not be put in quotes and needs to
      be fully qualified.  SYSEXEC and SYSPROC may have datasets
      added to its concatenation wile in ISPF but CONCATDD must
      be invoked outside of ISPF (or in a LOGON EXEC if your site
      has such a thing) if DDNAME is ISPMLIB, ISPLLIB, ISPSLIB,
      or ISPTLIB since they are in use while in ISPF.

         "EX 'YOURID.CLIST(CONCATDD)' 'SYSPROC YOURID.CLIST'"

      in a REXX macro will invoke CONCATDD from yout library and
      add that library at the top of the SYSPROC concatenation.

      If the data set is already in the concatenation, it is
      effectively moved to the top or bottom, as specified.


:HEADER2 DESC
:HEADERT Briefly Describe File from Within Edit/View

      shows the logical record length (LRECL), block size BLKSIZE)
      and number of records in upper right hand corner of display.

      For example, on this file (at this moment), DESC would show
      80/27920/5858.


:HEADER2 ENC  PASSWORD
:HEADERT Provide Simple Password Protection for Data

      encrypts a fixed format sequential file or member using
      the specified password. Invoking it again with the same
      password unencrypts the data.  It is not an extremely
      secure method but does provide a fast way to hide
      information. Passwords can be of any length.

      The process uses some shifting to assure shallow testing
      will not show the bit pattern used and to provide a
      measure of protection even with one character passwords.
      It may be invoked more then once, i.e. ENC XXX and then
      ENC YYY. Invoking ENC in the reverse order, ENC YYY and
      then ENC XXX will return the data to its original state.

      Caution should be used to remember the password since it
      may be difficult to recreate the file without the correct
      password. Unencrypting before saving and then
      re-encrypting would validate there was no error during
      typing.

      ENC2, described below, improves upon ENC in both hiding
      data and protecting it. ENC has been left in the package
      since it would be necessary for anyone who has data
      encrypted using it.


:HEADER2 ENC2  PASSWORD
:HEADERT Provide Improved Simple Password Protection for Data

      encrypts a file or member of any record format using the
      specified password. Invoking it again with the same
      password unencrypts the data.  It is not an extremely
      secure method but does provide a fast way to hide
      information. Passwords can be of any length.

      The process uses the password to generate a series of
      random overlays (exclusive or'ing) and to provide a
      measure of protection even with one character passwords.
      It may be invoked more then once, i.e. ENC2 XXX and then
      ENC2 YYY. Invoking ENC2 in the reverse order, ENC2 YYY and
      then ENC2 XXX will return the data to its original state.

      ENC2 improves upon ENC above in that it is more sensitive
      to the password and is not as repetitive, and uses
      randomization more effectively.  ENC is still included
      since someone may have encrypted data using it.

      As an example, encrypting a simple file using "A" as the
      password will protect all the data if "a" is tried. ENC
      would show some data.

      Caution should be used to remember the password since it
      may be difficult to recreate the file without the correct
      password. Unencrypting after saving and then
      re-encrypting would validate there was no error during
      typing.


:HEADER2 FOG  ( # )  ( ? )
:HEADERT Produce Sentences of Meaningless Text

      generates pseudo random meaningless sentences useful for
      testing with text or fleshing out meaningless documentation.
      # is the number of sentences to be generated and defaults to
      1. The generated text will be inserted either where the
      cursor is positioned or immediately below the top line on
      the displayed screen. For example, FOG 2 might produce:

            In this regard, the independent functional
            principle presents extremely interesting
            challenges to the greater fight-worthiness
            concept.   We can see, in retrospect, the
            interrelation of system and/or subsystem
            technologies is further compounded when taking
            into account the management-by-contention
            principle.

      The CAPS ON|OFF setting will determine whether the text is
      all upper or mixed case. If only the question mark is
      entered, the built in help is displayed and no text is
      generated. FOG may be useful for testing text applications
      or padding required documentation, just to see if someone
      actually reads it.


:HEADER2 FS  ( 'STRING TO BE FOUND' PDS-TO-BE-SEARCHED )  ( ? )
:HEADERT Submit a Job to Scan a PDS(E) for a String

      submits a job using the user ID of the TSO user to do
      a SuperC scan of a PDS or PDSE for a given string.
      For Example:

        FS  'STRING TO BE FOUND'  PDS-TO-BE-SEARCHED

      The user's ID will be used for the job name prefix, the
      name field and the NOTIFY.

      The string to be sought must be in quotes, either single or
      double. The PDS(E) may be either unqualified, without
      quotes where the user's ID will be prefixed, or within
      quotes as a fully qualified name.

      A question mark (?) as the only parameter or no parameters
      at all will cause the built in help to be displayed.


:HEADER2 NEW  ( Data-Set Prime Secondary Format Rec-Length )  ( ? )
:HEADERT Allocate a New Sequential File

       will allocate a file as NEW with the attributes specified.
       If no parameters are provided or a question mark is given
       as the first parameter, built in help will be displayed.

       The Data-Set name may be provided without quotes whence it
       will have the profile's prefix appended to its beginning
       (note this is usually the user ID). If a single quote is
       placed on both ends, that fully qualified name will be used.

       The Prime and Secondary parameters indicate the primary
       and secondary space parameters (in cylinders).

       The Format provides th record format. FB, F, VB, V and U
       are acceptable as well as FBA, FA, VBA, and VA. The
       Rec-Length is the LRECL for all the formats except U where
       it becomes the block size and the LRECL is set to 0. For
       FB, the block size is set to a multiple of the LRECL less
       then 27,998. For F, the block size is set to the LRECL.
       For VB, the block size is set to 27,998. For V, the block
       size is set to the LRECL + 4.

       For example, specifying

          NEW  $$$TEMP.DATA  5 2  FB 100

       will create a new data set named userid.$$$TEMP.DATA
       with a primary of 5 cylinders and a secondary of 2, and
       its attributes will be fixed blocked, LRECL of 100, and
       block size of 27,900.


:HEADER2 NEWP ( PDS-Name Prime Secondary Dir Format Rec-Length ) ( ? )
:HEADERT Allocate a New Partitioned Data Set

       will allocate a PDS as NEW with the attributes specified.
       If no parameters are provided or a question mark is given
       as the first parameter, built in help will be displayed.

       The Data-Set name may be provided without quotes whence it
       will have the profile's prefix appended to its beginning
       (note this is usually the user ID). If a single quote is
       placed on both ends, that precise name will be used.

       The Prime and Secondary parameters indicate the primary
       and secondary space parameters (in cylinders). The Dir
       parameter indicates the number of directory blocks to
       be provided.

       The Format provides the record format.  F, FB, FA, FBA, V,
       VB, VA, VBA and U are acceptable.  And the Rec-Length is
       the LRECL for all the formats except U where it becomes
       the block size and the LRECL is set to 0. For FB, the
       block size is set to a multiple of the LRECL less then
       27,998. For F, the block size is set to the LRECL. For VB,
       the block size is set to 27,998. For V, the block size is
       set to the LRECL + 4.

       For example, specifying

          NEWP  'SYS4.MACLIB.BACKUP' 20 10 89  FB 80

       will create a new PDS named SYS4.MACLIB.BACKUP with a
       primary space allocation of 20 cylinders, a secondary of
       10, and 89 directory blocks (45 fit on every 3390 track
       except the last where the end of file marker reduces the
       number to 44).  Its attributes will be fixed blocked,
       LRECL of 80, and block size of 27,920.


:HEADER2 OPCODE  HEX-VALUE
:HEADERT Describe a Machine Operation Code

      will give a brief description of the assembler instruction
      associated with the hex value. For example,

         OPCODE  41

      will show:

         OP CODE '41' IS LOAD ADDRESS
            WITH MNEMONIC LA        AND IS A(N)   RX   INSTRUCTION


:HEADER2 PACKDS  IN-DATA-SET  OUT-DATA-SET
:HEADERT Compress a File using IBM's TRSMAIN

      will use IBM's free TRSMAIN utility to compress one
      file into another new file created by the EXEC. So,

         PACKDS  'QDSN.S020701.DATA' COMPRSED.S020701.DATA

      will create the second file and compress the first into it.
      This macro may be run from the Edit/View command line
      or from a TSO command prompt.


:HEADER2 PDS2SEQ   PDS-name  Seq-Out-File  ( NOSEP )  ( ADD | REPLACE )
:HEADERT Unload a PDS to a Sequential File

      unloads the specified partitioned data set (PDS) into a
      sequential file with or without IEBUPDTE separator cards.
      The RECFM, LRECL and BLKSIZE of the PDS are used for the
      output file. A primary space parameter of 10 cylinders and
      a secondary of 10 cylinders is used.  The unit parameter is
      set to SYSDA.

      The PDS-name supplies the partitioned data set name, either
      fully qualified within quotes or without quotes where the
      user prefix will be attached. Seq-Out-File names the
      sequential file that will contain the unloaded records
      and may be either fully or partially qualified.

      NOSEP will cause no ./ separator cards to be output before
      each member's data; the default is to generate them.  ADD
      or REPLACE will change the option on the separator card
      respectively to ADD or REPL, that is ./  ADD NAME=member.,
      ADD is the default.

         PDS2SEQ  'USER.MACLIB'  UNLOAD.USER.MACLIB  NOSEP

      will cause the entire contents of 'USER.MACLIB' to be placed
      in the sequential file 'user-prefix.UNLOAD.USER.MACLIB'
      without any separator cards.


:HEADER2 SAVEINPL  ( ? )
:HEADERT Save a Member in Place

      will save the edited member in place, that is, it will
      overlay the existing member.  The edited file must be a
      member of a fixed length partitioned data set (record
      format must be F or FB).  Also, the number of lines must
      not have changed.  Note that it will not change the member
      statistics (if any) and will issue a warning to that
      effect.

      Uses in core read and write, and so may be vulnerable to
      out of memory conditions.Does not work with PDSE's.


:HEADER2 SLEEP  ( NUMBER-OF-SECONDS | ? )
:HEADERT Pause for Given Number of Seconds

      will delay responding the number of seconds specified,
      defaulting to 5. If a question mark (?) or non numeric
      value is specified, the built in help is displayed.  The
      SYSCALLS environment must be available. This may be
      useful for imbedding within another macro for usability or
      simulation testing.


:HEADER2 TODAY  ( CCYYMMDD | CCYYDDD )  ( ? )
:HEADERT Provide Variations of Given Date

      will display a message of the form

         Friday December 31st, 1999 (day 365) Lillian(152,384)

      for either of the 2 date formats specified. If no date is
      specified, today's date will be used.  The above message
      would have come out if either

         TSO  TODAY  1999365

      or

         TSO  TODAY  19991231

      were invoked. A parameter of a question mark (?)  will
      cause the built in help to be displayed. If the input date
      is less then 15821015 (Lillian date 1), the resulting
      Lillian date will be negative.


:HEADER2 TSJ  ( ? )
:HEADERT Split/Join Line at Cursor

      performs the equivalent of the TS (text split) prefix
      command, optimumly assigned to a PFKey.  Simply place the
      cursor under the column where the line is to be broken and
      invoke TSJ.  The new line has the same indentation.

      If the cursor is placed after all non-blank data on the
      line, the next line is "joined" at the point where the
      cursor is.  All blanks at the front of the next line are
      removed before being joined at the cursor point.


:HEADER2 UNPACKDS  IN-DATA-SET  OUT-DATA-SET
:HEADERT Decompress a File using IBM's TRSMAIN

      will use IBM's free TRSMAIN utility to decompress one
      file into another new file created by the EXEC. So,

         UNPACKDS  COMPRSED.S020701.DATA  'QDSN.S020701.DATA'

      will create the second file and decompress the first into
      it. This macro may be run from the Edit/View command line
      or from a TSO command prompt.


:HEADER2 VSAVE  ( ? )
:HEADERT Save File or Member from within VIEW

      will allow the VIEWed file or member to be saved, including
      any changes.  VSAVE works for sequential files, PDS's and
      PDSE's.  It saves having to do a multi-screen replace but
      remains in VIEW mode.  If a question mark (?) is specified
      as the parameter, the built in help is displayed.

      You still remain in View after the save is complete.


:HEADER2 VWV  ( ( limits )  VSAM-file-name ) ( ? )
:HEADERT Extract and View All or Part of a VSAM File

       pulls all or part of a specified VSAM file to a sequential
       file under the user's ID of the form
       $$$TEMP.VSAM.FLAT.FLhhmmss (where hhmmss is the time).
       Limits as to the number of records to be pulled and other
       constraints may be specified and must be before the VSAM
       file name.

       The limits may be COUNT(#), SKIP(#), FROMKEY(key),
       TOKEY(key), FROMNUMBER(#), or TONUMBER(#), all IDCAMS
       REPRO qualifiers.

       The VSAM file name can be specified or defaulted from a DS
       List entry.  It may be either unqualified, without quotes
       where the user's ID will be prefixed, or within quotes as
       a fully qualified name.

       VWV puts you in View on the set specified and saves the
       time-stamped file upon exit.

       For example:

          VWV  COUNT(500)  FROMKEY(XXX)  A-VSAM-FILE-UNDER-YOUR-ID

       will View the first 500 records of that file starting at
       key XXX and keep the file on exiting.

       A question mark (?) as the only parameter or no parameters
       at all will cause the built in help to be displayed.


:HEADER2 XALLMEM  ( ? )  PDS  MACRO
:HEADERT Execute Macro Against Every PDS Member from Outside

      will execute the macro specified against every member of
      the partitioned data set named.  It may be invoked from
      anywhere.  The macro must be accessible through SYSPROC or
      SYSEXEC.  If a question mark (?) is specified as the first
      parameter or no parameters are specified, the built in help
      is displayed.

      An example is:

         TSO  XALLMEM  'SYS4.JOBLIB'  ALLMEMC

      will execute ALLMEMC against every member of 'SYS4.JOBLIB'.
      Quotes may be left off a data set under your user-ID, such
      as:

         TSO  XALLMEM  A.PDS.UNDER.YOUR.USERID  ALLMEMC

      XALLMEM will not execute against a member with the same
      name as the macro to be executed.Please see ALLMEM above
      for sample EXEC's to be executed.


:HEADER2 ZVW  ( ? )
:HEADERT View Data Set Under Cursor

      will attempt to View the dataset on which the cursor is
      positioned. If there are & variables in the dataset name,
      i.e. it's a PROC, the macro will attempt to fill in from
      any PROC statement at the top of the file.  This works best
      when assigned to a PF Key.

      It opens the View within a new screen to allow swapping
      back and forth.  Code to just do a View (within the same
      screen session) is included but commented out.  A question
      mark as the only parameter typed will cause built in help
      to be displayed.


:HEADER1 Things You May Never Want to Do

 The following issues were quickly resolved using the above
 macros.  As the header of this unit implies, you may never
 encounter these "problems."  On the other hand, who knows...

 1) Given a file of records and a list of account numbers,
    identify those records that are on the account list.  Let's
    suppose the records have a ten digit account number in
    columns 21 through 30 (10 bytes) and the account list is in
    columns 1 through 10.

    Let's assume that all the account numbers in the record file
    are unique and that each record file line has non blank
    characters in columns 1 through 20. It's easy to check the
    former condition via FINDDUPS and make the latter true by
    doing a "C P'=' '!' 1 ALL" after the CLONE below and removing
    that special character later.

       CLONE the record file (for safety and to have the matched
       records in one place)

       Edit the record file and XCOPY the account file to the bottom

       Shift the accounts 20 bytes to the right (do a "))20" on
       the top account line and bottom account line)

       FINDDUPS 21 30 (sort and show only those non-unique account
       numbers

       Any unexcluded lines are dups, that is, the record file
       and the included account list have the same account
       numbers, so do a "DELETE ALL X" which removes the
       unmatched records

       Exclude everything ( "X 99999" on the first prefix line)

       Do a "F '                    ' 1 ALL" (finds the lines with
       blanks in columns 1 through 20, i.e. the account numbers)

       DELETE NX ALL (removes the account number, leaving the records)

 2) Given a "catastrophic" error when doing an Easytrieve (yes,
    that's the term the error message uses), you can check for
    dups within a table load using FINDDUPS start-col1 end-col1.
    There was no other elaborating text for the error.

 3) To create a partial file of test data from a very large file
    which will not be tolerated by Edit, simply CLONE the file
    with the EMPTY option, Edit the empty new file and XCOPY in
    some subset of the original file. You could copy the first
    50, middle 100 and last 50 records, for example. You can then
    free, via an 'F' command on ISPF 3.4 (DS List) the additional
    space.

    If the file to be edited is variable with block size 27,998,
    run HOWLONG against the file frist to get the longest record
    size. Then CLONE the file to that record size plus 4 (for the
    length). Quite often this will be sufficient to allow editing
    since Edit apepars to allocate room for the maximum record
    size.

    See also VWV for a similar extract facility for VSAM.

 4) To set a date as part of a data set name or even pass it as a
    PARM value to a program, use the date tokens (&YYMMDD for
    example) in SUBX. So the JCL stays the same but the submitted
    JCL contains the date (or any of the other allowed tokens).
    SUBX may be used in member lists too and the regular SUB
    command causes a page enter (3 asterisks appear the bottom of
    the page and you must press <Enter> to procede while SUBX
    does the submit and returns control saving one whole
    keystroke :)

    For consistency and documentation reasons, you might want to
    make ORIGIN the default parameter for your version of SUBX
    (or use the new SUBO) and always use it in place of plain
    SUB.

 5) If your group has a file of data sets that are accessed on
    a regular basis (a dumb 'read' to keep the data set from
    being archived or deleted), use GETDSNS to retrieve a group
    of data sets by wildcard. For example, GETDSNS SYS3.ARDX.*.
    This is a lot faster (and more accurate) the typing them or
    cutting and pasting.

    If you need such a program, I'd suggest FOREVER on this same
    CBT Tape file.  While this goes against what the DASD group
    is trying to accomplish, it may be your only way to get your
    job done.

 6) To columnize data, i.e. put every word on a new line:
       - do a SHIFT L 999 MAX to get data aligned against the
         left hand margin
       - do a DELBLANK
       - do a TF2 on the first line

 7) Suppose you have a very large data set and you want to
    eliminate most of the data and consolidate it to a smaller
    file but it's too big to edit.  CLONE the file to a back up
    copy first (for safety both against finger-fumbles and lights
    out). Then do a KEEPCOLS against the file in DS List
    specifying the columns (one or more sets) to be kept. Then
    finally CLONE that file specifying the new record length.

    Let's consider a 500,000 record file named
    USERID.REALLY.BIG.FILE of 300 bytes each, and suppose you
    need the first 10 columns and the last 10.

    Back it up by doing a "CLONE  =.BKUP". Then do
    "KEEPCOLS  1 10  291 300" and finally a "CLONE  =.NEW  20".
    You will now have 3 data sets, the original in
    USERID.REALLY.BIG.FILE.BKUP, the changed one in
    USERID.REALLY.BIG.FILE, and the new small one in
    USERID.REALLY.BIG.FILE.NEW.

 8) If you want to reformat a file in Edit/View, I'd suggest:
       - CLONE the file first (for safety)
       - save periodically
       - put a sample of what you want as a result at the top
         of the file and use labels to limit the changes
       - work consistently from right to left
       - stack commands using the semi-colon, e.g.
         DELCOLS 1 7; FILLINS 22 '-->';MOVEINSD 43 55 27

 9) To add a number of header lines after every 50 lines of a
    data file:
       - given:
            A1 ... first 50 lines ...
            B2 ... second 50 lines ...
            C3 ... third 50 lines ...
            D4 ... last 50 lines ...
       - CUTX just the header lines
       - add a blank line before A1
       - put a C9999 on the blank line just inserted
       - enter 'PASTEAFT 50' on the command line and press enter
       - delete the blank line
       - you may have to delete the very last lines if there were
         an even 50 multiple of data lines

